# BLUEPRINT FITNESS - Technical Architecture Plan

## Technology Stack Overview

### Frontend Framework
- **React 19**: Latest React version with concurrent features and improved performance
- **TypeScript 5.9**: Strong typing system for enhanced developer experience and code reliability
- **Vite 6.3**: Modern build tool for fast development and optimized production builds
- **PWA Support**: Progressive Web App capabilities with offline functionality via vite-plugin-pwa

### UI Framework & Styling
- **Material-UI v7.3**: Comprehensive React component library with modern design system
- **Emotion**: CSS-in-JS styling solution for dynamic theming and component styling
- **Framer Motion 12**: Advanced animation library for smooth user interactions
- **MUI X Components**: Extended component suite including data grids, charts, and date pickers

### State Management Architecture
- **Zustand 5.0**: Lightweight state management for simple global state
- **XState 5.20**: Sophisticated state machines for complex workflow management (workout sessions, training plan editor)
- **React Query (TanStack) 5.85**: Server state management, caching, and synchronization
- **React Hook Form 7.62**: Efficient form management with validation

### Database & Persistence
- **WatermelonDB 0.28**: Reactive offline-first database built on IndexDB

### Development & Testing Stack
- **Vitest 3.2**: Fast unit testing framework with Vite integration
- **Testing Library**: React testing utilities for component testing
- **Stryker 9.0**: Mutation testing for test quality assurance
- **ESLint 9.33**: Code linting with zero-warning policy
- **Prettier 3.6**: Code formatting for consistent style

### Development Tools
- **Plop 4.0**: Code generation tool for consistent component creation
- **Storybook 8.6**: Component development and documentation
- **i18next 25.4**: Internationalization with TypeScript integration
- **ts-morph 26.0**: TypeScript AST manipulation for documentation generation

## Architectural Patterns

### 6-Layer Clean Architecture

#### 1. Domain Layer (Pure Business Logic)
- **Location**: `src/shared/domain/`, `src/features/*/domain/`
- **Responsibilities**: 
  - Business entities and value objects
  - Domain events and event handlers
  - Business rules and validation logic
  - Repository interfaces (contracts)
- **Dependencies**: None (pure TypeScript classes)
- **Key Components**:
  - `BaseModel`: Base class for all domain entities
  - Value objects: `Weight`, `Duration`, `RPE`, `Counter`
  - Domain events: `WorkoutFinishedEvent`, `NewPersonalRecordEvent`

#### 2. Data Layer (Persistence)
- **Location**: `src/features/*/data/`
- **Responsibilities**:
  - WatermelonDB model implementations
  - Repository pattern implementations
  - Database schema definitions
  - Data access optimizations
- **Dependencies**: Domain layer, WatermelonDB
- **Key Components**:
  - Repository implementations for each domain entity
  - WatermelonDB model classes with reactive queries
  - Database transaction management

#### 3. Service Layer (Application Logic)
- **Location**: `src/features/*/services/`
- **Responsibilities**:
  - Use case orchestration
  - Business workflow coordination
  - Cross-domain operations
  - Application-specific business logic
- **Dependencies**: Domain and Data layers
- **Key Components**:
  - Service classes for complex business operations
  - Integration between multiple repositories
  - Business rule enforcement

#### 4. Query Services (Read Operations)
- **Location**: `src/features/*/query-services/`
- **Responsibilities**:
  - Optimized data fetching
  - Complex query operations
  - Data aggregation and reporting
  - Observable data streams
- **Dependencies**: Data layer, WatermelonDB
- **Key Components**:
  - Specialized query services for each feature
  - Reactive data streams using WatermelonDB observables
  - Performance-optimized queries

#### 5. Hooks Layer (React Integration)
- **Location**: `src/features/*/hooks/`
- **Responsibilities**:
  - React-specific state management
  - Service layer integration
  - UI state coordination
  - React Query integration
- **Dependencies**: Service and Query Service layers
- **Key Components**:
  - Feature-level aggregate hooks (e.g., `useExerciseManagement`)
  - CRUD operation hooks
  - Real-time data subscription hooks

#### 6. UI Layer (Presentation)
- **Location**: Components throughout the application
- **Responsibilities**:
  - User interface rendering
  - User interaction handling
  - Visual state representation
- **Dependencies**: Hooks layer only
- **Key Components**:
  - React components using Material-UI
  - Form components with React Hook Form
  - State machine providers for complex workflows

### Feature-Based Module Structure

Each feature follows a consistent vertical slice architecture:

```
src/features/[feature-name]/
├── domain/              # Business logic and models
│   ├── [Entity]Model.ts
│   ├── I[Entity]Repository.ts
│   └── __tests__/
├── data/                # WatermelonDB persistence
│   ├── [Entity]Repository.ts
│   └── __tests__/
├── services/            # Application services
│   ├── [Feature]Service.ts
│   └── __tests__/
├── query-services/      # Read-optimized operations
│   ├── [Feature]QueryService.ts
│   └── __tests__/
├── hooks/               # React integration layer
│   ├── use[Feature]Management.ts
│   └── __tests__/
├── machines/            # XState machines (if needed)
│   ├── [feature]Machine.ts
│   └── __tests__/
└── store/               # Feature-specific state (if needed)
    ├── [feature]Store.ts
    └── __tests__/
```

## Database Architecture (WatermelonDB)

### Core Tables Structure

#### User Management
- **profiles**: User profiles with basic information
- **user_settings**: Preferences, themes, units
- **user_details**: Extended user information and goals
- **custom_themes**: User-defined color schemes

#### Exercise System
- **exercises**: Exercise library with muscle activation data
- **exercise_templates**: Reusable exercise configurations

#### Training Plans
- **training_cycles**: Periodization containers
- **training_plans**: Workout programs
- **workout_sessions**: Individual workout templates
- **exercise_groups**: Exercise groupings (supersets, circuits)
- **applied_exercises**: Exercises within groups with configurations

#### Workout Execution
- **workout_logs**: Completed workout records
- **performed_groups**: Executed exercise groups
- **performed_exercise_logs**: Exercise execution records
- **performed_sets**: Individual set data with performance metrics
- **workout_states**: Active workout session persistence

#### Body Metrics
- **weight_records**: Weight tracking over time
- **height_records**: Height measurements
- **max_logs**: One-rep max calculations and records

### Database Design Principles

#### Reactive Architecture
- **Observable Queries**: All data access uses WatermelonDB's reactive queries
- **Automatic UI Updates**: UI components automatically re-render when underlying data changes
- **Optimistic Updates**: UI updates immediately with rollback on failure

#### Offline-First Design
- **Local Storage**: All data stored locally in IndexDB
- **No Network Dependency**: Full functionality without internet connection
- **Sync Ready**: Architecture prepared for future cloud synchronization

#### Performance Optimization
- **Lazy Loading**: Data loaded on-demand to minimize memory usage
- **Query Optimization**: Efficient database queries with proper indexing
- **Memory Management**: Automatic garbage collection of unused data

## State Management Strategy

### Multi-Paradigm Approach

#### Simple State: Zustand
- **Use Cases**: Global UI preferences, theme settings, user session
- **Benefits**: Minimal boilerplate, TypeScript-friendly, performance optimized
- **Example**: User preferences, theme selection, language settings

#### Complex Workflows: XState
- **Use Cases**: Multi-step processes like workout execution, training plan editing
- **Benefits**: Predictable state transitions, visual state machine modeling, debugging tools
- **Key Machines**:
  - `workoutMachine`: Active workout session management
  - `sessionEditorMachine`: Training plan editing workflow

#### Server State: React Query
- **Use Cases**: Data fetching, caching, synchronization
- **Benefits**: Automatic caching, background updates, optimistic updates
- **Integration**: Wrapper around WatermelonDB operations for consistency

#### Form State: React Hook Form
- **Use Cases**: All form inputs throughout the application
- **Benefits**: Performance optimization, built-in validation, minimal re-renders
- **Integration**: Custom Material-UI integration via react-hook-form-mui

## Performance Architecture

### Memory Management
- **Immer Integration**: Immutable state updates with structural sharing
- **Component Optimization**: React.memo and useMemo for expensive operations
- **Virtual Scrolling**: Large dataset handling with efficient rendering

### Database Performance
- **Query Batching**: Multiple operations grouped for performance
- **Index Strategy**: Optimized database indexes for common queries

### Bundle Optimization
- **Code Splitting**: Feature-based lazy loading
- **Tree Shaking**: Unused code elimination
- **Asset Optimization**: Image and resource compression

## Testing Strategy

### Multi-Level Testing Approach

#### Unit Tests (Vitest)
- **Domain Layer**: Pure business logic testing
- **Service Layer**: Use case and workflow testing
- **Hooks Layer**: React hook testing with custom utilities
- **Coverage Target**: 90%+ for critical business logic

#### Integration Tests
- **Database Integration**: Full WatermelonDB workflow testing
- **Service Integration**: Cross-layer operation testing
- **Hook Integration**: React Query and state management integration

#### Architecture Tests
- **Dependency Enforcement**: ESLint rules preventing architectural violations
- **Layer Boundary Testing**: Automated verification of clean architecture principles
- **Import Analysis**: Ensuring proper dependency directions

#### Mutation Testing (Stryker)
- **Test Quality Assurance**: Verification that tests actually catch bugs
- **Critical Path Focus**: High-value business logic mutation testing
- **Continuous Quality**: Regular mutation test execution

### Test Database Strategy
- **In-Memory IndexDB**: Fast test database creation and cleanup
- **Data Factories**: Consistent test data generation with @faker-js/faker
- **Transaction Isolation**: Each test runs in isolated database state

## Build & Development Pipeline

### Development Environment
- **Hot Module Replacement**: Instant feedback during development
- **TypeScript Checking**: Real-time type checking and error reporting
- **ESLint Integration**: Zero-warning policy enforcement
- **Prettier Auto-formatting**: Consistent code style maintenance

### Production Build
- **TypeScript Compilation**: Full type checking before build
- **Bundle Analysis**: Size optimization and dependency analysis
- **Asset Optimization**: Compression and caching strategies
- **PWA Generation**: Service worker and manifest creation

## Security Architecture

### Local Data Protection
- **Secure Storage**: Sensitive data isolation and protection
- **Input Validation**: Zod schema validation for all data inputs
- **XSS Prevention**: Content sanitization and safe rendering

### Application Security
- **Memory Protection**: Sensitive data clearing after use
- **State Validation**: Type-safe state management preventing corruption
- **Error Handling**: Secure error reporting without data leakage

## Scalability Considerations

### Data Growth Management
- **Archival Strategy**: Automatic old data archiving for performance
- **Pagination**: Efficient large dataset handling
- **Query Optimization**: Performance maintenance as data grows

### Feature Extensibility
- **Plugin Architecture**: Modular feature addition capability
- **API Abstraction**: Service layer abstractions for external integrations
- **Configuration Management**: Environment-based feature flags

### Cross-Platform Preparation
- **Responsive Design**: Mobile-first responsive layouts
- **Touch Optimization**: Large touch targets and gesture support
- **Capacitor Ready**: Architecture suitable for mobile app deployment

## Documentation & Maintenance

### Code Documentation
- **TypeScript Types**: Self-documenting interfaces and types
- **JSDoc Comments**: Comprehensive API documentation
- **Architecture Decision Records**: Decision rationale documentation

### Auto-Generated Documentation
- **Domain Documentation**: Automated domain model documentation
- **API Documentation**: Service layer API documentation
- **Component Documentation**: Storybook component catalog

### Maintenance Strategy
- **Dependency Management**: Regular updates with compatibility testing
- **Performance Monitoring**: Bundle size and performance tracking
- **Technical Debt**: Regular architectural review and refactoring

## Future Architecture Considerations

### Cloud Integration Readiness
- **API Layer**: Service abstractions ready for remote backends
- **Sync Architecture**: Conflict resolution and merge strategies
- **Authentication**: User identity management preparation

### Mobile Application Path
- **Capacitor Integration**: Native mobile app deployment
- **Platform Optimization**: Platform-specific optimizations
- **Native Feature Access**: Camera, notifications, background processing

### Advanced Features
- **Machine Learning**: Performance prediction and recommendation systems
- **Social Features**: Sharing and community functionality
- **Wearable Integration**: Heart rate and activity tracker support

This technical architecture ensures a robust, maintainable, and scalable fitness tracking application that can evolve with user needs while maintaining high performance and reliability standards.
