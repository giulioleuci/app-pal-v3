{"version":3,"sources":["../../src/FormErrorProvider.tsx","../../src/useTransform.ts","../../src/utils.ts"],"names":["createContext","useContext","jsx","FormErrorProviderContext","error","FormErrorProvider","onError","children","useFormError","useTransform","options","event","propertyExists","obj","prop","getTimezone","adapter","value","readValueAsDate"],"mappings":"AAAA,OACE,iBAAAA,EACA,cAAAC,MAGK,QAgBH,cAAAC,MAAA,oBATJ,IAAMC,EAA2BH,EAAsC,CACrE,QAAUI,GAAUA,GAAO,OAC7B,CAAC,EAEM,SAASC,EAAkB,CAChC,QAAAC,EACA,SAAAC,CACF,EAA8C,CAC5C,OACEL,EAACC,EAAyB,SAAzB,CAAkC,MAAO,CAAC,QAAAG,CAAO,EAC/C,SAAAC,EACH,CAEJ,CAEO,IAAMC,EAAe,IACTP,EAAmCE,CAAwB,GAC3D,QCAZ,SAASM,EAKdC,EACiD,CAcjD,MAAO,CACL,MAbA,OAAOA,EAAQ,WAAW,OAAU,WAChCA,EAAQ,UAAU,MAAMA,EAAQ,KAAK,EACrCA,EAAQ,MAYZ,SAVe,IAAIC,IAAgB,CAC/B,OAAOD,EAAQ,WAAW,QAAW,WACvCA,EAAQ,SAASA,EAAQ,UAAU,OAAO,GAAGC,CAAK,CAAC,EAEnDD,EAAQ,SAAS,GAAGC,CAAK,CAE7B,CAKA,CACF,CClDO,SAASC,EACdC,EACAC,EAC+B,CAC/B,OACE,OAAOD,GAAQ,UACfA,IAAQ,MACR,OAAO,UAAU,eAAe,KAAKA,EAAKC,CAAI,CAElD,CAEO,SAASC,EACdC,EACAC,EACe,CACf,OAAOA,GAAS,MAAQ,CAACD,EAAQ,MAAM,QAAQC,CAAwB,EACnE,KACAD,EAAQ,MAAM,YAAYC,CAAwB,CACxD,CAEO,SAASC,EACdF,EACAC,EACc,CACd,OAAI,OAAOA,GAAU,SACfA,IAAU,GACL,KAEFD,EAAQ,MAAM,KAAKC,CAAK,EAE1BA,CACT","sourcesContent":["import {\n  createContext,\n  useContext,\n  type PropsWithChildren,\n  type ReactNode,\n} from 'react'\nimport {FieldError} from 'react-hook-form'\n\nexport type FormErrorProviderProps = {\n  onError: (error: FieldError) => ReactNode\n}\n\nconst FormErrorProviderContext = createContext<FormErrorProviderProps>({\n  onError: (error) => error?.message,\n})\n\nexport function FormErrorProvider({\n  onError,\n  children,\n}: PropsWithChildren<FormErrorProviderProps>) {\n  return (\n    <FormErrorProviderContext.Provider value={{onError}}>\n      {children}\n    </FormErrorProviderContext.Provider>\n  )\n}\n\nexport const useFormError = () => {\n  const errorCtx = useContext<FormErrorProviderProps>(FormErrorProviderContext)\n  return errorCtx?.onError\n}\n","import {\n  FieldPath,\n  FieldValues,\n  PathValue,\n  UseControllerReturn,\n} from 'react-hook-form'\n\nexport type UseTransformOptions<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = {\n  value: UseControllerReturn<TFieldValues, TName>['field']['value']\n  onChange: UseControllerReturn<TFieldValues, TName>['field']['onChange']\n  transform?: {\n    input?: (value: PathValue<TFieldValues, TName>) => TValue\n    output?: (...event: any[]) => PathValue<TFieldValues, TName>\n  }\n}\n\nexport type UseTransformReturn<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = {\n  value: TValue\n  onChange: UseControllerReturn<TFieldValues, TName>['field']['onChange']\n}\n\nexport function useTransform<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  options: UseTransformOptions<TFieldValues, TName, TValue>\n): UseTransformReturn<TFieldValues, TName, TValue> {\n  const value =\n    typeof options.transform?.input === 'function'\n      ? options.transform.input(options.value)\n      : options.value\n\n  const onChange = (...event): void => {\n    if (typeof options.transform?.output === 'function') {\n      options.onChange(options.transform.output(...event))\n    } else {\n      options.onChange(...event)\n    }\n  }\n\n  return {\n    value,\n    onChange,\n  }\n}\n","import {type PickerValidDate} from '@mui/x-date-pickers'\nimport {useLocalizationContext} from '@mui/x-date-pickers/internals'\n\nexport function propertyExists<X, Y extends PropertyKey>(\n  obj: X,\n  prop: Y\n): obj is X & Record<Y, unknown> {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    Object.prototype.hasOwnProperty.call(obj, prop)\n  )\n}\n\nexport function getTimezone<TDate extends PickerValidDate>(\n  adapter: ReturnType<typeof useLocalizationContext>,\n  value: TDate\n): string | null {\n  return value == null || !adapter.utils.isValid(value as unknown as Date)\n    ? null\n    : adapter.utils.getTimezone(value as unknown as Date)\n}\n\nexport function readValueAsDate<TDate extends PickerValidDate>(\n  adapter: ReturnType<typeof useLocalizationContext>,\n  value: string | null | TDate\n): TDate | null {\n  if (typeof value === 'string') {\n    if (value === '') {\n      return null\n    }\n    return adapter.utils.date(value) as TDate\n  }\n  return value\n}\n"]}