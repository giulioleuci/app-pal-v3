import { TextFieldProps, TextField, CheckboxProps, FormControlLabelProps, SelectProps, FormControlProps, SelectChangeEvent, InputLabelProps, IconButtonProps, FormLabelProps, RadioProps, SwitchProps, ChipTypeMap, AutocompleteProps, AutocompleteValue, AutocompleteChangeReason, AutocompleteChangeDetails, SliderProps, ToggleButtonGroupProps, ToggleButtonProps } from '@mui/material';
import { FieldValues, FieldPath, UseControllerProps, FieldError, Control, PathValue, UseFormProps, SubmitHandler, SubmitErrorHandler, UseFormReturn, UseControllerReturn } from 'react-hook-form';
export * from 'react-hook-form';
import { ReactNode, ChangeEvent, RefAttributes, PropsWithChildren, FormHTMLAttributes, FormEventHandler, ElementType, SyntheticEvent, CSSProperties } from 'react';
import * as react_jsx_runtime from 'react/jsx-runtime';

type TextFieldElementProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = Omit<TextFieldProps, 'name'> & {
    rules?: UseControllerProps<TFieldValues, TName>['rules'];
    name: TName;
    parseError?: (error: FieldError) => ReactNode;
    control?: Control<TFieldValues>;
    component?: typeof TextField;
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => TValue;
        output?: (event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => PathValue<TFieldValues, TName>;
    };
};
type TextFieldElementComponent = <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown>(props: TextFieldElementProps<TFieldValues, TName, TValue> & RefAttributes<HTMLDivElement>) => JSX.Element;
declare const _default$b: TextFieldElementComponent;

type FormContainerProps<T extends FieldValues = FieldValues> = PropsWithChildren<UseFormProps<T> & {
    onSuccess?: SubmitHandler<T>;
    onError?: SubmitErrorHandler<T>;
    FormProps?: FormHTMLAttributes<HTMLFormElement>;
    handleSubmit?: FormEventHandler<HTMLFormElement>;
    formContext?: UseFormReturn<T>;
}>;
declare function FormContainer<TFieldValues extends FieldValues = FieldValues>({ handleSubmit, children, FormProps, formContext, onSuccess, onError, ...useFormProps }: PropsWithChildren<FormContainerProps<TFieldValues>>): react_jsx_runtime.JSX.Element;

type CheckboxElementProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = Omit<CheckboxProps, 'name'> & {
    rules?: UseControllerProps<TFieldValues, TName>['rules'];
    name: TName;
    parseError?: (error: FieldError) => ReactNode;
    label?: FormControlLabelProps['label'];
    helperText?: string;
    control?: Control<TFieldValues>;
    labelProps?: Omit<FormControlLabelProps, 'label' | 'control'>;
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => TValue;
        output?: (event: ChangeEvent<HTMLInputElement>, value: TValue) => PathValue<TFieldValues, TName>;
    };
};
type CheckboxElementComponent = <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown>(props: CheckboxElementProps<TFieldValues, TName, TValue> & RefAttributes<HTMLDivElement>) => JSX.Element;
declare const _default$a: CheckboxElementComponent;

type SelectElementProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = Omit<TextFieldProps, 'name' | 'type' | 'onChange'> & {
    rules?: UseControllerProps<TFieldValues, TName>['rules'];
    name: TName;
    options?: TValue[];
    valueKey?: string;
    labelKey?: string;
    type?: 'string' | 'number';
    parseError?: (error: FieldError) => ReactNode;
    objectOnChange?: boolean;
    onChange?: (value: any) => void;
    control?: Control<TFieldValues>;
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => TValue;
        output?: (event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => PathValue<TFieldValues, TName>;
    };
};
type SelectElementComponent = <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown>(props: SelectElementProps<TFieldValues, TName, TValue> & RefAttributes<HTMLDivElement>) => JSX.Element;
declare const _default$9: SelectElementComponent;

type CheckboxButtonGroupProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = {
    options: (TValue | unknown)[];
    helperText?: ReactNode;
    name: TName;
    required?: boolean;
    parseError?: (error: FieldError) => ReactNode;
    label?: string;
    labelKey?: string;
    valueKey?: string;
    onChange?: (data: TValue[]) => void;
    returnObject?: boolean;
    disabled?: boolean;
    row?: boolean;
    control?: Control<TFieldValues>;
    rules?: UseControllerProps<TFieldValues, TName>['rules'];
    checkboxColor?: CheckboxProps['color'];
    labelProps?: Omit<FormControlLabelProps, 'label' | 'control'>;
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => TValue[];
        output?: (value: TValue[]) => PathValue<TFieldValues, TName>;
    };
    defaultValue?: TValue[];
};
type CheckboxButtonGroupComponent = <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown>(props: CheckboxButtonGroupProps<TFieldValues, TName, TValue> & RefAttributes<HTMLDivElement>) => JSX.Element;
declare const _default$8: CheckboxButtonGroupComponent;

type MultiSelectElementProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = Omit<SelectProps, 'value'> & {
    options: TValue[];
    label?: string;
    itemKey?: string;
    itemValue?: string;
    itemLabel?: string;
    required?: boolean;
    rules?: UseControllerProps<TFieldValues, TName>['rules'];
    name: TName;
    parseError?: (error: FieldError) => ReactNode;
    minWidth?: number;
    menuMaxHeight?: number;
    menuMaxWidth?: number;
    helperText?: ReactNode;
    showChips?: boolean;
    preserveOrder?: boolean;
    control?: Control<TFieldValues>;
    showCheckbox?: boolean;
    formControlProps?: Omit<FormControlProps, 'fullWidth' | 'variant'>;
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => TValue[];
        output?: (event: SelectChangeEvent<unknown>, child: ReactNode) => PathValue<TFieldValues, TName>;
    };
    inputLabelProps?: Omit<InputLabelProps, 'htmlFor' | 'required'>;
};
type MultiSelectElementComponent = <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown>(props: MultiSelectElementProps<TFieldValues, TName, TValue> & RefAttributes<HTMLDivElement>) => JSX.Element;
declare const _default$7: MultiSelectElementComponent;

type PasswordElementProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = TextFieldElementProps<TFieldValues, TName, TValue> & {
    iconColor?: IconButtonProps['color'];
    renderIcon?: (password: boolean) => ReactNode;
};
type PasswordElementComponent = <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: PasswordElementProps<TFieldValues, TName> & RefAttributes<HTMLDivElement>) => JSX.Element;
declare const _default$6: PasswordElementComponent;

type RadioButtonGroupProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = {
    rules?: UseControllerProps<TFieldValues, TName>['rules'];
    options: TValue[];
    helperText?: ReactNode;
    name: TName;
    required?: boolean;
    parseError?: (error: FieldError) => ReactNode;
    label?: string;
    labelKey?: string;
    valueKey?: string;
    disabledKey?: string;
    type?: 'number' | 'string';
    emptyOptionLabel?: string;
    onChange?: (value: TValue | string | undefined) => void;
    returnObject?: boolean;
    row?: boolean;
    control?: Control<TFieldValues>;
    labelProps?: Omit<FormControlLabelProps, 'label' | 'control' | 'value'>;
    formLabelProps?: Omit<FormLabelProps, 'required' | 'error'>;
    radioProps?: RadioProps;
    disabled?: boolean;
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => TValue;
        output?: (value: TValue | string | undefined) => PathValue<TFieldValues, TName>;
    };
};
type RadioButtonGroupComponent = <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown>(props: RadioButtonGroupProps<TFieldValues, TName, TValue> & RefAttributes<HTMLDivElement>) => JSX.Element;
declare const _default$5: RadioButtonGroupComponent;

type SwitchElementProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = Omit<FormControlLabelProps, 'control'> & {
    name: TName;
    control?: Control<TFieldValues>;
    switchProps?: SwitchProps;
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => TValue;
        output?: (event: ChangeEvent<HTMLInputElement>, checked: boolean) => PathValue<TFieldValues, TName>;
    };
};
type SwitchElementComponent = <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown>(props: SwitchElementProps<TFieldValues, TName, TValue> & RefAttributes<HTMLLabelElement>) => JSX.Element;
declare const _default$4: SwitchElementComponent;

type PasswordRepeatElementProps<TFieldValues extends FieldValues = FieldValues, TConfirmPasswordName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TPasswordName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TConfirmPasswordValue = unknown> = PasswordElementProps<TFieldValues, TConfirmPasswordName, TConfirmPasswordValue> & {
    passwordFieldName: TPasswordName;
    customInvalidFieldMessage?: string;
};
type PasswordRepeatElementComponent = <TFieldValues extends FieldValues = FieldValues, TConfirmPasswordName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TPasswordName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: PasswordRepeatElementProps<TFieldValues, TConfirmPasswordName, TPasswordName> & RefAttributes<HTMLDivElement>) => JSX.Element;
declare const _default$3: PasswordRepeatElementComponent;

type AutocompleteElementProps<TValue, Multiple extends boolean | undefined, DisableClearable extends boolean | undefined, FreeSolo extends boolean | undefined, ChipComponent extends ElementType = ChipTypeMap['defaultComponent'], TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
    name: TName;
    control?: Control<TFieldValues>;
    options: TValue[];
    loading?: boolean;
    multiple?: Multiple;
    loadingIndicator?: ReactNode;
    rules?: UseControllerProps<TFieldValues, TName>['rules'];
    parseError?: (error: FieldError) => ReactNode;
    required?: boolean;
    label?: TextFieldProps['label'];
    showCheckbox?: boolean;
    matchId?: boolean;
    autocompleteProps?: Omit<AutocompleteProps<TValue, Multiple, DisableClearable, FreeSolo, ChipComponent>, 'name' | 'options' | 'loading' | 'renderInput'>;
    textFieldProps?: Omit<TextFieldProps, 'name' | 'required' | 'label'>;
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => AutocompleteValue<TValue, Multiple, DisableClearable, FreeSolo>;
        output?: (event: SyntheticEvent, value: AutocompleteValue<TValue, Multiple, DisableClearable, FreeSolo>, reason: AutocompleteChangeReason, details?: AutocompleteChangeDetails<TValue>) => PathValue<TFieldValues, TName>;
    };
};
type AutocompleteElementComponent = <TValue, Multiple extends boolean | undefined = false, DisableClearable extends boolean | undefined = false, FreeSolo extends boolean | undefined = false, ChipComponent extends ElementType = ChipTypeMap['defaultComponent'], TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: AutocompleteElementProps<TValue, Multiple, DisableClearable, FreeSolo, ChipComponent, TFieldValues, TName> & RefAttributes<HTMLDivElement>) => JSX.Element;
declare const _default$2: AutocompleteElementComponent;

type SliderElementProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = Omit<SliderProps, 'control'> & {
    name: TName;
    control?: Control<TFieldValues>;
    label?: string;
    rules?: UseControllerProps<TFieldValues, TName>['rules'];
    parseError?: (error: FieldError) => ReactNode;
    required?: boolean;
    formControlProps?: FormControlProps;
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => number | number[] | undefined;
        output?: (event: Event, value: number | number[] | undefined, activeThumb: number) => PathValue<TFieldValues, TName>;
    };
};
type SliderElementComponent = <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>>(props: SliderElementProps<TFieldValues, TName> & RefAttributes<HTMLDivElement>) => JSX.Element;
declare const _default$1: SliderElementComponent;

type SingleToggleButtonProps = Omit<ToggleButtonProps, 'id' | 'value' | 'children'> & {
    id: number | string;
    label: ReactNode;
};
type ToggleButtonGroupElementProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = ToggleButtonGroupProps & {
    required?: boolean;
    label?: string;
    rules?: UseControllerProps<TFieldValues, TName>['rules'];
    name: TName;
    parseError?: (error: FieldError) => ReactNode;
    control?: Control<TFieldValues>;
    options: SingleToggleButtonProps[];
    formLabelProps?: FormLabelProps;
    helperText?: string;
    enforceAtLeastOneSelected?: boolean;
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => TValue;
        output?: (...event: any[]) => PathValue<TFieldValues, TName>;
    };
};
declare function ToggleButtonGroupElement<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown>(props: ToggleButtonGroupElementProps<TFieldValues, TName, TValue>): react_jsx_runtime.JSX.Element;

type TextareaAutosizeElementProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = Omit<TextFieldProps, 'name' | 'type'> & {
    rules?: UseControllerProps<TFieldValues, TName>['rules'];
    name: TName;
    parseError?: (error: FieldError) => ReactNode;
    control?: Control<TFieldValues>;
    resizeStyle?: CSSProperties['resize'];
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => TValue;
        output?: (event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => PathValue<TFieldValues, TName>;
    };
};
type TextareaAutosizeElementComponent = <TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown>(props: TextareaAutosizeElementProps<TFieldValues, TName, TValue> & RefAttributes<HTMLDivElement>) => JSX.Element;
declare const _default: TextareaAutosizeElementComponent;

type FormErrorProviderProps = {
    onError: (error: FieldError) => ReactNode;
};
declare function FormErrorProvider({ onError, children, }: PropsWithChildren<FormErrorProviderProps>): react_jsx_runtime.JSX.Element;
declare const useFormError: () => (error: FieldError) => ReactNode;

type UseTransformOptions<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = {
    value: UseControllerReturn<TFieldValues, TName>['field']['value'];
    onChange: UseControllerReturn<TFieldValues, TName>['field']['onChange'];
    transform?: {
        input?: (value: PathValue<TFieldValues, TName>) => TValue;
        output?: (...event: any[]) => PathValue<TFieldValues, TName>;
    };
};
type UseTransformReturn<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown> = {
    value: TValue;
    onChange: UseControllerReturn<TFieldValues, TName>['field']['onChange'];
};
declare function useTransform<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>, TValue = unknown>(options: UseTransformOptions<TFieldValues, TName, TValue>): UseTransformReturn<TFieldValues, TName, TValue>;

export { _default$2 as AutocompleteElement, AutocompleteElementProps, _default$8 as CheckboxButtonGroup, CheckboxButtonGroupProps, _default$a as CheckboxElement, CheckboxElementProps, FormContainer, FormContainerProps, FormErrorProvider, FormErrorProviderProps, _default$7 as MultiSelectElement, MultiSelectElementProps, _default$6 as PasswordElement, PasswordElementProps, _default$3 as PasswordRepeatElement, PasswordRepeatElementProps, _default$5 as RadioButtonGroup, RadioButtonGroupProps, _default$9 as SelectElement, SelectElementProps, _default$1 as SliderElement, SliderElementProps, _default$4 as SwitchElement, SwitchElementProps, _default$b as TextFieldElement, TextFieldElementProps, _default as TextareaAutosizeElement, TextareaAutosizeElementProps, ToggleButtonGroupElement, ToggleButtonGroupElementProps, UseTransformOptions, UseTransformReturn, useFormError, useTransform };
