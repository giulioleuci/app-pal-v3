{"version":3,"sources":["../src/index.ts","../react-shim.js","../src/TextFieldElement.tsx","../src/FormErrorProvider.tsx","../src/useTransform.ts","../src/FormContainer.tsx","../src/CheckboxElement.tsx","../src/SelectElement.tsx","../src/utils.ts","../src/CheckboxButtonGroup.tsx","../src/MultiSelectElement.tsx","../src/PasswordElement.tsx","../src/RadioButtonGroup.tsx","../src/SwitchElement.tsx","../src/PasswordRepeatElement.tsx","../src/AutocompleteElement.tsx","../src/SliderElement.tsx","../src/ToggleButtonGroupElement.tsx","../src/TextareaAutosizeElement.tsx"],"names":["src_exports","__export","AutocompleteElement_default","CheckboxButtonGroup_default","CheckboxElement_default","FormContainer","FormErrorProvider","MultiSelectElement_default","PasswordElement_default","PasswordRepeatElement_default","RadioButtonGroup_default","SelectElement_default","SliderElement_default","SwitchElement_default","TextFieldElement_default","TextareaAutosizeElement_default","ToggleButtonGroupElement","useFormError","useTransform","__toCommonJS","import_react","import_material","import_react_hook_form","import_jsx_runtime","FormErrorProviderContext","error","onError","children","options","event","TextFieldElement","props","ref","rules","parseError","type","required","name","control","TextFieldComponent","inputRef","transform","onBlur","rest","errorMsgFn","customErrorFn","rulesTmp","field","value","onChange","handleInputRef","handleSubmit","FormProps","formContext","onSuccess","useFormProps","FormProviderWithoutContext","methods","CheckboxElement","label","helperText","labelProps","_event","newValue","renderHelperText","propertyExists","obj","prop","SelectElement","valueKey","labelKey","objectOnChange","isNativeSelect","i","item","key","optionProps","CheckboxButtonGroup","returnObject","disabled","row","checkboxColor","defaultValue","theme","invalid","selectedOptions","handleChange","option","optionValue","existsAtIndex","selectedOption","selectedOptionValue","newValues","_","index","optionLabel","isChecked","import_Cancel","ITEM_HEIGHT","ITEM_PADDING_TOP","MultiSelectElement","itemKey","itemValue","itemLabel","menuMaxHeight","menuMaxWidth","minWidth","showChips","preserveOrder","showCheckbox","formControlProps","inputLabelProps","renderLabel","op","selected","selectedValue","CloseIcon","ev","val","v","import_Visibility","import_VisibilityOff","PasswordElement","iconColor","renderIcon","password","Visibility","VisibilityOff","InputProps","slotProps","setPassword","endAdornment","e","RadioButtonGroup","disabledKey","emptyOptionLabel","formLabelProps","radioProps","onRadioChange","radioValue","returnValue","items","optionKey","optionDisabled","SwitchElement","switchProps","checked","handleSwitchRef","PasswordRepeatElement","passwordFieldName","customInvalidFieldMessage","pwValue","AutocompleteElement","textFieldProps","autocompleteProps","loading","loadingIndicator","multiple","matchId","validationRules","getOptionLabel","isOptionEqualToValue","matchOptionByValue","currentValue","loadingElement","reason","details","params","SliderElement","other","parsedHelperText","enforceAtLeastOneSelected","exclusive","toggleButtonGroupProps","isRequired","id","toggleProps","TextareaAutosizeElement","rows","resizeStyle","maxRows","minRows","inputProps","__reExport"],"mappings":"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","sourcesContent":["'use client'\n\nexport {default as TextFieldElement} from './TextFieldElement'\nexport type {TextFieldElementProps} from './TextFieldElement'\n\nexport {FormContainer} from './FormContainer'\nexport type {FormContainerProps} from './FormContainer'\n\nexport {default as CheckboxElement} from './CheckboxElement'\nexport type {CheckboxElementProps} from './CheckboxElement'\n\nexport {default as SelectElement} from './SelectElement'\nexport type {SelectElementProps} from './SelectElement'\n\nexport {default as CheckboxButtonGroup} from './CheckboxButtonGroup'\nexport type {CheckboxButtonGroupProps} from './CheckboxButtonGroup'\n\nexport {default as MultiSelectElement} from './MultiSelectElement'\nexport type {MultiSelectElementProps} from './MultiSelectElement'\n\nexport {default as PasswordElement} from './PasswordElement'\nexport type {PasswordElementProps} from './PasswordElement'\n\nexport {default as RadioButtonGroup} from './RadioButtonGroup'\nexport type {RadioButtonGroupProps} from './RadioButtonGroup'\n\nexport {default as SwitchElement} from './SwitchElement'\nexport type {SwitchElementProps} from './SwitchElement'\n\nexport {default as PasswordRepeatElement} from './PasswordRepeatElement'\nexport type {PasswordRepeatElementProps} from './PasswordRepeatElement'\n\nexport {default as AutocompleteElement} from './AutocompleteElement'\nexport type {AutocompleteElementProps} from './AutocompleteElement'\n\nexport {default as SliderElement} from './SliderElement'\nexport type {SliderElementProps} from './SliderElement'\n\nexport {default as ToggleButtonGroupElement} from './ToggleButtonGroupElement'\nexport type {ToggleButtonGroupElementProps} from './ToggleButtonGroupElement'\n\nexport {default as TextareaAutosizeElement} from './TextareaAutosizeElement'\nexport type {TextareaAutosizeElementProps} from './TextareaAutosizeElement'\n\nexport {FormErrorProvider} from './FormErrorProvider'\nexport type {FormErrorProviderProps} from './FormErrorProvider'\nexport {useFormError} from './FormErrorProvider'\n\nexport {useTransform} from './useTransform'\nexport type {UseTransformOptions, UseTransformReturn} from './useTransform'\n\nexport * from 'react-hook-form'\n","import React from 'react'\n\nexport {React}\n","import {TextField, TextFieldProps, useForkRef} from '@mui/material'\nimport {\n  Control,\n  FieldError,\n  FieldPath,\n  FieldValues,\n  PathValue,\n  useController,\n  UseControllerProps,\n} from 'react-hook-form'\nimport {useFormError} from './FormErrorProvider'\nimport {ChangeEvent, forwardRef, ReactNode, Ref, RefAttributes} from 'react'\nimport {useTransform} from './useTransform'\n\nexport type TextFieldElementProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = Omit<TextFieldProps, 'name'> & {\n  rules?: UseControllerProps<TFieldValues, TName>['rules']\n  name: TName\n  parseError?: (error: FieldError) => ReactNode\n  control?: Control<TFieldValues>\n  /**\n   * You override the MUI's TextField component by passing a reference of the component you want to use.\n   *\n   * This is especially useful when you want to use a customized version of TextField.\n   */\n  component?: typeof TextField\n  transform?: {\n    input?: (value: PathValue<TFieldValues, TName>) => TValue\n    output?: (\n      event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\n    ) => PathValue<TFieldValues, TName>\n  }\n}\n\ntype TextFieldElementComponent = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: TextFieldElementProps<TFieldValues, TName, TValue> &\n    RefAttributes<HTMLDivElement>\n) => JSX.Element\n\nconst TextFieldElement = forwardRef(function TextFieldElement<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: TextFieldElementProps<TFieldValues, TName, TValue>,\n  ref: Ref<HTMLDivElement>\n) {\n  const {\n    rules = {},\n    parseError,\n    type,\n    required,\n    name,\n    control,\n    component: TextFieldComponent = TextField,\n    inputRef,\n    transform,\n    onBlur,\n    ...rest\n  } = props\n\n  const errorMsgFn = useFormError()\n  const customErrorFn = parseError || errorMsgFn\n\n  const rulesTmp = {\n    ...rules,\n    ...(required && !rules.required && {required: 'This field is required'}),\n    ...(type === 'email' &&\n      !rules.pattern && {\n        pattern: {\n          value:\n            // eslint-disable-next-line no-useless-escape\n            /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\n          message: 'Please enter a valid email address',\n        },\n      }),\n  }\n\n  const {\n    field,\n    fieldState: {error},\n  } = useController({\n    name,\n    control,\n    disabled: rest.disabled,\n    rules: rulesTmp,\n  })\n\n  const {value, onChange} = useTransform<TFieldValues, TName, TValue>({\n    value: field.value,\n    onChange: field.onChange,\n    transform: {\n      input:\n        typeof transform?.input === 'function'\n          ? transform.input\n          : (value) => {\n              return value ?? ('' as TValue)\n            },\n      output:\n        typeof transform?.output === 'function'\n          ? transform.output\n          : (event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n              const value = event.target.value\n              if (type !== 'number') {\n                return value as PathValue<TFieldValues, TName>\n              }\n\n              if (value === '') {\n                return null as PathValue<TFieldValues, TName>\n              }\n\n              if (value == null) {\n                return value\n              }\n\n              return Number(value) as PathValue<TFieldValues, TName>\n            },\n    },\n  })\n\n  const handleInputRef = useForkRef(field.ref, inputRef)\n\n  return (\n    <TextFieldComponent\n      {...rest}\n      name={field.name}\n      value={value}\n      onChange={(event) => {\n        // this will be a breaking change for anyone using transform.output\n        // because now we are passing event instead of event.target.value or +event.target.value\n        onChange(event)\n        if (typeof rest.onChange === 'function') {\n          rest.onChange(event)\n        }\n      }}\n      onBlur={(event) => {\n        field.onBlur()\n        if (typeof onBlur === 'function') {\n          onBlur(event)\n        }\n      }}\n      required={required}\n      type={type}\n      error={!!error}\n      helperText={\n        error\n          ? typeof customErrorFn === 'function'\n            ? customErrorFn(error)\n            : error.message\n          : rest.helperText\n      }\n      ref={ref}\n      inputRef={handleInputRef}\n    />\n  )\n})\nTextFieldElement.displayName = 'TextFieldElement'\nexport default TextFieldElement as TextFieldElementComponent\n","import {\n  createContext,\n  useContext,\n  type PropsWithChildren,\n  type ReactNode,\n} from 'react'\nimport {FieldError} from 'react-hook-form'\n\nexport type FormErrorProviderProps = {\n  onError: (error: FieldError) => ReactNode\n}\n\nconst FormErrorProviderContext = createContext<FormErrorProviderProps>({\n  onError: (error) => error?.message,\n})\n\nexport function FormErrorProvider({\n  onError,\n  children,\n}: PropsWithChildren<FormErrorProviderProps>) {\n  return (\n    <FormErrorProviderContext.Provider value={{onError}}>\n      {children}\n    </FormErrorProviderContext.Provider>\n  )\n}\n\nexport const useFormError = () => {\n  const errorCtx = useContext<FormErrorProviderProps>(FormErrorProviderContext)\n  return errorCtx?.onError\n}\n","import {\n  FieldPath,\n  FieldValues,\n  PathValue,\n  UseControllerReturn,\n} from 'react-hook-form'\n\nexport type UseTransformOptions<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = {\n  value: UseControllerReturn<TFieldValues, TName>['field']['value']\n  onChange: UseControllerReturn<TFieldValues, TName>['field']['onChange']\n  transform?: {\n    input?: (value: PathValue<TFieldValues, TName>) => TValue\n    output?: (...event: any[]) => PathValue<TFieldValues, TName>\n  }\n}\n\nexport type UseTransformReturn<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = {\n  value: TValue\n  onChange: UseControllerReturn<TFieldValues, TName>['field']['onChange']\n}\n\nexport function useTransform<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  options: UseTransformOptions<TFieldValues, TName, TValue>\n): UseTransformReturn<TFieldValues, TName, TValue> {\n  const value =\n    typeof options.transform?.input === 'function'\n      ? options.transform.input(options.value)\n      : options.value\n\n  const onChange = (...event): void => {\n    if (typeof options.transform?.output === 'function') {\n      options.onChange(options.transform.output(...event))\n    } else {\n      options.onChange(...event)\n    }\n  }\n\n  return {\n    value,\n    onChange,\n  }\n}\n","import {FormEventHandler, FormHTMLAttributes, PropsWithChildren} from 'react'\nimport {\n  FieldValues,\n  FormProvider,\n  SubmitErrorHandler,\n  SubmitHandler,\n  useForm,\n  UseFormProps,\n  UseFormReturn,\n} from 'react-hook-form'\n\nexport type FormContainerProps<T extends FieldValues = FieldValues> =\n  PropsWithChildren<\n    UseFormProps<T> & {\n      onSuccess?: SubmitHandler<T>\n      onError?: SubmitErrorHandler<T>\n      FormProps?: FormHTMLAttributes<HTMLFormElement>\n      handleSubmit?: FormEventHandler<HTMLFormElement>\n      formContext?: UseFormReturn<T>\n    }\n  >\n\nexport function FormContainer<TFieldValues extends FieldValues = FieldValues>({\n  handleSubmit,\n  children,\n  FormProps,\n  formContext,\n  onSuccess,\n  onError,\n  ...useFormProps\n}: PropsWithChildren<FormContainerProps<TFieldValues>>) {\n  if (!formContext) {\n    return (\n      <FormProviderWithoutContext<TFieldValues>\n        {...{onSuccess, onError, FormProps, children, ...useFormProps}}\n      />\n    )\n  }\n  if (typeof onSuccess === 'function' && typeof handleSubmit === 'function') {\n    console.warn(\n      'Property `onSuccess` will be ignored because handleSubmit is provided'\n    )\n  }\n  return (\n    <FormProvider {...formContext}>\n      <form\n        noValidate\n        {...FormProps}\n        onSubmit={\n          handleSubmit\n            ? handleSubmit\n            : onSuccess\n              ? formContext.handleSubmit(onSuccess, onError)\n              : () => console.log('submit handler `onSuccess` is missing')\n        }\n      >\n        {children}\n      </form>\n    </FormProvider>\n  )\n}\n\nfunction FormProviderWithoutContext<\n  TFieldValues extends FieldValues = FieldValues,\n>({\n  onSuccess,\n  onError,\n  FormProps,\n  children,\n  ...useFormProps\n}: PropsWithChildren<FormContainerProps<TFieldValues>>) {\n  const methods = useForm<TFieldValues>({\n    ...useFormProps,\n  })\n  const {handleSubmit} = methods\n\n  return (\n    <FormProvider {...methods}>\n      <form\n        onSubmit={handleSubmit(\n          onSuccess\n            ? onSuccess\n            : () => console.log('submit handler `onSuccess` is missing'),\n          onError\n        )}\n        noValidate\n        {...FormProps}\n      >\n        {children}\n      </form>\n    </FormProvider>\n  )\n}\n","import {\n  Control,\n  FieldError,\n  FieldPath,\n  FieldValues,\n  PathValue,\n  useController,\n  UseControllerProps,\n} from 'react-hook-form'\nimport {\n  Checkbox,\n  CheckboxProps,\n  FormControl,\n  FormControlLabel,\n  FormControlLabelProps,\n  FormGroup,\n  FormHelperText,\n  useForkRef,\n} from '@mui/material'\nimport {useFormError} from './FormErrorProvider'\nimport {ChangeEvent, forwardRef, ReactNode, Ref, RefAttributes} from 'react'\nimport {useTransform} from './useTransform'\n\nexport type CheckboxElementProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = Omit<CheckboxProps, 'name'> & {\n  rules?: UseControllerProps<TFieldValues, TName>['rules']\n  name: TName\n  parseError?: (error: FieldError) => ReactNode\n  label?: FormControlLabelProps['label']\n  helperText?: string\n  control?: Control<TFieldValues>\n  labelProps?: Omit<FormControlLabelProps, 'label' | 'control'>\n  transform?: {\n    input?: (value: PathValue<TFieldValues, TName>) => TValue\n    output?: (\n      event: ChangeEvent<HTMLInputElement>,\n      value: TValue\n    ) => PathValue<TFieldValues, TName>\n  }\n}\n\ntype CheckboxElementComponent = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: CheckboxElementProps<TFieldValues, TName, TValue> &\n    RefAttributes<HTMLDivElement>\n) => JSX.Element\n\nconst CheckboxElement = forwardRef(function CheckboxElement<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: CheckboxElementProps<TFieldValues, TName, TValue>,\n  ref: Ref<HTMLDivElement>\n) {\n  const {\n    name,\n    rules = {},\n    required,\n    parseError,\n    label,\n    control,\n    helperText,\n    labelProps,\n    inputRef,\n    transform,\n    ...rest\n  } = props\n\n  const errorMsgFn = useFormError()\n  const customErrorFn = parseError || errorMsgFn\n\n  const rulesTmp = {\n    ...rules,\n    ...(required &&\n      !rules.required && {\n        required: 'This field is required',\n      }),\n  }\n\n  const {\n    field,\n    fieldState: {error},\n  } = useController({\n    name,\n    control,\n    disabled: rest.disabled,\n    rules: rulesTmp,\n  })\n\n  const {value, onChange} = useTransform<TFieldValues, TName, TValue>({\n    value: field.value,\n    onChange: field.onChange,\n    transform: {\n      input: transform?.input,\n      output:\n        typeof transform?.output === 'function'\n          ? transform?.output\n          : (_event, newValue) => newValue,\n    },\n  })\n\n  const handleInputRef = useForkRef(field.ref, inputRef)\n\n  const renderHelperText = error\n    ? typeof customErrorFn === 'function'\n      ? customErrorFn(error)\n      : error.message\n    : helperText\n\n  return (\n    <FormControl required={required} error={!!error} ref={ref}>\n      <FormGroup row>\n        <FormControlLabel\n          {...labelProps}\n          label={label || ''}\n          control={\n            <Checkbox\n              {...rest}\n              color={rest.color || 'primary'}\n              sx={[\n                ...(Array.isArray(rest.sx) ? rest.sx : [rest.sx]),\n                {\n                  color: error ? 'error.main' : undefined,\n                },\n              ]}\n              value={value}\n              checked={!!value}\n              onChange={(event, newValue) => {\n                onChange(event, newValue)\n                if (typeof rest.onChange === 'function') {\n                  rest.onChange(event, newValue)\n                }\n              }}\n              inputRef={handleInputRef}\n            />\n          }\n        />\n      </FormGroup>\n      {renderHelperText && (\n        <FormHelperText error={!!error}>{renderHelperText}</FormHelperText>\n      )}\n    </FormControl>\n  )\n})\nCheckboxElement.displayName = 'CheckboxElement'\nexport default CheckboxElement as CheckboxElementComponent\n","import {ChangeEvent, forwardRef, ReactNode, Ref, RefAttributes} from 'react'\nimport {MenuItem, TextField, TextFieldProps, useForkRef} from '@mui/material'\nimport {\n  Control,\n  FieldError,\n  FieldPath,\n  FieldValues,\n  PathValue,\n  useController,\n  UseControllerProps,\n} from 'react-hook-form'\nimport {useFormError} from './FormErrorProvider'\nimport {useTransform} from './useTransform'\nimport {propertyExists} from './utils'\n\nexport type SelectElementProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = Omit<TextFieldProps, 'name' | 'type' | 'onChange'> & {\n  rules?: UseControllerProps<TFieldValues, TName>['rules']\n  name: TName\n  options?: TValue[]\n  valueKey?: string\n  labelKey?: string\n  type?: 'string' | 'number'\n  parseError?: (error: FieldError) => ReactNode\n  objectOnChange?: boolean\n  onChange?: (value: any) => void\n  control?: Control<TFieldValues>\n  transform?: {\n    input?: (value: PathValue<TFieldValues, TName>) => TValue\n    output?: (\n      event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\n    ) => PathValue<TFieldValues, TName>\n  }\n}\n\ntype SelectElementComponent = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: SelectElementProps<TFieldValues, TName, TValue> &\n    RefAttributes<HTMLDivElement>\n) => JSX.Element\n\nconst SelectElement = forwardRef(function SelectElement<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: SelectElementProps<TFieldValues, TName, TValue>,\n  ref: Ref<HTMLDivElement>\n) {\n  const {\n    name,\n    required,\n    valueKey = 'id',\n    labelKey = 'label',\n    options = [],\n    parseError,\n    type,\n    objectOnChange,\n    rules = {},\n    control,\n    inputRef,\n    transform,\n    onBlur,\n    ...rest\n  } = props\n\n  const errorMsgFn = useFormError()\n  const customErrorFn = parseError || errorMsgFn\n  const isNativeSelect = !!rest.SelectProps?.native\n\n  const rulesTmp = {\n    ...rules,\n    ...(required &&\n      !rules.required && {\n        required: 'This field is required',\n      }),\n  }\n\n  const {\n    field,\n    fieldState: {error},\n  } = useController({\n    name,\n    rules: rulesTmp,\n    disabled: rest.disabled,\n    control,\n  })\n\n  const {value, onChange} = useTransform<TFieldValues, TName, TValue>({\n    value: field.value,\n    onChange: field.onChange,\n    transform: {\n      input:\n        typeof transform?.input === 'function'\n          ? transform.input\n          : (value) => {\n              return value?.[valueKey] ?? value ?? ('' as TValue)\n            },\n      output:\n        typeof transform?.output === 'function'\n          ? transform.output\n          : (event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n              let value: string | number = event.target.value\n              if (type === 'number' && value) {\n                value = Number(value)\n              }\n              return value as PathValue<TFieldValues, TName>\n            },\n    },\n  })\n\n  const handleInputRef = useForkRef(field.ref, inputRef)\n\n  // handle shrink on number input fields\n  if (type === 'number' && typeof value !== 'undefined') {\n    rest.InputLabelProps = rest.InputLabelProps || {}\n    rest.InputLabelProps.shrink = true\n  }\n\n  return (\n    <TextField\n      {...rest}\n      name={name}\n      value={value}\n      onBlur={(event) => {\n        field.onBlur()\n        if (typeof onBlur === 'function') {\n          onBlur(event)\n        }\n      }}\n      ref={ref}\n      onChange={(event) => {\n        onChange(event)\n        if (typeof rest.onChange === 'function') {\n          let value: string | number | TValue | undefined = event.target.value\n          if (type === 'number' && value) {\n            value = Number(value)\n          }\n          if (objectOnChange) {\n            value = options.find((i) => i[valueKey] === value)\n          }\n          // It would be better if we expose event object here, instead of value\n          // This will be a breaking change for user.\n          rest.onChange(value)\n        }\n      }}\n      select\n      required={required}\n      error={!!error}\n      helperText={\n        error\n          ? typeof customErrorFn === 'function'\n            ? customErrorFn(error)\n            : error.message\n          : rest.helperText\n      }\n      inputRef={handleInputRef}\n    >\n      {isNativeSelect && <option />}\n      {options.map((item) => {\n        // Need to clearly apply key because of https://github.com/vercel/next.js/issues/55642\n        const key = `${name}_${item[valueKey]}`\n        const optionProps = {\n          value: item?.[valueKey] ?? item,\n          disabled: propertyExists(item, 'disabled') ? !!item.disabled : false,\n          children: item[labelKey],\n        }\n        // biome-ignore lint/correctness/useJsxKeyInIterable: <explanation>\n        return isNativeSelect ? (\n          <option key={key} {...optionProps} />\n        ) : (\n          <MenuItem key={key} {...optionProps} />\n        )\n      })}\n    </TextField>\n  )\n})\nSelectElement.displayName = 'SelectElement'\nexport default SelectElement as SelectElementComponent\n","import {type PickerValidDate} from '@mui/x-date-pickers'\nimport {useLocalizationContext} from '@mui/x-date-pickers/internals'\n\nexport function propertyExists<X, Y extends PropertyKey>(\n  obj: X,\n  prop: Y\n): obj is X & Record<Y, unknown> {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    Object.prototype.hasOwnProperty.call(obj, prop)\n  )\n}\n\nexport function getTimezone<TDate extends PickerValidDate>(\n  adapter: ReturnType<typeof useLocalizationContext>,\n  value: TDate\n): string | null {\n  return value == null || !adapter.utils.isValid(value as unknown as Date)\n    ? null\n    : adapter.utils.getTimezone(value as unknown as Date)\n}\n\nexport function readValueAsDate<TDate extends PickerValidDate>(\n  adapter: ReturnType<typeof useLocalizationContext>,\n  value: string | null | TDate\n): TDate | null {\n  if (typeof value === 'string') {\n    if (value === '') {\n      return null\n    }\n    return adapter.utils.date(value) as TDate\n  }\n  return value\n}\n","import {\n  Checkbox,\n  CheckboxProps,\n  FormControl,\n  FormControlLabel,\n  FormControlLabelProps,\n  FormGroup,\n  FormHelperText,\n  FormLabel,\n  useTheme,\n} from '@mui/material'\nimport {\n  Control,\n  FieldError,\n  FieldPath,\n  FieldValues,\n  PathValue,\n  useController,\n  UseControllerProps,\n} from 'react-hook-form'\nimport {useFormError} from './FormErrorProvider'\nimport {forwardRef, ReactNode, Ref, RefAttributes} from 'react'\nimport {useTransform} from './useTransform'\nimport {propertyExists} from './utils'\n\nexport type CheckboxButtonGroupProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = {\n  options: (TValue | unknown)[]\n  helperText?: ReactNode\n  name: TName\n  required?: boolean\n  parseError?: (error: FieldError) => ReactNode\n  label?: string\n  labelKey?: string\n  valueKey?: string\n  onChange?: (data: TValue[]) => void\n  returnObject?: boolean\n  disabled?: boolean\n  row?: boolean\n  control?: Control<TFieldValues>\n  rules?: UseControllerProps<TFieldValues, TName>['rules']\n  checkboxColor?: CheckboxProps['color']\n  labelProps?: Omit<FormControlLabelProps, 'label' | 'control'>\n  transform?: {\n    input?: (value: PathValue<TFieldValues, TName>) => TValue[]\n    output?: (value: TValue[]) => PathValue<TFieldValues, TName>\n  }\n  defaultValue?: TValue[]\n}\n\ntype CheckboxButtonGroupComponent = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: CheckboxButtonGroupProps<TFieldValues, TName, TValue> &\n    RefAttributes<HTMLDivElement>\n) => JSX.Element\n\nconst CheckboxButtonGroup = forwardRef(function CheckboxButtonGroup<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: CheckboxButtonGroupProps<TFieldValues, TName, TValue>,\n  ref: Ref<HTMLFieldSetElement>\n) {\n  const {\n    helperText,\n    options,\n    label,\n    name,\n    parseError,\n    required,\n    labelKey = 'label',\n    valueKey = 'id',\n    returnObject,\n    disabled,\n    row,\n    control,\n    checkboxColor,\n    rules,\n    labelProps,\n    transform,\n    defaultValue = [],\n    ...rest\n  } = props\n\n  const theme = useTheme()\n  const errorMsgFn = useFormError()\n  const customErrorFn = parseError || errorMsgFn\n\n  const {\n    field,\n    fieldState: {error, invalid},\n  } = useController({\n    name,\n    rules: required ? {required: 'This field is required'} : rules,\n    disabled,\n    control,\n    defaultValue: defaultValue as PathValue<TFieldValues, TName>,\n  })\n\n  const {value: selectedOptions, onChange} = useTransform<\n    TFieldValues,\n    TName,\n    TValue[]\n  >({\n    value: field.value,\n    onChange: field.onChange,\n    transform: {\n      input:\n        typeof transform?.input === 'function'\n          ? transform.input\n          : (value) => {\n              return Array.isArray(value) ? value : ([] as TValue[])\n            },\n      output: transform?.output,\n    },\n  })\n\n  const handleChange = (option: unknown) => {\n    const optionValue = propertyExists(option, valueKey)\n      ? option[valueKey]\n      : option\n    const existsAtIndex = selectedOptions.findIndex((selectedOption) => {\n      const selectedOptionValue = propertyExists(selectedOption, valueKey)\n        ? selectedOption[valueKey]\n        : selectedOption\n      return optionValue === selectedOptionValue\n    })\n\n    const newValues = (\n      existsAtIndex === -1\n        ? [...selectedOptions, option]\n        : selectedOptions.filter((_, index) => existsAtIndex !== index)\n    ).map((selectedOption) =>\n      returnObject || !propertyExists(selectedOption, valueKey)\n        ? selectedOption\n        : selectedOption[valueKey]\n    ) as TValue[]\n    onChange(newValues)\n    if (typeof rest.onChange === 'function') {\n      rest.onChange(newValues)\n    }\n  }\n\n  const renderHelperText = error\n    ? typeof customErrorFn === 'function'\n      ? customErrorFn(error)\n      : error.message\n    : helperText\n\n  return (\n    <FormControl\n      error={invalid}\n      required={required}\n      ref={ref}\n      component=\"fieldset\"\n    >\n      {label ? <FormLabel component=\"legend\">{label}</FormLabel> : null}\n      <FormGroup row={row}>\n        {options.map((option) => {\n          const optionValue = propertyExists(option, valueKey)\n            ? option[valueKey]\n            : option\n          const optionLabel = propertyExists(option, labelKey)\n            ? option[labelKey]\n            : option\n\n          const isChecked = selectedOptions.some((selectedOption) => {\n            const selectedOptionValue = propertyExists(selectedOption, valueKey)\n              ? selectedOption[valueKey]\n              : selectedOption\n            return selectedOptionValue === optionValue\n          })\n\n          return (\n            <FormControlLabel\n              {...labelProps}\n              control={\n                <Checkbox\n                  sx={{\n                    color: error ? theme.palette.error.main : undefined,\n                  }}\n                  color={checkboxColor}\n                  value={optionValue}\n                  checked={isChecked}\n                  disabled={disabled}\n                  onChange={() => handleChange(option)}\n                />\n              }\n              label={optionLabel as ReactNode}\n              key={`${optionValue}`}\n            />\n          )\n        })}\n      </FormGroup>\n      {renderHelperText && <FormHelperText>{renderHelperText}</FormHelperText>}\n    </FormControl>\n  )\n})\nCheckboxButtonGroup.displayName = 'CheckboxButtonGroup'\nexport default CheckboxButtonGroup as CheckboxButtonGroupComponent\n","import CloseIcon from '@mui/icons-material/Cancel'\nimport {\n  Control,\n  FieldError,\n  FieldPath,\n  FieldValues,\n  PathValue,\n  useController,\n  UseControllerProps,\n} from 'react-hook-form'\nimport {\n  Checkbox,\n  Chip,\n  FormControl,\n  FormControlProps,\n  FormHelperText,\n  InputLabel,\n  InputLabelProps,\n  ListItemText,\n  MenuItem,\n  Select,\n  SelectChangeEvent,\n  SelectProps,\n  useForkRef,\n} from '@mui/material'\nimport {useFormError} from './FormErrorProvider'\nimport {forwardRef, ReactNode, Ref, RefAttributes} from 'react'\nimport {useTransform} from './useTransform'\nimport {propertyExists} from './utils'\n\nexport type MultiSelectElementProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = Omit<SelectProps, 'value'> & {\n  options: TValue[]\n  label?: string\n  itemKey?: string\n  itemValue?: string\n  itemLabel?: string\n  required?: boolean\n  rules?: UseControllerProps<TFieldValues, TName>['rules']\n  name: TName\n  parseError?: (error: FieldError) => ReactNode\n  minWidth?: number\n  menuMaxHeight?: number\n  menuMaxWidth?: number\n  helperText?: ReactNode\n  showChips?: boolean\n  preserveOrder?: boolean\n  control?: Control<TFieldValues>\n  showCheckbox?: boolean\n  formControlProps?: Omit<FormControlProps, 'fullWidth' | 'variant'>\n  transform?: {\n    input?: (value: PathValue<TFieldValues, TName>) => TValue[]\n    output?: (\n      event: SelectChangeEvent<unknown>,\n      child: ReactNode\n    ) => PathValue<TFieldValues, TName>\n  }\n  inputLabelProps?: Omit<InputLabelProps, 'htmlFor' | 'required'>\n}\n\ntype MultiSelectElementComponent = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: MultiSelectElementProps<TFieldValues, TName, TValue> &\n    RefAttributes<HTMLDivElement>\n) => JSX.Element\n\nconst ITEM_HEIGHT = 48\nconst ITEM_PADDING_TOP = 8\n\nconst MultiSelectElement = forwardRef(function MultiSelectElement<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: MultiSelectElementProps<TFieldValues, TName, TValue>,\n  ref: Ref<HTMLDivElement>\n) {\n  const {\n    onBlur,\n    options,\n    label = '',\n    itemKey = 'id',\n    itemValue = '',\n    itemLabel = 'label',\n    required = false,\n    rules = {},\n    parseError,\n    name,\n    menuMaxHeight = ITEM_HEIGHT * 4.5 + ITEM_PADDING_TOP,\n    menuMaxWidth = 250,\n    minWidth = 120,\n    helperText,\n    showChips,\n    preserveOrder,\n    control,\n    showCheckbox,\n    formControlProps,\n    inputRef,\n    transform,\n    inputLabelProps,\n    ...rest\n  } = props\n\n  const errorMsgFn = useFormError()\n  const customErrorFn = parseError || errorMsgFn\n\n  const renderLabel = (item: any) =>\n    options.find((op) => {\n      const optionVal = op[itemValue || itemKey] ?? op\n      return optionVal === item\n    })?.[itemLabel] ?? item\n\n  const rulesTmp = {\n    ...rules,\n    ...(required &&\n      !rules.required && {\n        required: 'This field is required',\n      }),\n  }\n\n  const {\n    field,\n    fieldState: {error},\n  } = useController({\n    name,\n    rules: rulesTmp,\n    disabled: rest.disabled,\n    control,\n  })\n\n  const {value, onChange} = useTransform<TFieldValues, TName, TValue[]>({\n    value: field.value,\n    onChange: field.onChange,\n    transform: {\n      input:\n        typeof transform?.input === 'function'\n          ? transform.input\n          : (value) => {\n              return Array.isArray(value)\n                ? value\n                : ([] as PathValue<TFieldValues, TName>)\n            },\n      output: transform?.output,\n    },\n  })\n\n  const handleInputRef = useForkRef(field.ref, inputRef)\n\n  const renderHelperText = error\n    ? typeof customErrorFn === 'function'\n      ? customErrorFn(error)\n      : error.message\n    : helperText\n\n  return (\n    <FormControl\n      {...formControlProps}\n      style={{\n        minWidth,\n        ...formControlProps?.style,\n      }}\n      variant={rest.variant}\n      fullWidth={rest.fullWidth}\n      error={!!error}\n      size={rest.size}\n      ref={ref}\n    >\n      {label && (\n        <InputLabel\n          {...inputLabelProps}\n          size={rest.size === 'small' ? 'small' : inputLabelProps?.size}\n          error={!!error}\n          htmlFor={rest.id || `select-multi-select-${name}`}\n          required={required}\n        >\n          {label}\n        </InputLabel>\n      )}\n      <Select\n        {...rest}\n        id={rest.id || `select-multi-select-${name}`}\n        multiple\n        label={label || undefined}\n        error={!!error}\n        value={value}\n        required={required}\n        onChange={onChange}\n        onBlur={(event) => {\n          field.onBlur()\n          if (typeof onBlur === 'function') {\n            onBlur(event)\n          }\n        }}\n        MenuProps={{\n          ...rest.MenuProps,\n          slotProps: {\n            ...rest.MenuProps?.slotProps,\n            paper: {\n              ...(rest.MenuProps?.slotProps?.paper ?? {\n                style: {\n                  maxHeight: menuMaxHeight,\n                  width: menuMaxWidth,\n                  ...(propertyExists(\n                    rest.MenuProps?.slotProps?.paper,\n                    'style'\n                  ) &&\n                    typeof rest.MenuProps.slotProps.paper.style ===\n                      'object' && {\n                      ...rest.MenuProps.slotProps.paper.style,\n                    }),\n                },\n              }),\n            },\n          },\n        }}\n        renderValue={\n          typeof rest.renderValue === 'function'\n            ? rest.renderValue\n            : showChips\n              ? (selected) => (\n                  <div style={{display: 'flex', flexWrap: 'wrap', gap: '4px'}}>\n                    {(preserveOrder\n                      ? options.filter((option) =>\n                          (selected as any[]).includes(option)\n                        )\n                      : (selected as any[]) || []\n                    ).map((selectedValue) => (\n                      <Chip\n                        key={selectedValue}\n                        label={renderLabel(selectedValue)}\n                        style={{display: 'flex', flexWrap: 'wrap'}}\n                        onDelete={() => {\n                          onChange(\n                            (Array.isArray(value) ? value : []).filter(\n                              (i: any) => i !== selectedValue\n                            )\n                          )\n                        }}\n                        deleteIcon={\n                          <CloseIcon\n                            onMouseDown={(ev) => {\n                              ev.stopPropagation()\n                            }}\n                          />\n                        }\n                      />\n                    ))}\n                  </div>\n                )\n              : (selected) =>\n                  Array.isArray(selected)\n                    ? selected.map(renderLabel).join(', ')\n                    : ''\n        }\n        inputRef={handleInputRef}\n      >\n        {options.map((item) => {\n          const val: string | number = item[itemValue || itemKey] ?? item\n          const isChecked = Array.isArray(value)\n            ? value.some((v) => v === val)\n            : false\n          return (\n            <MenuItem\n              key={val}\n              value={val}\n              sx={{\n                fontWeight: (theme) =>\n                  isChecked\n                    ? theme.typography.fontWeightBold\n                    : theme.typography.fontWeightRegular,\n              }}\n            >\n              {showCheckbox && <Checkbox checked={isChecked} />}\n              <ListItemText primary={item[itemLabel] || item} />\n            </MenuItem>\n          )\n        })}\n      </Select>\n      {renderHelperText && (\n        <FormHelperText error={!!error}>{renderHelperText}</FormHelperText>\n      )}\n    </FormControl>\n  )\n})\nMultiSelectElement.displayName = 'MultiSelectElement'\nexport default MultiSelectElement as MultiSelectElementComponent\n","import {\n  forwardRef,\n  MouseEvent,\n  ReactNode,\n  Ref,\n  RefAttributes,\n  useState,\n} from 'react'\nimport TextFieldElement, {TextFieldElementProps} from './TextFieldElement'\nimport {IconButton, IconButtonProps, InputAdornment} from '@mui/material'\nimport Visibility from '@mui/icons-material/Visibility'\nimport VisibilityOff from '@mui/icons-material/VisibilityOff'\nimport {FieldPath, FieldValues} from 'react-hook-form'\n\nexport type PasswordElementProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = TextFieldElementProps<TFieldValues, TName, TValue> & {\n  iconColor?: IconButtonProps['color']\n  renderIcon?: (password: boolean) => ReactNode\n}\ntype PasswordElementComponent = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>(\n  props: PasswordElementProps<TFieldValues, TName> &\n    RefAttributes<HTMLDivElement>\n) => JSX.Element\nconst PasswordElement = forwardRef(function PasswordEl<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: PasswordElementProps<TFieldValues, TName, TValue>,\n  ref: Ref<HTMLDivElement>\n) {\n  const {\n    iconColor,\n    renderIcon = (password) => (password ? <Visibility /> : <VisibilityOff />),\n    InputProps = {},\n    slotProps,\n    ...rest\n  } = props\n  const [password, setPassword] = useState<boolean>(true)\n\n  const endAdornment = (\n    <InputAdornment position={'end'}>\n      <IconButton\n        aria-label={password ? 'Hide password' : 'Show password'}\n        onMouseDown={(e: MouseEvent<HTMLButtonElement>) => e.preventDefault()}\n        onClick={() => setPassword(!password)}\n        tabIndex={-1}\n        color={iconColor ?? 'default'}\n      >\n        {renderIcon(password)}\n      </IconButton>\n    </InputAdornment>\n  )\n\n  return (\n    <TextFieldElement\n      {...(rest as TextFieldElementProps)}\n      ref={ref}\n      type={password ? 'password' : 'text'}\n      {...(typeof slotProps === 'undefined'\n        ? {\n            InputProps: {\n              endAdornment,\n              ...InputProps,\n            },\n          }\n        : {\n            slotProps: {\n              ...slotProps,\n              input: {\n                endAdornment,\n                ...InputProps,\n                ...slotProps?.input,\n              },\n            } as TextFieldElementProps['slotProps'],\n          })}\n    />\n  )\n})\nPasswordElement.displayName = 'PasswordElement'\nexport default PasswordElement as PasswordElementComponent\n","import {forwardRef, ReactNode, Ref, RefAttributes} from 'react'\nimport {\n  Control,\n  FieldError,\n  FieldPath,\n  FieldValues,\n  PathValue,\n  useController,\n  UseControllerProps,\n} from 'react-hook-form'\nimport {\n  FormControl,\n  FormControlLabel,\n  FormControlLabelProps,\n  FormHelperText,\n  FormLabel,\n  FormLabelProps,\n  Radio,\n  RadioGroup,\n  RadioGroupProps,\n  RadioProps,\n  useTheme,\n} from '@mui/material'\nimport {useFormError} from './FormErrorProvider'\nimport {useTransform} from './useTransform'\n\nexport type RadioButtonGroupProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = {\n  rules?: UseControllerProps<TFieldValues, TName>['rules']\n  options: TValue[]\n  helperText?: ReactNode\n  name: TName\n  required?: boolean\n  parseError?: (error: FieldError) => ReactNode\n  label?: string\n  labelKey?: string\n  valueKey?: string\n  disabledKey?: string\n  type?: 'number' | 'string'\n  emptyOptionLabel?: string\n  onChange?: (value: TValue | string | undefined) => void\n  returnObject?: boolean\n  row?: boolean\n  control?: Control<TFieldValues>\n  labelProps?: Omit<FormControlLabelProps, 'label' | 'control' | 'value'>\n  formLabelProps?: Omit<FormLabelProps, 'required' | 'error'>\n  radioProps?: RadioProps\n  disabled?: boolean\n  transform?: {\n    input?: (value: PathValue<TFieldValues, TName>) => TValue\n    output?: (\n      value: TValue | string | undefined\n    ) => PathValue<TFieldValues, TName>\n  }\n}\n\ntype RadioButtonGroupComponent = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: RadioButtonGroupProps<TFieldValues, TName, TValue> &\n    RefAttributes<HTMLDivElement>\n) => JSX.Element\n\nconst RadioButtonGroup = forwardRef(function RadioButtonGroup<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: RadioButtonGroupProps<TFieldValues, TName, TValue>,\n  ref: Ref<HTMLDivElement>\n) {\n  const {\n    helperText,\n    options,\n    label,\n    name,\n    parseError,\n    labelKey = 'label',\n    valueKey = 'id',\n    disabledKey = 'disabled',\n    required,\n    emptyOptionLabel,\n    returnObject,\n    row,\n    control,\n    type,\n    labelProps,\n    disabled,\n    formLabelProps,\n    radioProps,\n    transform,\n    rules = {},\n    ...rest\n  } = props\n  const theme = useTheme()\n\n  const errorMsgFn = useFormError()\n  const customErrorFn = parseError || errorMsgFn\n\n  const rulesTmp = {\n    ...rules,\n    ...(required && !rules.required && {required: 'This field is required'}),\n  }\n\n  const {\n    field,\n    fieldState: {error},\n  } = useController({\n    name,\n    rules: rulesTmp,\n    disabled,\n    control,\n  })\n\n  const {value, onChange} = useTransform<TFieldValues, TName, TValue | string>({\n    value: field.value,\n    onChange: field.onChange,\n    transform: {\n      input:\n        typeof transform?.input === 'function'\n          ? transform.input\n          : (value) => {\n              return value || ('' as TValue)\n            },\n      output:\n        typeof transform?.output === 'function'\n          ? transform?.output\n          : (_event, value) => {\n              if (value && type === 'number') {\n                return Number(value)\n              }\n              return value\n            },\n    },\n  })\n\n  const renderHelperText = error\n    ? typeof customErrorFn === 'function'\n      ? customErrorFn(error)\n      : error.message\n    : helperText\n\n  const onRadioChange: RadioGroupProps['onChange'] = (event, radioValue) => {\n    const returnValue = returnObject\n      ? options.find((items) => items[valueKey] === radioValue)\n      : radioValue\n    onChange(event, returnValue)\n    if (typeof rest.onChange === 'function') {\n      rest.onChange(returnValue)\n    }\n  }\n\n  return (\n    <FormControl error={!!error} ref={ref}>\n      {label && (\n        <FormLabel {...formLabelProps} required={required} error={!!error}>\n          {label}\n        </FormLabel>\n      )}\n      <RadioGroup onChange={onRadioChange} name={name} row={row} value={value}>\n        {emptyOptionLabel && (\n          <FormControlLabel\n            {...labelProps}\n            control={\n              <Radio\n                {...radioProps}\n                sx={{\n                  color: error ? theme.palette.error.main : undefined,\n                }}\n                checked={!value}\n              />\n            }\n            label={emptyOptionLabel}\n            value=\"\"\n          />\n        )}\n        {options.map((option: any) => {\n          const optionKey = option[valueKey]\n          const optionDisabled = option[disabledKey] || false\n          if (optionKey === undefined) {\n            console.error(\n              `RadioButtonGroup: valueKey ${valueKey} does not exist on option`,\n              option\n            )\n          }\n          let val = returnObject ? value?.[valueKey] : value\n          if (type === 'number') {\n            val = Number(val)\n          }\n          const isChecked = val === optionKey\n          return (\n            <FormControlLabel\n              {...labelProps}\n              control={\n                <Radio\n                  {...radioProps}\n                  sx={{\n                    color: error ? theme.palette.error.main : undefined,\n                  }}\n                  disabled={disabled || optionDisabled}\n                  checked={isChecked}\n                />\n              }\n              value={optionKey}\n              label={option[labelKey]}\n              key={optionKey}\n            />\n          )\n        })}\n      </RadioGroup>\n      {renderHelperText && <FormHelperText>{renderHelperText}</FormHelperText>}\n    </FormControl>\n  )\n})\nRadioButtonGroup.displayName = 'RadioButtonGroup'\nexport default RadioButtonGroup as RadioButtonGroupComponent\n","import {\n  Control,\n  FieldPath,\n  FieldValues,\n  PathValue,\n  useController,\n} from 'react-hook-form'\nimport {\n  FormControlLabel,\n  FormControlLabelProps,\n  Switch,\n  SwitchProps,\n  useForkRef,\n} from '@mui/material'\nimport {ChangeEvent, forwardRef, Ref, RefAttributes} from 'react'\nimport {useTransform} from './useTransform'\n\nexport type SwitchElementProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = Omit<FormControlLabelProps, 'control'> & {\n  name: TName\n  control?: Control<TFieldValues>\n  switchProps?: SwitchProps\n  transform?: {\n    input?: (value: PathValue<TFieldValues, TName>) => TValue\n    output?: (\n      event: ChangeEvent<HTMLInputElement>,\n      checked: boolean\n    ) => PathValue<TFieldValues, TName>\n  }\n}\n\ntype SwitchElementComponent = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: SwitchElementProps<TFieldValues, TName, TValue> &\n    RefAttributes<HTMLLabelElement>\n) => JSX.Element\n\nconst SwitchElement = forwardRef(function SwitchElement<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: SwitchElementProps<TFieldValues, TName, TValue>,\n  ref: Ref<HTMLLabelElement>\n) {\n  const {name, control, switchProps, transform, ...rest} = props\n\n  const {field} = useController({\n    name,\n    control,\n    disabled: rest.disabled,\n  })\n\n  const {value, onChange} = useTransform<TFieldValues, TName, TValue>({\n    value: field.value,\n    onChange: field.onChange,\n    transform: {\n      input: transform?.input,\n      output:\n        typeof transform?.output === 'function'\n          ? transform.output\n          : (_event: ChangeEvent<HTMLInputElement>, checked: boolean) => {\n              return checked as PathValue<TFieldValues, TName>\n            },\n    },\n  })\n\n  const handleSwitchRef = useForkRef(field.ref, switchProps?.ref)\n\n  return (\n    <FormControlLabel\n      ref={ref}\n      control={\n        <Switch\n          {...switchProps}\n          name={field.name}\n          value={value}\n          onChange={(event, checked) => {\n            onChange(event, checked)\n            if (typeof switchProps?.onChange === 'function') {\n              switchProps.onChange(event, checked)\n            }\n          }}\n          onBlur={(event) => {\n            field.onBlur()\n            if (typeof switchProps?.onBlur === 'function') {\n              switchProps?.onBlur(event)\n            }\n          }}\n          ref={handleSwitchRef}\n          checked={!!value}\n        />\n      }\n      {...rest}\n    />\n  )\n})\nSwitchElement.displayName = 'SwitchElement'\nexport default SwitchElement as SwitchElementComponent\n","import PasswordElement, {PasswordElementProps} from './PasswordElement'\nimport {FieldPath, FieldValues, useWatch} from 'react-hook-form'\nimport {forwardRef, Ref, RefAttributes} from 'react'\n\nexport type PasswordRepeatElementProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TConfirmPasswordName extends\n    FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TPasswordName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TConfirmPasswordValue = unknown,\n> = PasswordElementProps<\n  TFieldValues,\n  TConfirmPasswordName,\n  TConfirmPasswordValue\n> & {\n  passwordFieldName: TPasswordName\n  customInvalidFieldMessage?: string\n}\n\ntype PasswordRepeatElementComponent = <\n  TFieldValues extends FieldValues = FieldValues,\n  TConfirmPasswordName extends\n    FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TPasswordName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>(\n  props: PasswordRepeatElementProps<\n    TFieldValues,\n    TConfirmPasswordName,\n    TPasswordName\n  > &\n    RefAttributes<HTMLDivElement>\n) => JSX.Element\n\nconst PasswordRepeatElement = forwardRef(function PasswordRepeatElement<\n  TFieldValues extends FieldValues = FieldValues,\n  TConfirmPasswordName extends\n    FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TPasswordName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TConfirmPasswordValue = unknown,\n>(\n  props: PasswordRepeatElementProps<\n    TFieldValues,\n    TConfirmPasswordName,\n    TPasswordName,\n    TConfirmPasswordValue\n  >,\n  ref: Ref<HTMLDivElement>\n) {\n  const {passwordFieldName, customInvalidFieldMessage, control, ...rest} = props\n\n  const pwValue = useWatch({\n    name: passwordFieldName,\n    control,\n  })\n\n  return (\n    <PasswordElement\n      control={control}\n      {...rest}\n      ref={ref}\n      rules={{\n        validate: (value: string) => {\n          return (\n            value === pwValue ||\n            (customInvalidFieldMessage ?? 'Password should match')\n          )\n        },\n      }}\n    />\n  )\n})\nPasswordRepeatElement.displayName = 'PasswordRepeatElement'\nexport default PasswordRepeatElement as PasswordRepeatElementComponent\n","import {\n  Control,\n  FieldError,\n  FieldPath,\n  FieldValues,\n  PathValue,\n  useController,\n  UseControllerProps,\n} from 'react-hook-form'\nimport {\n  Autocomplete,\n  AutocompleteChangeDetails,\n  AutocompleteChangeReason,\n  AutocompleteFreeSoloValueMapping,\n  AutocompleteProps,\n  AutocompleteValue,\n  Checkbox,\n  ChipTypeMap,\n  TextField,\n  TextFieldProps,\n  useForkRef,\n  CircularProgress,\n} from '@mui/material'\nimport {useFormError} from './FormErrorProvider'\nimport {\n  ElementType,\n  forwardRef,\n  ReactNode,\n  Ref,\n  RefAttributes,\n  SyntheticEvent,\n} from 'react'\nimport {useTransform} from './useTransform'\nimport {propertyExists} from './utils'\n\nexport type AutocompleteElementProps<\n  TValue,\n  Multiple extends boolean | undefined,\n  DisableClearable extends boolean | undefined,\n  FreeSolo extends boolean | undefined,\n  ChipComponent extends ElementType = ChipTypeMap['defaultComponent'],\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> = {\n  name: TName\n  control?: Control<TFieldValues>\n  options: TValue[]\n  loading?: boolean\n  multiple?: Multiple\n  loadingIndicator?: ReactNode\n  rules?: UseControllerProps<TFieldValues, TName>['rules']\n  parseError?: (error: FieldError) => ReactNode\n  required?: boolean\n  label?: TextFieldProps['label']\n  showCheckbox?: boolean\n  matchId?: boolean\n  autocompleteProps?: Omit<\n    AutocompleteProps<\n      TValue,\n      Multiple,\n      DisableClearable,\n      FreeSolo,\n      ChipComponent\n    >,\n    'name' | 'options' | 'loading' | 'renderInput'\n  >\n  textFieldProps?: Omit<TextFieldProps, 'name' | 'required' | 'label'>\n  transform?: {\n    input?: (\n      value: PathValue<TFieldValues, TName>\n    ) => AutocompleteValue<TValue, Multiple, DisableClearable, FreeSolo>\n    output?: (\n      event: SyntheticEvent,\n      value: AutocompleteValue<TValue, Multiple, DisableClearable, FreeSolo>,\n      reason: AutocompleteChangeReason,\n      details?: AutocompleteChangeDetails<TValue>\n    ) => PathValue<TFieldValues, TName>\n  }\n}\n\ntype AutocompleteElementComponent = <\n  TValue,\n  Multiple extends boolean | undefined = false,\n  DisableClearable extends boolean | undefined = false,\n  FreeSolo extends boolean | undefined = false,\n  ChipComponent extends ElementType = ChipTypeMap['defaultComponent'],\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>(\n  props: AutocompleteElementProps<\n    TValue,\n    Multiple,\n    DisableClearable,\n    FreeSolo,\n    ChipComponent,\n    TFieldValues,\n    TName\n  > &\n    RefAttributes<HTMLDivElement>\n) => JSX.Element\n\nconst AutocompleteElement = forwardRef(function AutocompleteElement<\n  TValue,\n  Multiple extends boolean | undefined = false,\n  DisableClearable extends boolean | undefined = false,\n  FreeSolo extends boolean | undefined = false,\n  ChipComponent extends ElementType = ChipTypeMap['defaultComponent'],\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>(\n  props: AutocompleteElementProps<\n    TValue,\n    Multiple,\n    DisableClearable,\n    FreeSolo,\n    ChipComponent,\n    TFieldValues,\n    TName\n  >,\n  ref: Ref<HTMLDivElement>\n) {\n  const {\n    textFieldProps,\n    autocompleteProps,\n    name,\n    control,\n    options,\n    loading,\n    showCheckbox,\n    rules,\n    loadingIndicator,\n    required,\n    multiple,\n    label,\n    parseError,\n    transform,\n    matchId,\n  } = props\n\n  const errorMsgFn = useFormError()\n  const customErrorFn = parseError || errorMsgFn\n\n  const validationRules = {\n    ...rules,\n    ...(required && {\n      required: rules?.required || 'This field is required',\n    }),\n  }\n\n  const {\n    field,\n    fieldState: {error},\n  } = useController({\n    name,\n    control,\n    disabled: autocompleteProps?.disabled,\n    rules: validationRules,\n  })\n\n  const getOptionLabel = (\n    option: TValue | AutocompleteFreeSoloValueMapping<FreeSolo>\n  ): string => {\n    if (typeof autocompleteProps?.getOptionLabel === 'function') {\n      return autocompleteProps.getOptionLabel(option)\n    }\n    if (propertyExists(option, 'label')) {\n      return `${option?.label}`\n    }\n    return `${option}`\n  }\n\n  const isOptionEqualToValue = (option: TValue, value: TValue): boolean => {\n    if (typeof autocompleteProps?.isOptionEqualToValue == 'function') {\n      return autocompleteProps.isOptionEqualToValue(option, value)\n    }\n    const optionKey = propertyExists(option, 'id') ? option.id : option\n    const valueKey = propertyExists(value, 'id') ? value.id : value\n    return optionKey === valueKey\n  }\n\n  const matchOptionByValue = (currentValue: TValue) => {\n    return options.find((option) => {\n      if (matchId && propertyExists(option, 'id')) {\n        return option.id === currentValue\n      }\n      return isOptionEqualToValue(option, currentValue)\n    })\n  }\n\n  const {value, onChange} = useTransform<\n    TFieldValues,\n    TName,\n    AutocompleteValue<TValue, Multiple, DisableClearable, FreeSolo>\n  >({\n    value: field.value,\n    onChange: field.onChange,\n    transform: {\n      input:\n        typeof transform?.input === 'function'\n          ? transform.input\n          : (newValue) => {\n              return (\n                multiple\n                  ? (Array.isArray(newValue) ? newValue : []).map(\n                      matchOptionByValue\n                    )\n                  : matchOptionByValue(newValue) ?? null\n              ) as AutocompleteValue<\n                TValue,\n                Multiple,\n                DisableClearable,\n                FreeSolo\n              >\n            },\n      output:\n        typeof transform?.output === 'function'\n          ? transform.output\n          : (\n              _event: SyntheticEvent,\n              newValue: AutocompleteValue<\n                TValue,\n                Multiple,\n                DisableClearable,\n                FreeSolo\n              >\n            ) => {\n              if (multiple) {\n                const newValues = Array.isArray(newValue) ? newValue : []\n                return (\n                  matchId\n                    ? newValues.map((currentValue) =>\n                        propertyExists(currentValue, 'id')\n                          ? currentValue.id\n                          : currentValue\n                      )\n                    : newValues\n                ) as PathValue<TFieldValues, TName>\n              }\n              return (\n                matchId && propertyExists(newValue, 'id')\n                  ? newValue.id\n                  : newValue\n              ) as PathValue<TFieldValues, TName>\n            },\n    },\n  })\n\n  const handleInputRef = useForkRef(field.ref, textFieldProps?.inputRef)\n\n  const loadingElement = loadingIndicator || (\n    <CircularProgress color=\"inherit\" size={20} />\n  )\n\n  return (\n    <Autocomplete\n      {...autocompleteProps}\n      value={value}\n      loading={loading}\n      multiple={multiple}\n      options={options}\n      disableCloseOnSelect={\n        typeof autocompleteProps?.disableCloseOnSelect === 'boolean'\n          ? autocompleteProps.disableCloseOnSelect\n          : !!multiple\n      }\n      isOptionEqualToValue={isOptionEqualToValue}\n      getOptionLabel={getOptionLabel}\n      onChange={(event, newValue, reason, details) => {\n        onChange(event, newValue, reason, details)\n        if (autocompleteProps?.onChange) {\n          autocompleteProps.onChange(event, newValue, reason, details)\n        }\n      }}\n      ref={ref}\n      renderOption={\n        autocompleteProps?.renderOption ??\n        (showCheckbox\n          ? (props, option, {selected}) => {\n              return (\n                <li {...props} key={props.key}>\n                  <Checkbox sx={{marginRight: 1}} checked={selected} />\n                  {getOptionLabel(option)}\n                </li>\n              )\n            }\n          : undefined)\n      }\n      onBlur={(event) => {\n        field.onBlur()\n        if (typeof autocompleteProps?.onBlur === 'function') {\n          autocompleteProps.onBlur(event)\n        }\n      }}\n      renderInput={(params) => (\n        <TextField\n          name={name}\n          required={rules?.required ? true : required}\n          label={label}\n          {...textFieldProps}\n          {...params}\n          error={!!error}\n          InputLabelProps={{\n            ...params.InputLabelProps,\n            ...textFieldProps?.InputLabelProps,\n          }}\n          InputProps={{\n            ...params.InputProps,\n            endAdornment: (\n              <>\n                {loading ? loadingElement : null}\n                {params.InputProps.endAdornment}\n              </>\n            ),\n            ...textFieldProps?.InputProps,\n          }}\n          inputProps={{\n            ...params.inputProps,\n            ...textFieldProps?.inputProps,\n          }}\n          helperText={\n            error\n              ? typeof customErrorFn === 'function'\n                ? customErrorFn(error)\n                : error.message\n              : textFieldProps?.helperText\n          }\n          inputRef={handleInputRef}\n        />\n      )}\n    />\n  )\n})\nAutocompleteElement.displayName = 'AutocompleteElement'\nexport default AutocompleteElement as AutocompleteElementComponent\n","import {\n  Control,\n  FieldError,\n  FieldPath,\n  FieldValues,\n  PathValue,\n  useController,\n  UseControllerProps,\n} from 'react-hook-form'\nimport {\n  FormControl,\n  FormControlProps,\n  FormHelperText,\n  FormLabel,\n  Slider,\n  SliderProps,\n} from '@mui/material'\nimport {useFormError} from './FormErrorProvider'\nimport {forwardRef, ReactNode, Ref, RefAttributes} from 'react'\nimport {useTransform} from './useTransform'\n\nexport type SliderElementProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n> = Omit<SliderProps, 'control'> & {\n  name: TName\n  control?: Control<TFieldValues>\n  label?: string\n  rules?: UseControllerProps<TFieldValues, TName>['rules']\n  parseError?: (error: FieldError) => ReactNode\n  required?: boolean\n  formControlProps?: FormControlProps\n  transform?: {\n    input?: (\n      value: PathValue<TFieldValues, TName>\n    ) => number | number[] | undefined\n    output?: (\n      event: Event,\n      value: number | number[] | undefined,\n      activeThumb: number\n    ) => PathValue<TFieldValues, TName>\n  }\n}\n\ntype SliderElementComponent = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>(\n  props: SliderElementProps<TFieldValues, TName> & RefAttributes<HTMLDivElement>\n) => JSX.Element\n\nconst SliderElement = forwardRef(function SliderElement<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n>(props: SliderElementProps<TFieldValues, TName>, ref: Ref<HTMLDivElement>) {\n  const {\n    name,\n    control,\n    label,\n    rules = {},\n    parseError,\n    required,\n    formControlProps,\n    transform,\n    ...other\n  } = props\n\n  const errorMsgFn = useFormError()\n  const customErrorFn = parseError || errorMsgFn\n\n  const validationRules = {\n    ...rules,\n    ...(required &&\n      !rules.required && {\n        required: 'This field is required',\n      }),\n  }\n\n  const {\n    field,\n    fieldState: {error, invalid},\n  } = useController({\n    name,\n    control,\n    disabled: other.disabled,\n    rules: validationRules,\n  })\n\n  const {value, onChange} = useTransform<\n    TFieldValues,\n    TName,\n    number | number[] | undefined\n  >({\n    value: field.value,\n    onChange: field.onChange,\n    transform,\n  })\n\n  const parsedHelperText = error\n    ? typeof customErrorFn === 'function'\n      ? customErrorFn(error)\n      : error.message\n    : null\n\n  return (\n    <FormControl\n      error={invalid}\n      required={required}\n      fullWidth\n      {...formControlProps}\n      ref={ref}\n    >\n      {label && (\n        <FormLabel component=\"legend\" error={invalid}>\n          {label}\n        </FormLabel>\n      )}\n      <Slider\n        {...other}\n        value={value}\n        onChange={onChange}\n        valueLabelDisplay={other.valueLabelDisplay || 'auto'}\n      />\n      {parsedHelperText && (\n        <FormHelperText error={invalid}>{parsedHelperText}</FormHelperText>\n      )}\n    </FormControl>\n  )\n})\nSliderElement.displayName = 'SliderElement'\nexport default SliderElement as SliderElementComponent\n","import {\n  Control,\n  FieldError,\n  FieldPath,\n  FieldValues,\n  PathValue,\n  useController,\n  UseControllerProps,\n} from 'react-hook-form'\nimport {\n  FormControl,\n  FormHelperText,\n  FormLabel,\n  FormLabelProps,\n  ToggleButton,\n  ToggleButtonGroup,\n  ToggleButtonGroupProps,\n  ToggleButtonProps,\n} from '@mui/material'\nimport {MouseEvent, ReactNode} from 'react'\nimport {useFormError} from './FormErrorProvider'\nimport {useTransform} from './useTransform'\n\ntype SingleToggleButtonProps = Omit<\n  ToggleButtonProps,\n  'id' | 'value' | 'children'\n> & {\n  id: number | string\n  label: ReactNode\n}\n\nexport type ToggleButtonGroupElementProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = ToggleButtonGroupProps & {\n  required?: boolean\n  label?: string\n  rules?: UseControllerProps<TFieldValues, TName>['rules']\n  name: TName\n  parseError?: (error: FieldError) => ReactNode\n  control?: Control<TFieldValues>\n  options: SingleToggleButtonProps[]\n  formLabelProps?: FormLabelProps\n  helperText?: string\n  enforceAtLeastOneSelected?: boolean\n  transform?: {\n    input?: (value: PathValue<TFieldValues, TName>) => TValue\n    output?: (...event: any[]) => PathValue<TFieldValues, TName>\n  }\n}\n\nexport default function ToggleButtonGroupElement<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(props: ToggleButtonGroupElementProps<TFieldValues, TName, TValue>) {\n  const {\n    name,\n    control,\n    label,\n    rules = {},\n    required,\n    options = [],\n    onBlur,\n    parseError,\n    helperText,\n    formLabelProps,\n    enforceAtLeastOneSelected = false,\n    exclusive,\n    transform,\n    ...toggleButtonGroupProps\n  } = props\n  const errorMsgFn = useFormError()\n  const customErrorFn = parseError || errorMsgFn\n\n  const rulesTmp = {\n    ...rules,\n    ...(required &&\n      !rules.required && {\n        required: 'This field is required',\n      }),\n  }\n\n  const isRequired = required || !!rules?.required\n\n  const {\n    field,\n    fieldState: {error},\n  } = useController({\n    name,\n    control,\n    rules: rulesTmp,\n    disabled: toggleButtonGroupProps.disabled,\n  })\n\n  const {value, onChange} = useTransform<TFieldValues, TName, TValue>({\n    value: field.value,\n    onChange: field.onChange,\n    transform: {\n      input: transform?.input,\n      output:\n        typeof transform?.output === 'function'\n          ? transform.output\n          : (_event: MouseEvent<HTMLElement, MouseEvent>, value: any) => {\n              return value\n            },\n    },\n  })\n\n  const renderHelperText = error\n    ? typeof customErrorFn === 'function'\n      ? customErrorFn(error)\n      : error.message\n    : helperText\n\n  return (\n    <FormControl\n      error={!!error}\n      required={isRequired}\n      fullWidth={toggleButtonGroupProps?.fullWidth}\n    >\n      {label && (\n        <FormLabel\n          {...formLabelProps}\n          error={!!error}\n          required={isRequired}\n          sx={{mb: 1, ...formLabelProps?.sx}}\n        >\n          {label}\n        </FormLabel>\n      )}\n      <ToggleButtonGroup\n        {...toggleButtonGroupProps}\n        exclusive={exclusive}\n        value={value}\n        onBlur={(event) => {\n          field.onBlur()\n          if (typeof onBlur === 'function') {\n            onBlur(event)\n          }\n        }}\n        onChange={(event, value) => {\n          if (enforceAtLeastOneSelected) {\n            // don't allow unselecting the last item\n            if (exclusive && value === null) return\n            if (!exclusive && value?.length === 0) return\n          }\n          onChange(event, value)\n          if (typeof toggleButtonGroupProps.onChange === 'function') {\n            toggleButtonGroupProps.onChange(event, value)\n          }\n        }}\n      >\n        {options.map(({label, id, ...toggleProps}) => (\n          <ToggleButton value={id} {...toggleProps} key={id}>\n            {label}\n          </ToggleButton>\n        ))}\n      </ToggleButtonGroup>\n      {renderHelperText && <FormHelperText>{renderHelperText}</FormHelperText>}\n    </FormControl>\n  )\n}\n","import {\n  TextareaAutosize,\n  TextField,\n  TextFieldProps,\n  useForkRef,\n} from '@mui/material'\nimport {\n  Control,\n  FieldError,\n  FieldPath,\n  FieldValues,\n  PathValue,\n  useController,\n  UseControllerProps,\n} from 'react-hook-form'\nimport {\n  ChangeEvent,\n  CSSProperties,\n  forwardRef,\n  ReactNode,\n  Ref,\n  RefAttributes,\n} from 'react'\nimport {useFormError} from './FormErrorProvider'\nimport {useTransform} from './useTransform'\n\nexport type TextareaAutosizeElementProps<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n> = Omit<TextFieldProps, 'name' | 'type'> & {\n  rules?: UseControllerProps<TFieldValues, TName>['rules']\n  name: TName\n  parseError?: (error: FieldError) => ReactNode\n  control?: Control<TFieldValues>\n  resizeStyle?: CSSProperties['resize']\n  transform?: {\n    input?: (value: PathValue<TFieldValues, TName>) => TValue\n    output?: (\n      event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\n    ) => PathValue<TFieldValues, TName>\n  }\n}\n\ntype TextareaAutosizeElementComponent = <\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: TextareaAutosizeElementProps<TFieldValues, TName, TValue> &\n    RefAttributes<HTMLDivElement>\n) => JSX.Element\n\nconst TextareaAutosizeElement = forwardRef(function TextareaAutosizeElement<\n  TFieldValues extends FieldValues = FieldValues,\n  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,\n  TValue = unknown,\n>(\n  props: TextareaAutosizeElementProps<TFieldValues, TName, TValue>,\n  ref: Ref<HTMLDivElement>\n) {\n  const {\n    rules = {},\n    parseError,\n    required,\n    name,\n    control,\n    rows,\n    resizeStyle = 'none',\n    maxRows,\n    minRows,\n    inputRef,\n    inputProps,\n    transform,\n    onBlur,\n    ...rest\n  } = props\n\n  const errorMsgFn = useFormError()\n  const customErrorFn = parseError || errorMsgFn\n\n  const rulesTmp = {\n    ...rules,\n    ...(required && !rules.required && {required: 'This field is required'}),\n  }\n\n  const {\n    field,\n    fieldState: {error},\n  } = useController({\n    name,\n    control,\n    rules: rulesTmp,\n    disabled: rest.disabled,\n  })\n\n  const {value, onChange} = useTransform<TFieldValues, TName, TValue>({\n    value: field.value,\n    onChange: field.onChange,\n    transform: {\n      input:\n        typeof transform?.input === 'function'\n          ? transform.input\n          : (value) => {\n              return value ?? ('' as TValue)\n            },\n      output:\n        typeof transform?.output === 'function'\n          ? transform.output\n          : (event: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n              return event.target.value as PathValue<TFieldValues, TName>\n            },\n    },\n  })\n\n  const handleInputRef = useForkRef(field.ref, inputRef)\n\n  return (\n    <TextField\n      {...rest}\n      name={name}\n      value={value}\n      onChange={(event) => {\n        onChange(event)\n        if (typeof rest.onChange === 'function') {\n          rest.onChange(event)\n        }\n      }}\n      onBlur={(event) => {\n        field.onBlur()\n        if (typeof onBlur === 'function') {\n          onBlur(event)\n        }\n      }}\n      required={required}\n      error={!!error}\n      helperText={\n        error\n          ? typeof customErrorFn === 'function'\n            ? customErrorFn(error)\n            : error.message\n          : rest.helperText\n      }\n      inputRef={handleInputRef}\n      multiline\n      ref={ref}\n      slotProps={{\n        input: {\n          inputComponent: TextareaAutosize,\n          inputProps: {\n            minRows: minRows || rows,\n            maxRows: maxRows || rows,\n            style: {\n              resize: resizeStyle,\n            },\n            ...(inputProps || {}),\n          },\n        },\n      }}\n    />\n  )\n})\nTextareaAutosizeElement.displayName = 'TextareaAutosizeElement'\nexport default TextareaAutosizeElement as TextareaAutosizeElementComponent\n"]}