import {
  require_common,
  require_stepsForMigration
} from "./chunk-K3VF5HSK.js";
import {
  require_RawRecord,
  require_likeToRegexp
} from "./chunk-R7SZ4RGA.js";
import {
  require_createClass,
  require_logError
} from "./chunk-OXRMU63H.js";
import {
  require_extends,
  require_interopRequireDefault,
  require_invariant,
  require_logger,
  require_toConsumableArray
} from "./chunk-UA6MBTDI.js";
import {
  __commonJS
} from "./chunk-OL46QLBJ.js";

// node_modules/lokijs/src/incremental-indexeddb-adapter.js
var require_incremental_indexeddb_adapter = __commonJS({
  "node_modules/lokijs/src/incremental-indexeddb-adapter.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.IncrementalIndexedDBAdapter = factory();
      }
    })(exports, function() {
      return (function() {
        "use strict";
        var DEBUG = typeof window !== "undefined" && !!window.__loki_incremental_idb_debug;
        function IncrementalIndexedDBAdapter(options) {
          this.mode = "incremental";
          this.options = options || {};
          this.chunkSize = 100;
          this.megachunkCount = this.options.megachunkCount || 24;
          this.lazyCollections = this.options.lazyCollections || [];
          this.idb = null;
          this._prevLokiVersionId = null;
          this._prevCollectionVersionIds = {};
          if (!(this.megachunkCount >= 4 && this.megachunkCount % 2 === 0)) {
            throw new Error("megachunkCount must be >=4 and divisible by 2");
          }
        }
        IncrementalIndexedDBAdapter.prototype._getChunk = function(collection, chunkId) {
          var minId = chunkId * this.chunkSize;
          var maxId = minId + this.chunkSize - 1;
          collection.ensureId();
          var idIndex = collection.idIndex;
          var firstDataPosition = null;
          var max = idIndex.length - 1, min = 0, mid;
          while (idIndex[min] < idIndex[max]) {
            mid = min + max >> 1;
            if (idIndex[mid] < minId) {
              min = mid + 1;
            } else {
              max = mid;
            }
          }
          if (max === min && idIndex[min] >= minId && idIndex[min] <= maxId) {
            firstDataPosition = min;
          }
          if (firstDataPosition === null) {
            return [];
          }
          var lastDataPosition = null;
          for (var i = firstDataPosition + this.chunkSize - 1; i >= firstDataPosition; i--) {
            if (idIndex[i] <= maxId) {
              lastDataPosition = i;
              break;
            }
          }
          var firstElement = collection.data[firstDataPosition];
          if (!(firstElement && firstElement.$loki >= minId && firstElement.$loki <= maxId)) {
            throw new Error("broken invariant firstelement");
          }
          var lastElement = collection.data[lastDataPosition];
          if (!(lastElement && lastElement.$loki >= minId && lastElement.$loki <= maxId)) {
            throw new Error("broken invariant lastElement");
          }
          var chunkData = collection.data.slice(firstDataPosition, lastDataPosition + 1);
          if (chunkData.length > this.chunkSize) {
            throw new Error("broken invariant - chunk size");
          }
          return chunkData;
        };
        IncrementalIndexedDBAdapter.prototype.saveDatabase = function(dbname, getLokiCopy, callback) {
          var that = this;
          if (!this.idb) {
            this._initializeIDB(dbname, callback, function() {
              that.saveDatabase(dbname, getLokiCopy, callback);
            });
            return;
          }
          if (this.operationInProgress) {
            throw new Error("Error while saving to database - another operation is already in progress. Please use throttledSaves=true option on Loki object");
          }
          this.operationInProgress = true;
          DEBUG && console.log("saveDatabase - begin");
          DEBUG && console.time("saveDatabase");
          function finish(e) {
            DEBUG && e && console.error(e);
            DEBUG && console.timeEnd("saveDatabase");
            that.operationInProgress = false;
            callback(e);
          }
          try {
            var updatePrevVersionIds = function() {
              console.error("Unexpected successful tx - cannot update previous version ids");
            };
            var didOverwrite = false;
            var tx = this.idb.transaction(["LokiIncrementalData"], "readwrite");
            tx.oncomplete = function() {
              updatePrevVersionIds();
              finish();
              if (didOverwrite && that.options.onDidOverwrite) {
                that.options.onDidOverwrite();
              }
            };
            tx.onerror = function(e) {
              finish(e);
            };
            tx.onabort = function(e) {
              finish(e);
            };
            var store = tx.objectStore("LokiIncrementalData");
            var performSave = function(maxChunkIds) {
              try {
                var incremental = !maxChunkIds;
                var chunkInfo = that._putInChunks(store, getLokiCopy(), incremental, maxChunkIds);
                updatePrevVersionIds = function() {
                  that._prevLokiVersionId = chunkInfo.lokiVersionId;
                  chunkInfo.collectionVersionIds.forEach(function(collectionInfo) {
                    that._prevCollectionVersionIds[collectionInfo.name] = collectionInfo.versionId;
                  });
                };
                tx.commit && tx.commit();
              } catch (error) {
                console.error("idb performSave failed: ", error);
                tx.abort();
              }
            };
            var getAllKeysThenSave = function() {
              idbReq(store.getAllKeys(), function(e) {
                var maxChunkIds = getMaxChunkIds(e.target.result);
                performSave(maxChunkIds);
              }, function(e) {
                console.error("Getting all keys failed: ", e);
                tx.abort();
              });
            };
            var getLokiThenSave = function() {
              idbReq(store.get("loki"), function(e) {
                if (lokiChunkVersionId(e.target.result) === that._prevLokiVersionId) {
                  performSave();
                } else {
                  DEBUG && console.warn("Another writer changed Loki IDB, using slow path...");
                  didOverwrite = true;
                  getAllKeysThenSave();
                }
              }, function(e) {
                console.error("Getting loki chunk failed: ", e);
                tx.abort();
              });
            };
            getLokiThenSave();
          } catch (error) {
            finish(error);
          }
        };
        function getMaxChunkIds(allKeys) {
          var maxChunkIds = {};
          allKeys.forEach(function(key) {
            var keySegments = key.split(".");
            if (keySegments.length === 3 && keySegments[1] === "chunk") {
              var collection = keySegments[0];
              var chunkId = parseInt(keySegments[2]) || 0;
              var currentMax = maxChunkIds[collection];
              if (!currentMax || chunkId > currentMax) {
                maxChunkIds[collection] = chunkId;
              }
            }
          });
          return maxChunkIds;
        }
        function lokiChunkVersionId(chunk) {
          try {
            if (chunk) {
              var loki = JSON.parse(chunk.value);
              return loki.idbVersionId || null;
            } else {
              return null;
            }
          } catch (e) {
            console.error("Error while parsing loki chunk", e);
            return null;
          }
        }
        IncrementalIndexedDBAdapter.prototype._putInChunks = function(idbStore, loki, incremental, maxChunkIds) {
          var that = this;
          var collectionVersionIds = [];
          var savedSize = 0;
          var prepareCollection = function(collection, i) {
            var dirtyChunks = /* @__PURE__ */ new Set();
            incremental && collection.dirtyIds.forEach(function(lokiId) {
              var chunkId = lokiId / that.chunkSize | 0;
              dirtyChunks.add(chunkId);
            });
            collection.dirtyIds = [];
            var prepareChunk = function(chunkId) {
              var chunkData = that._getChunk(collection, chunkId);
              if (that.options.serializeChunk) {
                chunkData = that.options.serializeChunk(collection.name, chunkData);
              }
              chunkData = JSON.stringify(chunkData);
              savedSize += chunkData.length;
              DEBUG && incremental && console.log("Saving: " + collection.name + ".chunk." + chunkId);
              idbStore.put({
                key: collection.name + ".chunk." + chunkId,
                value: chunkData
              });
            };
            if (incremental) {
              dirtyChunks.forEach(prepareChunk);
            } else {
              var maxChunkId = collection.maxId / that.chunkSize | 0;
              for (var j = 0; j <= maxChunkId; j += 1) {
                prepareChunk(j);
              }
              var persistedMaxChunkId = maxChunkIds[collection.name] || 0;
              for (var k = maxChunkId + 1; k <= persistedMaxChunkId; k += 1) {
                var deletedChunkName = collection.name + ".chunk." + k;
                idbStore.delete(deletedChunkName);
                DEBUG && console.warn("Deleted chunk: " + deletedChunkName);
              }
            }
            if (collection.dirty || dirtyChunks.size || !incremental) {
              collection.idIndex = [];
              collection.data = [];
              collection.idbVersionId = randomVersionId();
              collectionVersionIds.push({ name: collection.name, versionId: collection.idbVersionId });
              var metadataChunk = JSON.stringify(collection);
              savedSize += metadataChunk.length;
              DEBUG && incremental && console.log("Saving: " + collection.name + ".metadata");
              idbStore.put({
                key: collection.name + ".metadata",
                value: metadataChunk
              });
            }
            loki.collections[i] = { name: collection.name };
          };
          loki.collections.forEach(prepareCollection);
          loki.idbVersionId = randomVersionId();
          var serializedMetadata = JSON.stringify(loki);
          savedSize += serializedMetadata.length;
          DEBUG && incremental && console.log("Saving: loki");
          idbStore.put({ key: "loki", value: serializedMetadata });
          DEBUG && console.log("saved size: " + savedSize);
          return {
            lokiVersionId: loki.idbVersionId,
            collectionVersionIds
          };
        };
        IncrementalIndexedDBAdapter.prototype.loadDatabase = function(dbname, callback) {
          var that = this;
          if (this.operationInProgress) {
            throw new Error("Error while loading database - another operation is already in progress. Please use throttledSaves=true option on Loki object");
          }
          this.operationInProgress = true;
          DEBUG && console.log("loadDatabase - begin");
          DEBUG && console.time("loadDatabase");
          var finish = function(value) {
            DEBUG && console.timeEnd("loadDatabase");
            that.operationInProgress = false;
            callback(value);
          };
          this._getAllChunks(dbname, function(chunks) {
            try {
              if (!Array.isArray(chunks)) {
                throw chunks;
              }
              if (!chunks.length) {
                return finish(null);
              }
              DEBUG && console.log("Found chunks:", chunks.length);
              chunks = chunksToMap(chunks);
              var loki = chunks.loki;
              chunks.loki = null;
              populateLoki(loki, chunks.chunkMap, that.options.deserializeChunk, that.lazyCollections);
              chunks = null;
              that._prevLokiVersionId = loki.idbVersionId || null;
              that._prevCollectionVersionIds = {};
              loki.collections.forEach(function(collection) {
                that._prevCollectionVersionIds[collection.name] = collection.idbVersionId || null;
              });
              return finish(loki);
            } catch (error) {
              that._prevLokiVersionId = null;
              that._prevCollectionVersionIds = {};
              return finish(error);
            }
          });
        };
        function chunksToMap(chunks) {
          var loki;
          var chunkMap = {};
          sortChunksInPlace(chunks);
          chunks.forEach(function(chunk) {
            var type = chunk.type;
            var value = chunk.value;
            var name = chunk.collectionName;
            if (type === "loki") {
              loki = value;
            } else if (type === "data") {
              if (chunkMap[name]) {
                chunkMap[name].dataChunks.push(value);
              } else {
                chunkMap[name] = {
                  metadata: null,
                  dataChunks: [value]
                };
              }
            } else if (type === "metadata") {
              if (chunkMap[name]) {
                chunkMap[name].metadata = value;
              } else {
                chunkMap[name] = { metadata: value, dataChunks: [] };
              }
            } else {
              throw new Error("unreachable");
            }
          });
          if (!loki) {
            throw new Error("Corrupted database - missing database metadata");
          }
          return { loki, chunkMap };
        }
        function populateLoki(loki, chunkMap, deserializeChunk, lazyCollections) {
          loki.collections.forEach(function populateCollection(collectionStub, i) {
            var name = collectionStub.name;
            var chunkCollection = chunkMap[name];
            if (chunkCollection) {
              if (!chunkCollection.metadata) {
                throw new Error("Corrupted database - missing metadata chunk for " + name);
              }
              var collection = chunkCollection.metadata;
              chunkCollection.metadata = null;
              loki.collections[i] = collection;
              var isLazy = lazyCollections.includes(name);
              var lokiDeserializeCollectionChunks = function() {
                DEBUG && isLazy && console.log("lazy loading " + name);
                var data = [];
                var dataChunks = chunkCollection.dataChunks;
                dataChunks.forEach(function populateChunk(chunk, i2) {
                  if (isLazy) {
                    chunk = JSON.parse(chunk);
                    if (deserializeChunk) {
                      chunk = deserializeChunk(name, chunk);
                    }
                  }
                  chunk.forEach(function(doc) {
                    data.push(doc);
                  });
                  dataChunks[i2] = null;
                });
                return data;
              };
              collection.getData = lokiDeserializeCollectionChunks;
            }
          });
        }
        IncrementalIndexedDBAdapter.prototype._initializeIDB = function(dbname, onError, onSuccess) {
          var that = this;
          DEBUG && console.log("initializing idb");
          if (this.idbInitInProgress) {
            throw new Error("Cannot open IndexedDB because open is already in progress");
          }
          this.idbInitInProgress = true;
          var openRequest = indexedDB.open(dbname, 1);
          openRequest.onupgradeneeded = function(e) {
            var db = e.target.result;
            DEBUG && console.log("onupgradeneeded, old version: " + e.oldVersion);
            if (e.oldVersion < 1) {
              db.createObjectStore("LokiIncrementalData", { keyPath: "key" });
            } else {
              throw new Error("Invalid old version " + e.oldVersion + " for IndexedDB upgrade");
            }
          };
          openRequest.onsuccess = function(e) {
            that.idbInitInProgress = false;
            var db = e.target.result;
            that.idb = db;
            if (!db.objectStoreNames.contains("LokiIncrementalData")) {
              onError(new Error("Missing LokiIncrementalData"));
              that.deleteDatabase(dbname);
              return;
            }
            DEBUG && console.log("init success");
            db.onversionchange = function(versionChangeEvent) {
              if (that.idb !== db) {
                return;
              }
              DEBUG && console.log("IDB version change", versionChangeEvent);
              that.idb.close();
              that.idb = null;
              if (that.options.onversionchange) {
                that.options.onversionchange(versionChangeEvent);
              }
            };
            onSuccess();
          };
          openRequest.onblocked = function(e) {
            console.error("IndexedDB open is blocked", e);
            onError(new Error("IndexedDB open is blocked by open connection"));
          };
          openRequest.onerror = function(e) {
            that.idbInitInProgress = false;
            console.error("IndexedDB open error", e);
            onError(e);
          };
        };
        IncrementalIndexedDBAdapter.prototype._getAllChunks = function(dbname, callback) {
          var that = this;
          if (!this.idb) {
            this._initializeIDB(dbname, callback, function() {
              that._getAllChunks(dbname, callback);
            });
            return;
          }
          var tx = this.idb.transaction(["LokiIncrementalData"], "readonly");
          var store = tx.objectStore("LokiIncrementalData");
          var deserializeChunk = this.options.deserializeChunk;
          var lazyCollections = this.lazyCollections;
          function getMegachunks(keys) {
            var megachunkCount = that.megachunkCount;
            var keyRanges = createKeyRanges(keys, megachunkCount);
            var allChunks = [];
            var megachunksReceived = 0;
            function processMegachunk(e, megachunkIndex, keyRange) {
              var megachunk = e.target.result;
              megachunk.forEach(function(chunk, i2) {
                parseChunk(chunk, deserializeChunk, lazyCollections);
                allChunks.push(chunk);
                megachunk[i2] = null;
              });
              megachunksReceived += 1;
              if (megachunksReceived === megachunkCount) {
                callback(allChunks);
              }
            }
            var megachunkWaves = 2;
            var megachunksPerWave = megachunkCount / megachunkWaves;
            function requestMegachunk(index, wave) {
              var keyRange = keyRanges[index];
              idbReq(store.getAll(keyRange), function(e) {
                if (wave < megachunkWaves) {
                  requestMegachunk(index + megachunksPerWave, wave + 1);
                }
                processMegachunk(e, index, keyRange);
              }, function(e) {
                callback(e);
              });
            }
            for (var i = 0; i < megachunksPerWave; i += 1) {
              requestMegachunk(i, 1);
            }
          }
          function getAllChunks() {
            idbReq(store.getAll(), function(e) {
              var allChunks = e.target.result;
              allChunks.forEach(function(chunk) {
                parseChunk(chunk, deserializeChunk, lazyCollections);
              });
              callback(allChunks);
            }, function(e) {
              callback(e);
            });
          }
          function getAllKeys() {
            function onDidGetKeys(keys) {
              keys.sort();
              if (keys.length > 100) {
                getMegachunks(keys);
              } else {
                getAllChunks();
              }
            }
            idbReq(store.getAllKeys(), function(e) {
              onDidGetKeys(e.target.result);
            }, function(e) {
              callback(e);
            });
            if (that.options.onFetchStart) {
              that.options.onFetchStart();
            }
          }
          getAllKeys();
        };
        function classifyChunk(chunk) {
          var key = chunk.key;
          if (key === "loki") {
            chunk.type = "loki";
            return;
          } else if (key.includes(".")) {
            var keySegments = key.split(".");
            if (keySegments.length === 3 && keySegments[1] === "chunk") {
              chunk.type = "data";
              chunk.collectionName = keySegments[0];
              chunk.index = parseInt(keySegments[2], 10);
              return;
            } else if (keySegments.length === 2 && keySegments[1] === "metadata") {
              chunk.type = "metadata";
              chunk.collectionName = keySegments[0];
              return;
            }
          }
          console.error("Unknown chunk " + key);
          throw new Error("Corrupted database - unknown chunk found");
        }
        function parseChunk(chunk, deserializeChunk, lazyCollections) {
          classifyChunk(chunk);
          var isData = chunk.type === "data";
          var isLazy = lazyCollections.includes(chunk.collectionName);
          if (!(isData && isLazy)) {
            chunk.value = JSON.parse(chunk.value);
          }
          if (deserializeChunk && isData && !isLazy) {
            chunk.value = deserializeChunk(chunk.collectionName, chunk.value);
          }
        }
        IncrementalIndexedDBAdapter.prototype.deleteDatabase = function(dbname, callback) {
          if (this.operationInProgress) {
            throw new Error("Error while deleting database - another operation is already in progress. Please use throttledSaves=true option on Loki object");
          }
          this.operationInProgress = true;
          var that = this;
          DEBUG && console.log("deleteDatabase - begin");
          DEBUG && console.time("deleteDatabase");
          this._prevLokiVersionId = null;
          this._prevCollectionVersionIds = {};
          if (this.idb) {
            this.idb.close();
            this.idb = null;
          }
          var request = indexedDB.deleteDatabase(dbname);
          request.onsuccess = function() {
            that.operationInProgress = false;
            DEBUG && console.timeEnd("deleteDatabase");
            callback({ success: true });
          };
          request.onerror = function(e) {
            that.operationInProgress = false;
            console.error("Error while deleting database", e);
            callback({ success: false });
          };
          request.onblocked = function(e) {
            console.error("Deleting database failed because it's blocked by another connection", e);
          };
        };
        function randomVersionId() {
          return Math.random().toString(36).substring(2);
        }
        function sortChunksInPlace(chunks) {
          chunks.sort(function(a, b) {
            return (a.index || 0) - (b.index || 0);
          });
        }
        function createKeyRanges(keys, count) {
          var countPerRange = Math.floor(keys.length / count);
          var keyRanges = [];
          var minKey, maxKey;
          for (var i = 0; i < count; i += 1) {
            minKey = keys[countPerRange * i];
            maxKey = keys[countPerRange * (i + 1)];
            if (i === 0) {
              keyRanges.push(IDBKeyRange.upperBound(maxKey, true));
            } else if (i === count - 1) {
              keyRanges.push(IDBKeyRange.lowerBound(minKey));
            } else {
              keyRanges.push(IDBKeyRange.bound(minKey, maxKey, false, true));
            }
          }
          return keyRanges;
        }
        function idbReq(request, onsuccess, onerror) {
          request.onsuccess = function(e) {
            try {
              return onsuccess(e);
            } catch (error) {
              onerror(error);
            }
          };
          request.onerror = onerror;
          return request;
        }
        return IncrementalIndexedDBAdapter;
      })();
    });
  }
});

// node_modules/lokijs/src/loki-indexed-adapter.js
var require_loki_indexed_adapter = __commonJS({
  "node_modules/lokijs/src/loki-indexed-adapter.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.LokiIndexedAdapter = factory();
      }
    })(exports, function() {
      return (function() {
        function LokiIndexedAdapter(appname, options) {
          this.app = "loki";
          this.options = options || {};
          if (typeof appname !== "undefined") {
            this.app = appname;
          }
          this.catalog = null;
          if (!this.checkAvailability()) {
            throw new Error("indexedDB does not seem to be supported for your environment");
          }
        }
        LokiIndexedAdapter.prototype.closeDatabase = function() {
          if (this.catalog && this.catalog.db) {
            this.catalog.db.close();
            this.catalog.db = null;
          }
        };
        LokiIndexedAdapter.prototype.checkAvailability = function() {
          if (typeof indexedDB !== "undefined" && indexedDB) return true;
          return false;
        };
        LokiIndexedAdapter.prototype.loadDatabase = function(dbname, callback) {
          var appName = this.app;
          var adapter = this;
          if (this.catalog === null || this.catalog.db === null) {
            this.catalog = new LokiCatalog(function(cat) {
              adapter.catalog = cat;
              adapter.loadDatabase(dbname, callback);
            });
            return;
          }
          this.catalog.getAppKey(appName, dbname, function(result) {
            if (typeof callback === "function") {
              if (result.id === 0) {
                callback(null);
                return;
              }
              callback(result.val);
            } else {
              console.log(result.val);
            }
          });
        };
        LokiIndexedAdapter.prototype.loadKey = LokiIndexedAdapter.prototype.loadDatabase;
        LokiIndexedAdapter.prototype.saveDatabase = function(dbname, dbstring, callback) {
          var appName = this.app;
          var adapter = this;
          function saveCallback(result) {
            if (result && result.success === true) {
              callback(null);
            } else {
              callback(new Error("Error saving database"));
            }
            if (adapter.options.closeAfterSave) {
              adapter.closeDatabase();
            }
          }
          if (this.catalog === null || this.catalog.db === null) {
            this.catalog = new LokiCatalog(function(cat) {
              adapter.saveDatabase(dbname, dbstring, saveCallback);
            });
            return;
          }
          this.catalog.setAppKey(appName, dbname, dbstring, saveCallback);
        };
        LokiIndexedAdapter.prototype.saveKey = LokiIndexedAdapter.prototype.saveDatabase;
        LokiIndexedAdapter.prototype.deleteDatabase = function(dbname, callback) {
          var appName = this.app;
          var adapter = this;
          if (this.catalog === null || this.catalog.db === null) {
            this.catalog = new LokiCatalog(function(cat) {
              adapter.catalog = cat;
              adapter.deleteDatabase(dbname, callback);
            });
            return;
          }
          this.catalog.getAppKey(appName, dbname, function(result) {
            var id = result.id;
            if (id !== 0) {
              adapter.catalog.deleteAppKey(id, callback);
            } else if (typeof callback === "function") {
              callback({ success: true });
            }
          });
        };
        LokiIndexedAdapter.prototype.deleteKey = LokiIndexedAdapter.prototype.deleteDatabase;
        LokiIndexedAdapter.prototype.deleteDatabasePartitions = function(dbname) {
          var self2 = this;
          this.getDatabaseList(function(result) {
            result.forEach(function(str) {
              if (str.startsWith(dbname)) {
                self2.deleteDatabase(str);
              }
            });
          });
        };
        LokiIndexedAdapter.prototype.getDatabaseList = function(callback) {
          var appName = this.app;
          var adapter = this;
          if (this.catalog === null || this.catalog.db === null) {
            this.catalog = new LokiCatalog(function(cat) {
              adapter.catalog = cat;
              adapter.getDatabaseList(callback);
            });
            return;
          }
          this.catalog.getAppKeys(appName, function(results) {
            var names = [];
            for (var idx = 0; idx < results.length; idx++) {
              names.push(results[idx].key);
            }
            if (typeof callback === "function") {
              callback(names);
            } else {
              names.forEach(function(obj) {
                console.log(obj);
              });
            }
          });
        };
        LokiIndexedAdapter.prototype.getKeyList = LokiIndexedAdapter.prototype.getDatabaseList;
        LokiIndexedAdapter.prototype.getCatalogSummary = function(callback) {
          var appName = this.app;
          var adapter = this;
          if (this.catalog === null || this.catalog.db === null) {
            this.catalog = new LokiCatalog(function(cat) {
              adapter.catalog = cat;
              adapter.getCatalogSummary(callback);
            });
            return;
          }
          this.catalog.getAllKeys(function(results) {
            var entries = [];
            var obj, size, oapp, okey, oval;
            for (var idx = 0; idx < results.length; idx++) {
              obj = results[idx];
              oapp = obj.app || "";
              okey = obj.key || "";
              oval = obj.val || "";
              size = oapp.length * 2 + okey.length * 2 + oval.length + 1;
              entries.push({ "app": obj.app, "key": obj.key, "size": size });
            }
            if (typeof callback === "function") {
              callback(entries);
            } else {
              entries.forEach(function(obj2) {
                console.log(obj2);
              });
            }
          });
        };
        function LokiCatalog(callback) {
          this.db = null;
          this.initializeLokiCatalog(callback);
        }
        LokiCatalog.prototype.initializeLokiCatalog = function(callback) {
          var openRequest = indexedDB.open("LokiCatalog", 1);
          var cat = this;
          openRequest.onupgradeneeded = function(e) {
            var thisDB = e.target.result;
            if (thisDB.objectStoreNames.contains("LokiAKV")) {
              thisDB.deleteObjectStore("LokiAKV");
            }
            if (!thisDB.objectStoreNames.contains("LokiAKV")) {
              var objectStore = thisDB.createObjectStore("LokiAKV", { keyPath: "id", autoIncrement: true });
              objectStore.createIndex("app", "app", { unique: false });
              objectStore.createIndex("key", "key", { unique: false });
              objectStore.createIndex("appkey", "appkey", { unique: true });
            }
          };
          openRequest.onsuccess = function(e) {
            cat.db = e.target.result;
            if (typeof callback === "function") callback(cat);
          };
          openRequest.onerror = function(e) {
            throw e;
          };
        };
        LokiCatalog.prototype.getAppKey = function(app, key, callback) {
          var transaction = this.db.transaction(["LokiAKV"], "readonly");
          var store = transaction.objectStore("LokiAKV");
          var index = store.index("appkey");
          var appkey = app + "," + key;
          var request = index.get(appkey);
          request.onsuccess = /* @__PURE__ */ (function(usercallback) {
            return function(e) {
              var lres = e.target.result;
              if (lres === null || typeof lres === "undefined") {
                lres = {
                  id: 0,
                  success: false
                };
              }
              if (typeof usercallback === "function") {
                usercallback(lres);
              } else {
                console.log(lres);
              }
            };
          })(callback);
          request.onerror = /* @__PURE__ */ (function(usercallback) {
            return function(e) {
              if (typeof usercallback === "function") {
                usercallback({ id: 0, success: false });
              } else {
                throw e;
              }
            };
          })(callback);
        };
        LokiCatalog.prototype.getAppKeyById = function(id, callback, data) {
          var transaction = this.db.transaction(["LokiAKV"], "readonly");
          var store = transaction.objectStore("LokiAKV");
          var request = store.get(id);
          request.onsuccess = /* @__PURE__ */ (function(data2, usercallback) {
            return function(e) {
              if (typeof usercallback === "function") {
                usercallback(e.target.result, data2);
              } else {
                console.log(e.target.result);
              }
            };
          })(data, callback);
        };
        LokiCatalog.prototype.setAppKey = function(app, key, val, callback) {
          var transaction = this.db.transaction(["LokiAKV"], "readwrite");
          var store = transaction.objectStore("LokiAKV");
          var index = store.index("appkey");
          var appkey = app + "," + key;
          var request = index.get(appkey);
          request.onsuccess = function(e) {
            var res = e.target.result;
            if (res === null || res === void 0) {
              res = {
                app,
                key,
                appkey: app + "," + key,
                val
              };
            } else {
              res.val = val;
            }
            var requestPut = store.put(res);
            requestPut.onerror = /* @__PURE__ */ (function(usercallback) {
              return function(e2) {
                if (typeof usercallback === "function") {
                  usercallback({ success: false });
                } else {
                  console.error("LokiCatalog.setAppKey (set) onerror");
                  console.error(request.error);
                }
              };
            })(callback);
            requestPut.onsuccess = /* @__PURE__ */ (function(usercallback) {
              return function(e2) {
                if (typeof usercallback === "function") {
                  usercallback({ success: true });
                }
              };
            })(callback);
          };
          request.onerror = /* @__PURE__ */ (function(usercallback) {
            return function(e) {
              if (typeof usercallback === "function") {
                usercallback({ success: false });
              } else {
                console.error("LokiCatalog.setAppKey (get) onerror");
                console.error(request.error);
              }
            };
          })(callback);
        };
        LokiCatalog.prototype.deleteAppKey = function(id, callback) {
          var transaction = this.db.transaction(["LokiAKV"], "readwrite");
          var store = transaction.objectStore("LokiAKV");
          var request = store.delete(id);
          request.onsuccess = /* @__PURE__ */ (function(usercallback) {
            return function(evt) {
              if (typeof usercallback === "function") usercallback({ success: true });
            };
          })(callback);
          request.onerror = /* @__PURE__ */ (function(usercallback) {
            return function(evt) {
              if (typeof usercallback === "function") {
                usercallback({ success: false });
              } else {
                console.error("LokiCatalog.deleteAppKey raised onerror");
                console.error(request.error);
              }
            };
          })(callback);
        };
        LokiCatalog.prototype.getAppKeys = function(app, callback) {
          var transaction = this.db.transaction(["LokiAKV"], "readonly");
          var store = transaction.objectStore("LokiAKV");
          var index = store.index("app");
          var singleKeyRange = IDBKeyRange.only(app);
          var cursor = index.openCursor(singleKeyRange);
          var localdata = [];
          cursor.onsuccess = /* @__PURE__ */ (function(data, callback2) {
            return function(e) {
              var cursor2 = e.target.result;
              if (cursor2) {
                var currObject = cursor2.value;
                data.push(currObject);
                cursor2.continue();
              } else {
                if (typeof callback2 === "function") {
                  callback2(data);
                } else {
                  console.log(data);
                }
              }
            };
          })(localdata, callback);
          cursor.onerror = /* @__PURE__ */ (function(usercallback) {
            return function(e) {
              if (typeof usercallback === "function") {
                usercallback(null);
              } else {
                console.error("LokiCatalog.getAppKeys raised onerror");
                console.error(e);
              }
            };
          })(callback);
        };
        LokiCatalog.prototype.getAllKeys = function(callback) {
          var transaction = this.db.transaction(["LokiAKV"], "readonly");
          var store = transaction.objectStore("LokiAKV");
          var cursor = store.openCursor();
          var localdata = [];
          cursor.onsuccess = /* @__PURE__ */ (function(data, callback2) {
            return function(e) {
              var cursor2 = e.target.result;
              if (cursor2) {
                var currObject = cursor2.value;
                data.push(currObject);
                cursor2.continue();
              } else {
                if (typeof callback2 === "function") {
                  callback2(data);
                } else {
                  console.log(data);
                }
              }
            };
          })(localdata, callback);
          cursor.onerror = /* @__PURE__ */ (function(usercallback) {
            return function(e) {
              if (typeof usercallback === "function") usercallback(null);
            };
          })(callback);
        };
        return LokiIndexedAdapter;
      })();
    });
  }
});

// node_modules/lokijs/src/lokijs.wmelon.js
var require_lokijs_wmelon = __commonJS({
  "node_modules/lokijs/src/lokijs.wmelon.js"(exports, module) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof exports === "object") {
        module.exports = factory();
      } else {
        root.loki = factory();
      }
    })(exports, function() {
      return (function() {
        "use strict";
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function deepFreeze(obj) {
          var prop, i;
          if (Array.isArray(obj)) {
            for (i = 0; i < obj.length; i++) {
              deepFreeze(obj[i]);
            }
            freeze(obj);
          } else if (obj !== null && typeof obj === "object") {
            for (prop in obj) {
              if (obj.hasOwnProperty(prop)) {
                deepFreeze(obj[prop]);
              }
            }
            freeze(obj);
          }
        }
        function freeze(obj) {
          if (!Object.isFrozen(obj)) {
            Object.freeze(obj);
          }
        }
        function unFreeze(obj) {
          if (!Object.isFrozen(obj)) {
            return obj;
          }
          return clone(obj, "shallow");
        }
        var Utils = {
          copyProperties: function(src, dest) {
            var prop;
            for (prop in src) {
              dest[prop] = src[prop];
            }
          },
          // (Code skipped for WatermelonDB build)
          // By default (if usingDotNotation is false), looks up path in
          // object via `object[path]`
          //
          // If `usingDotNotation` is true, then the path is assumed to
          // represent a nested path. It can be in the form of an array of
          // field names, or a period delimited string. The function will
          // look up the value of object[path[0]], and then call
          // result[path[1]] on the result, etc etc.
          //
          // If `usingDotNotation` is true, this function still supports
          // non nested fields.
          //
          // `usingDotNotation` is a performance optimization. The caller
          // may know that a path is *not* nested. In which case, this
          // function avoids a costly string.split('.')
          //
          // examples:
          // getIn({a: 1}, "a") => 1
          // getIn({a: 1}, "a", true) => 1
          // getIn({a: {b: 1}}, ["a", "b"], true) => 1
          // getIn({a: {b: 1}}, "a.b", true) => 1
          getIn: function(object, path, usingDotNotation) {
            if (object == null) {
              return void 0;
            }
            if (!usingDotNotation) {
              return object[path];
            }
            if (typeof path === "string") {
              path = path.split(".");
            }
            if (!Array.isArray(path)) {
              throw new Error("path must be a string or array. Found " + typeof path);
            }
            var index = 0, length = path.length;
            while (object != null && index < length) {
              object = object[path[index++]];
            }
            return index && index == length ? object : void 0;
          }
        };
        var Comparators = {
          aeq: aeqHelper,
          lt: ltHelper,
          gt: gtHelper
        };
        function aeqHelper(prop1, prop2) {
          var cv1, cv2, t1, t2;
          if (prop1 === prop2) return true;
          if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
            switch (prop1) {
              case void 0:
                t1 = 1;
                break;
              case null:
                t1 = 1;
                break;
              case false:
                t1 = 3;
                break;
              case true:
                t1 = 4;
                break;
              case "":
                t1 = 5;
                break;
              default:
                t1 = prop1 === prop1 ? 9 : 0;
                break;
            }
            switch (prop2) {
              case void 0:
                t2 = 1;
                break;
              case null:
                t2 = 1;
                break;
              case false:
                t2 = 3;
                break;
              case true:
                t2 = 4;
                break;
              case "":
                t2 = 5;
                break;
              default:
                t2 = prop2 === prop2 ? 9 : 0;
                break;
            }
            if (t1 !== 9 || t2 !== 9) {
              return t1 === t2;
            }
          }
          cv1 = Number(prop1);
          cv2 = Number(prop2);
          if (cv1 === cv1 || cv2 === cv2) {
            return cv1 === cv2;
          }
          cv1 = prop1.toString();
          cv2 = prop2.toString();
          return cv1 == cv2;
        }
        function ltHelper(prop1, prop2, equal) {
          var cv1, cv2, t1, t2;
          if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
            switch (prop1) {
              case void 0:
                t1 = 1;
                break;
              case null:
                t1 = 1;
                break;
              case false:
                t1 = 3;
                break;
              case true:
                t1 = 4;
                break;
              case "":
                t1 = 5;
                break;
              // if strict equal probably 0 so sort higher, otherwise probably NaN so sort lower than even null
              default:
                t1 = prop1 === prop1 ? 9 : 0;
                break;
            }
            switch (prop2) {
              case void 0:
                t2 = 1;
                break;
              case null:
                t2 = 1;
                break;
              case false:
                t2 = 3;
                break;
              case true:
                t2 = 4;
                break;
              case "":
                t2 = 5;
                break;
              default:
                t2 = prop2 === prop2 ? 9 : 0;
                break;
            }
            if (t1 !== 9 || t2 !== 9) {
              return t1 === t2 ? equal : t1 < t2;
            }
          }
          cv1 = Number(prop1);
          cv2 = Number(prop2);
          if (cv1 === cv1 && cv2 === cv2) {
            if (cv1 < cv2) return true;
            if (cv1 > cv2) return false;
            return equal;
          }
          if (cv1 === cv1 && cv2 !== cv2) {
            return true;
          }
          if (cv2 === cv2 && cv1 !== cv1) {
            return false;
          }
          if (prop1 < prop2) return true;
          if (prop1 > prop2) return false;
          if (prop1 == prop2) return equal;
          cv1 = prop1.toString();
          cv2 = prop2.toString();
          if (cv1 < cv2) {
            return true;
          }
          if (cv1 == cv2) {
            return equal;
          }
          return false;
        }
        function gtHelper(prop1, prop2, equal) {
          var cv1, cv2, t1, t2;
          if (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {
            switch (prop1) {
              case void 0:
                t1 = 1;
                break;
              case null:
                t1 = 1;
                break;
              case false:
                t1 = 3;
                break;
              case true:
                t1 = 4;
                break;
              case "":
                t1 = 5;
                break;
              // NaN 0
              default:
                t1 = prop1 === prop1 ? 9 : 0;
                break;
            }
            switch (prop2) {
              case void 0:
                t2 = 1;
                break;
              case null:
                t2 = 1;
                break;
              case false:
                t2 = 3;
                break;
              case true:
                t2 = 4;
                break;
              case "":
                t2 = 5;
                break;
              default:
                t2 = prop2 === prop2 ? 9 : 0;
                break;
            }
            if (t1 !== 9 || t2 !== 9) {
              return t1 === t2 ? equal : t1 > t2;
            }
          }
          cv1 = Number(prop1);
          cv2 = Number(prop2);
          if (cv1 === cv1 && cv2 === cv2) {
            if (cv1 > cv2) return true;
            if (cv1 < cv2) return false;
            return equal;
          }
          if (cv1 === cv1 && cv2 !== cv2) {
            return false;
          }
          if (cv2 === cv2 && cv1 !== cv1) {
            return true;
          }
          if (prop1 > prop2) return true;
          if (prop1 < prop2) return false;
          if (prop1 == prop2) return equal;
          cv1 = prop1.toString();
          cv2 = prop2.toString();
          if (cv1 > cv2) {
            return true;
          }
          if (cv1 == cv2) {
            return equal;
          }
          return false;
        }
        function sortHelper(prop1, prop2, desc) {
          if (Comparators.aeq(prop1, prop2)) return 0;
          if (Comparators.lt(prop1, prop2, false)) {
            return desc ? 1 : -1;
          }
          if (Comparators.gt(prop1, prop2, false)) {
            return desc ? -1 : 1;
          }
          return 0;
        }
        function compoundeval(properties, obj1, obj2) {
          var res = 0;
          var prop, field, val1, val2, arr, path;
          for (var i = 0, len = properties.length; i < len; i++) {
            prop = properties[i];
            field = prop[0];
            if (~field.indexOf(".")) {
              arr = field.split(".");
              val1 = Utils.getIn(obj1, arr, true);
              val2 = Utils.getIn(obj2, arr, true);
            } else {
              val1 = obj1[field];
              val2 = obj2[field];
            }
            res = sortHelper(val1, val2, prop[1]);
            if (res !== 0) {
              return res;
            }
          }
          return 0;
        }
        function dotSubScan(root, paths, fun, value, extra, poffset) {
          var pathOffset = poffset || 0;
          var path = paths[pathOffset];
          var valueFound = false;
          var element;
          if (typeof root === "object" && path in root) {
            element = root[path];
          }
          if (pathOffset + 1 >= paths.length) {
            valueFound = fun(element, value, extra);
          } else if (Array.isArray(element)) {
            for (var index = 0, len = element.length; index < len; index += 1) {
              valueFound = dotSubScan(element[index], paths, fun, value, extra, pathOffset + 1);
              if (valueFound === true) {
                break;
              }
            }
          } else {
            valueFound = dotSubScan(element, paths, fun, value, extra, pathOffset + 1);
          }
          return valueFound;
        }
        function containsCheckFn(a) {
          if (typeof a === "string" || Array.isArray(a)) {
            return function(b) {
              return a.indexOf(b) !== -1;
            };
          } else if (typeof a === "object" && a !== null) {
            return function(b) {
              return hasOwnProperty.call(a, b);
            };
          }
          return null;
        }
        function doQueryOp(val, op, record) {
          for (var p in op) {
            if (hasOwnProperty.call(op, p)) {
              return LokiOps[p](val, op[p], record);
            }
          }
          return false;
        }
        var LokiOps = {
          // comparison operators
          // a is the value in the collection
          // b is the query value
          $eq: function(a, b) {
            return a === b;
          },
          // abstract/loose equality
          $aeq: function(a, b) {
            return a == b;
          },
          $ne: function(a, b) {
            if (b !== b) {
              return a === a;
            }
            return a !== b;
          },
          // date equality / loki abstract equality test
          $dteq: function(a, b) {
            return Comparators.aeq(a, b);
          },
          // loki comparisons: return identical unindexed results as indexed comparisons
          $gt: function(a, b) {
            return Comparators.gt(a, b, false);
          },
          $gte: function(a, b) {
            return Comparators.gt(a, b, true);
          },
          $lt: function(a, b) {
            return Comparators.lt(a, b, false);
          },
          $lte: function(a, b) {
            return Comparators.lt(a, b, true);
          },
          // lightweight javascript comparisons
          $jgt: function(a, b) {
            return a > b;
          },
          $jgte: function(a, b) {
            return a >= b;
          },
          $jlt: function(a, b) {
            return a < b;
          },
          $jlte: function(a, b) {
            return a <= b;
          },
          // ex : coll.find({'orderCount': {$between: [10, 50]}});
          $between: function(a, vals) {
            if (a === void 0 || a === null) return false;
            return Comparators.gt(a, vals[0], true) && Comparators.lt(a, vals[1], true);
          },
          $jbetween: function(a, vals) {
            if (a === void 0 || a === null) return false;
            return a >= vals[0] && a <= vals[1];
          },
          $in: function(a, b) {
            return b.indexOf(a) !== -1;
          },
          $inSet: function(a, b) {
            return b.has(a);
          },
          $nin: function(a, b) {
            return b.indexOf(a) === -1;
          },
          $keyin: function(a, b) {
            return a in b;
          },
          $nkeyin: function(a, b) {
            return !(a in b);
          },
          $definedin: function(a, b) {
            return b[a] !== void 0;
          },
          $undefinedin: function(a, b) {
            return b[a] === void 0;
          },
          $regex: function(a, b) {
            return b.test(a);
          },
          $containsString: function(a, b) {
            return typeof a === "string" && a.indexOf(b) !== -1;
          },
          $containsNone: function(a, b) {
            return !LokiOps.$containsAny(a, b);
          },
          $containsAny: function(a, b) {
            var checkFn = containsCheckFn(a);
            if (checkFn !== null) {
              return Array.isArray(b) ? b.some(checkFn) : checkFn(b);
            }
            return false;
          },
          $contains: function(a, b) {
            var checkFn = containsCheckFn(a);
            if (checkFn !== null) {
              return Array.isArray(b) ? b.every(checkFn) : checkFn(b);
            }
            return false;
          },
          $elemMatch: function(a, b) {
            if (Array.isArray(a)) {
              return a.some(function(item) {
                return Object.keys(b).every(function(property) {
                  var filter = b[property];
                  if (!(typeof filter === "object" && filter)) {
                    filter = { $eq: filter };
                  }
                  if (property.indexOf(".") !== -1) {
                    return dotSubScan(item, property.split("."), doQueryOp, b[property], item);
                  }
                  return doQueryOp(item[property], filter, item);
                });
              });
            }
            return false;
          },
          $type: function(a, b, record) {
            var type = typeof a;
            if (type === "object") {
              if (Array.isArray(a)) {
                type = "array";
              } else if (a instanceof Date) {
                type = "date";
              }
            }
            return typeof b !== "object" ? type === b : doQueryOp(type, b, record);
          },
          $finite: function(a, b) {
            return b === isFinite(a);
          },
          $size: function(a, b, record) {
            if (Array.isArray(a)) {
              return typeof b !== "object" ? a.length === b : doQueryOp(a.length, b, record);
            }
            return false;
          },
          $len: function(a, b, record) {
            if (typeof a === "string") {
              return typeof b !== "object" ? a.length === b : doQueryOp(a.length, b, record);
            }
            return false;
          },
          $where: function(a, b) {
            return b(a) === true;
          },
          // field-level logical operators
          // a is the value in the collection
          // b is the nested query operation (for '$not')
          //   or an array of nested query operations (for '$and' and '$or')
          $not: function(a, b, record) {
            return !doQueryOp(a, b, record);
          },
          $and: function(a, b, record) {
            for (var idx = 0, len = b.length; idx < len; idx += 1) {
              if (!doQueryOp(a, b[idx], record)) {
                return false;
              }
            }
            return true;
          },
          $or: function(a, b, record) {
            for (var idx = 0, len = b.length; idx < len; idx += 1) {
              if (doQueryOp(a, b[idx], record)) {
                return true;
              }
            }
            return false;
          },
          $exists: function(a, b) {
            if (b) {
              return a !== void 0;
            } else {
              return a === void 0;
            }
          }
        };
        var valueLevelOps = ["$eq", "$aeq", "$ne", "$dteq", "$gt", "$gte", "$lt", "$lte", "$jgt", "$jgte", "$jlt", "$jlte", "$type"];
        valueLevelOps.forEach(function(op) {
          var fun = LokiOps[op];
          LokiOps["$" + op] = function(a, spec, record) {
            if (typeof spec === "string") {
              return fun(a, record[spec]);
            } else if (typeof spec === "function") {
              return fun(a, spec(record));
            } else {
              throw new Error("Invalid argument to $$ matcher");
            }
          };
        });
        var indexedOps = {
          $eq: LokiOps.$eq,
          $aeq: true,
          $dteq: true,
          $gt: true,
          $gte: true,
          $lt: true,
          $lte: true,
          $in: true,
          $between: true
        };
        function clone(data, method) {
          if (data === null || data === void 0) {
            return null;
          }
          var cloneMethod = method || "parse-stringify", cloned;
          switch (cloneMethod) {
            case "parse-stringify":
              cloned = JSON.parse(JSON.stringify(data));
              break;
            // (Code skipped for WatermelonDB build)
            default:
              break;
          }
          return cloned;
        }
        function cloneObjectArray(objarray, method) {
          if (method == "parse-stringify") {
            return clone(objarray, method);
          }
          var result = [];
          for (var i = 0, len = objarray.length; i < len; i++) {
            result[i] = clone(objarray[i], method);
          }
          return result;
        }
        function LokiEventEmitter() {
        }
        LokiEventEmitter.prototype.events = {};
        LokiEventEmitter.prototype.asyncListeners = false;
        LokiEventEmitter.prototype.on = function(eventName, listener) {
          var event;
          var self2 = this;
          if (Array.isArray(eventName)) {
            eventName.forEach(function(currentEventName) {
              self2.on(currentEventName, listener);
            });
            return listener;
          }
          event = this.events[eventName];
          if (!event) {
            event = this.events[eventName] = [];
          }
          event.push(listener);
          return listener;
        };
        LokiEventEmitter.prototype.emit = function(eventName) {
          var self2 = this;
          var selfArgs;
          if (eventName && this.events[eventName]) {
            if (this.events[eventName].length) {
              selfArgs = Array.prototype.slice.call(arguments, 1);
              this.events[eventName].forEach(function(listener) {
                if (self2.asyncListeners) {
                  setTimeout(function() {
                    listener.apply(self2, selfArgs);
                  }, 1);
                } else {
                  listener.apply(self2, selfArgs);
                }
              });
            }
          } else {
            throw new Error("No event " + eventName + " defined");
          }
        };
        LokiEventEmitter.prototype.addListener = LokiEventEmitter.prototype.on;
        LokiEventEmitter.prototype.removeListener = function(eventName, listener) {
          var self2 = this;
          if (Array.isArray(eventName)) {
            eventName.forEach(function(currentEventName) {
              self2.removeListener(currentEventName, listener);
            });
            return;
          }
          if (this.events[eventName]) {
            var listeners = this.events[eventName];
            listeners.splice(listeners.indexOf(listener), 1);
          }
        };
        function Loki(filename, options) {
          this.filename = filename || "loki.db";
          this.collections = [];
          this.databaseVersion = 1.5;
          this.engineVersion = 1.5;
          this.autosave = false;
          this.autosaveInterval = 5e3;
          this.autosaveHandle = null;
          this.throttledSaves = true;
          this.options = {};
          this.persistenceMethod = null;
          this.persistenceAdapter = null;
          this.throttledSavePending = false;
          this.throttledCallbacks = [];
          this.verbose = options && options.hasOwnProperty("verbose") ? options.verbose : false;
          this.events = {
            "init": [],
            "loaded": [],
            "flushChanges": [],
            "close": [],
            "changes": [],
            "warning": []
          };
          this.configureOptions(options, true);
        }
        Loki.prototype = new LokiEventEmitter();
        Loki.prototype.constructor = Loki;
        Loki.prototype.configureOptions = function(options, initialConfig) {
          var defaultPersistence = {
            "NODEJS": "fs",
            "BROWSER": "localStorage",
            "CORDOVA": "localStorage",
            "MEMORY": "memory"
          }, persistenceMethods = {
            // (Code skipped for WatermelonDB build)
            "memory": LokiMemoryAdapter
          };
          this.options = {};
          this.persistenceMethod = null;
          this.persistenceAdapter = null;
          if (typeof options !== "undefined") {
            this.options = options;
            if (this.options.hasOwnProperty("persistenceMethod")) {
              if (typeof persistenceMethods[options.persistenceMethod] == "function") {
                this.persistenceMethod = options.persistenceMethod;
                this.persistenceAdapter = new persistenceMethods[options.persistenceMethod]();
              }
            }
            if (this.options.hasOwnProperty("adapter")) {
              this.persistenceMethod = "adapter";
              this.persistenceAdapter = options.adapter;
              this.options.adapter = null;
              this.isIncremental = this.persistenceAdapter.mode === "incremental";
            }
            if (options.autoload && initialConfig) {
              var self2 = this;
              setTimeout(function() {
                self2.loadDatabase(options, options.autoloadCallback);
              }, 1);
            }
            if (this.options.hasOwnProperty("autosaveInterval")) {
              this.autosaveDisable();
              this.autosaveInterval = parseInt(this.options.autosaveInterval, 10);
            }
            if (this.options.hasOwnProperty("autosave") && this.options.autosave) {
              this.autosaveDisable();
              this.autosave = true;
              if (this.options.hasOwnProperty("autosaveCallback")) {
                this.autosaveEnable(options, options.autosaveCallback);
              } else {
                this.autosaveEnable();
              }
            }
            if (this.options.hasOwnProperty("throttledSaves")) {
              this.throttledSaves = this.options.throttledSaves;
            }
          }
          if (!this.options.hasOwnProperty("serializationMethod")) {
            this.options.serializationMethod = "normal";
          }
          if (!this.options.hasOwnProperty("destructureDelimiter")) {
            this.options.destructureDelimiter = "$<\n";
          }
          if (this.persistenceAdapter === null) {
            this.persistenceMethod = defaultPersistence[this.ENV];
            if (this.persistenceMethod) {
              this.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();
            }
          }
        };
        Loki.prototype.copy = function(options) {
          var databaseCopy = new Loki(this.filename, { env: "NA" });
          var clen, idx;
          options = options || {};
          databaseCopy.loadJSONObject(this, { retainDirtyFlags: true });
          if (options.hasOwnProperty("removeNonSerializable") && options.removeNonSerializable === true) {
            databaseCopy.autosaveHandle = null;
            databaseCopy.persistenceAdapter = null;
            clen = databaseCopy.collections.length;
            for (idx = 0; idx < clen; idx++) {
              databaseCopy.collections[idx].constraints = null;
              databaseCopy.collections[idx].ttl = null;
            }
          }
          return databaseCopy;
        };
        Loki.prototype.addCollection = function(name, options) {
          var i, len = this.collections.length;
          for (i = 0; i < len; i += 1) {
            if (this.collections[i].name === name) {
              return this.collections[i];
            }
          }
          var collection = new Collection(name, options);
          collection.isIncremental = this.isIncremental;
          this.collections.push(collection);
          if (this.verbose)
            collection.lokiConsoleWrapper = console;
          return collection;
        };
        Loki.prototype.loadCollection = function(collection) {
          if (!collection.name) {
            throw new Error("Collection must have a name property to be loaded");
          }
          this.collections.push(collection);
        };
        Loki.prototype.getCollection = function(collectionName) {
          var i, len = this.collections.length;
          for (i = 0; i < len; i += 1) {
            if (this.collections[i].name === collectionName) {
              return this.collections[i];
            }
          }
          this.emit("warning", "collection " + collectionName + " not found");
          return null;
        };
        Loki.prototype.renameCollection = function(oldName, newName) {
          var c = this.getCollection(oldName);
          if (c) {
            c.name = newName;
          }
          return c;
        };
        Loki.prototype.removeCollection = function(collectionName) {
          var i, len = this.collections.length;
          for (i = 0; i < len; i += 1) {
            if (this.collections[i].name === collectionName) {
              var tmpcol = new Collection(collectionName, {});
              var curcol = this.collections[i];
              for (var prop in curcol) {
                if (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {
                  curcol[prop] = tmpcol[prop];
                }
              }
              this.collections.splice(i, 1);
              return;
            }
          }
        };
        Loki.prototype.getName = function() {
          return this.name;
        };
        Loki.prototype.serializeReplacer = function(key, value) {
          switch (key) {
            case "autosaveHandle":
            case "persistenceAdapter":
            case "constraints":
            case "ttl":
              return null;
            case "throttledSavePending":
            case "throttledCallbacks":
              return void 0;
            case "lokiConsoleWrapper":
              return null;
            default:
              return value;
          }
        };
        Loki.prototype.serialize = function(options) {
          options = options || {};
          if (!options.hasOwnProperty("serializationMethod")) {
            options.serializationMethod = this.options.serializationMethod;
          }
          switch (options.serializationMethod) {
            case "normal":
              return JSON.stringify(this, this.serializeReplacer);
            case "pretty":
              return JSON.stringify(this, this.serializeReplacer, 2);
            case "destructured":
              return this.serializeDestructured();
            // use default options
            default:
              return JSON.stringify(this, this.serializeReplacer);
          }
        };
        Loki.prototype.toJson = Loki.prototype.serialize;
        Loki.prototype.loadJSON = function(serializedDb, options) {
          var dbObject;
          if (serializedDb.length === 0) {
            dbObject = {};
          } else {
            switch (this.options.serializationMethod) {
              case "normal":
              case "pretty":
                dbObject = JSON.parse(serializedDb);
                break;
              case "destructured":
                dbObject = this.deserializeDestructured(serializedDb);
                break;
              default:
                dbObject = JSON.parse(serializedDb);
                break;
            }
          }
          this.loadJSONObject(dbObject, options);
        };
        Loki.prototype.loadJSONObject = function(dbObject, options) {
          var i = 0, len = dbObject.collections ? dbObject.collections.length : 0, coll, copyColl, clen, j, loader, collObj;
          this.name = dbObject.name;
          if (dbObject.hasOwnProperty("throttledSaves") && options && !options.hasOwnProperty("throttledSaves")) {
            this.throttledSaves = dbObject.throttledSaves;
          }
          this.collections = [];
          function makeLoader(coll2) {
            var collOptions = options[coll2.name];
            var inflater;
            if (collOptions.proto) {
              inflater = collOptions.inflate || Utils.copyProperties;
              return function(data) {
                var collObj2 = new collOptions.proto();
                inflater(data, collObj2);
                return collObj2;
              };
            }
            return collOptions.inflate;
          }
          for (i; i < len; i += 1) {
            coll = dbObject.collections[i];
            copyColl = this.addCollection(coll.name, {
              disableChangesApi: coll.disableChangesApi,
              disableDeltaChangesApi: coll.disableDeltaChangesApi,
              disableMeta: coll.disableMeta,
              disableFreeze: coll.hasOwnProperty("disableFreeze") ? coll.disableFreeze : true
            });
            copyColl.adaptiveBinaryIndices = coll.hasOwnProperty("adaptiveBinaryIndices") ? coll.adaptiveBinaryIndices === true : false;
            copyColl.transactional = coll.transactional;
            copyColl.asyncListeners = coll.asyncListeners;
            copyColl.cloneObjects = coll.cloneObjects;
            copyColl.cloneMethod = coll.cloneMethod || "parse-stringify";
            copyColl.autoupdate = coll.autoupdate;
            copyColl.changes = coll.changes;
            copyColl.dirtyIds = coll.dirtyIds || [];
            if (options && options.retainDirtyFlags === true) {
              copyColl.dirty = coll.dirty;
            } else {
              copyColl.dirty = false;
            }
            if (coll.getData) {
              if (options && options.hasOwnProperty(coll.name) || !copyColl.disableFreeze || copyColl.autoupdate) {
                throw new Error("this collection cannot be loaded lazily: " + coll.name);
              }
              copyColl.getData = coll.getData;
              Object.defineProperty(copyColl, "data", {
                /* jshint loopfunc:true */
                get: function() {
                  var data = this.getData();
                  this.getData = null;
                  Object.defineProperty(this, "data", { value: data });
                  return data;
                }
                /* jshint loopfunc:false */
              });
            } else {
              clen = coll.data.length;
              j = 0;
              if (options && options.hasOwnProperty(coll.name)) {
                loader = makeLoader(coll);
                for (j; j < clen; j++) {
                  collObj = loader(coll.data[j]);
                  copyColl.data[j] = collObj;
                  copyColl.addAutoUpdateObserver(collObj);
                  if (!copyColl.disableFreeze) {
                    deepFreeze(copyColl.data[j]);
                  }
                }
              } else {
                for (j; j < clen; j++) {
                  copyColl.data[j] = coll.data[j];
                  copyColl.addAutoUpdateObserver(copyColl.data[j]);
                  if (!copyColl.disableFreeze) {
                    deepFreeze(copyColl.data[j]);
                  }
                }
              }
            }
            copyColl.maxId = typeof coll.maxId === "undefined" ? 0 : coll.maxId;
            if (typeof coll.binaryIndices !== "undefined") {
              copyColl.binaryIndices = coll.binaryIndices;
            }
            if (typeof coll.transforms !== "undefined") {
              copyColl.transforms = coll.transforms;
            }
            copyColl.uniqueNames = [];
            if (coll.hasOwnProperty("uniqueNames")) {
              copyColl.uniqueNames = coll.uniqueNames;
            }
            if (dbObject.databaseVersion < 1.5) {
              copyColl.ensureAllIndexes(true);
              copyColl.dirty = true;
            }
          }
        };
        Loki.prototype.close = function(callback) {
          if (this.autosave) {
            this.autosaveDisable();
            if (this.autosaveDirty()) {
              this.saveDatabase(callback);
              callback = void 0;
            }
          }
          if (callback) {
            this.on("close", callback);
          }
          this.emit("close");
        };
        function LokiMemoryAdapter(options) {
          this.hashStore = {};
          this.options = options || {};
          if (!this.options.hasOwnProperty("asyncResponses")) {
            this.options.asyncResponses = false;
          }
          if (!this.options.hasOwnProperty("asyncTimeout")) {
            this.options.asyncTimeout = 50;
          }
        }
        LokiMemoryAdapter.prototype.loadDatabase = function(dbname, callback) {
          var self2 = this;
          if (this.options.asyncResponses) {
            setTimeout(function() {
              if (self2.hashStore.hasOwnProperty(dbname)) {
                callback(self2.hashStore[dbname].value);
              } else {
                callback(null);
              }
            }, this.options.asyncTimeout);
          } else {
            if (this.hashStore.hasOwnProperty(dbname)) {
              callback(this.hashStore[dbname].value);
            } else {
              callback(null);
            }
          }
        };
        LokiMemoryAdapter.prototype.saveDatabase = function(dbname, dbstring, callback) {
          var self2 = this;
          var saveCount;
          if (this.options.asyncResponses) {
            setTimeout(function() {
              saveCount = self2.hashStore.hasOwnProperty(dbname) ? self2.hashStore[dbname].savecount : 0;
              self2.hashStore[dbname] = {
                savecount: saveCount + 1,
                lastsave: /* @__PURE__ */ new Date(),
                value: dbstring
              };
              callback();
            }, this.options.asyncTimeout);
          } else {
            saveCount = this.hashStore.hasOwnProperty(dbname) ? this.hashStore[dbname].savecount : 0;
            this.hashStore[dbname] = {
              savecount: saveCount + 1,
              lastsave: /* @__PURE__ */ new Date(),
              value: dbstring
            };
            callback();
          }
        };
        LokiMemoryAdapter.prototype.deleteDatabase = function(dbname, callback) {
          if (this.hashStore.hasOwnProperty(dbname)) {
            delete this.hashStore[dbname];
          }
          if (typeof callback === "function") {
            callback();
          }
        };
        Loki.prototype.throttledSaveDrain = function(callback, options) {
          var self2 = this;
          var now = (/* @__PURE__ */ new Date()).getTime();
          if (!this.throttledSaves) {
            callback(true);
          }
          options = options || {};
          if (!options.hasOwnProperty("recursiveWait")) {
            options.recursiveWait = true;
          }
          if (!options.hasOwnProperty("recursiveWaitLimit")) {
            options.recursiveWaitLimit = false;
          }
          if (!options.hasOwnProperty("recursiveWaitLimitDuration")) {
            options.recursiveWaitLimitDuration = 2e3;
          }
          if (!options.hasOwnProperty("started")) {
            options.started = (/* @__PURE__ */ new Date()).getTime();
          }
          if (this.throttledSaves && this.throttledSavePending) {
            if (options.recursiveWait) {
              this.throttledCallbacks.push(function() {
                if (self2.throttledSavePending) {
                  if (options.recursiveWaitLimit && now - options.started > options.recursiveWaitLimitDuration) {
                    callback(false);
                    return;
                  }
                  self2.throttledSaveDrain(callback, options);
                  return;
                } else {
                  callback(true);
                  return;
                }
              });
            } else {
              this.throttledCallbacks.push(callback);
              return;
            }
          } else {
            callback(true);
          }
        };
        Loki.prototype.loadDatabaseInternal = function(options, callback) {
          var cFun = callback || function(err, data) {
            if (err) {
              throw err;
            }
          }, self2 = this;
          if (this.persistenceAdapter !== null) {
            this.persistenceAdapter.loadDatabase(this.filename, function loadDatabaseCallback(dbString) {
              if (typeof dbString === "string") {
                var parseSuccess = false;
                try {
                  self2.loadJSON(dbString, options || {});
                  parseSuccess = true;
                } catch (err) {
                  cFun(err);
                }
                if (parseSuccess) {
                  cFun(null);
                  self2.emit("loaded", "database " + self2.filename + " loaded");
                }
              } else {
                if (!dbString) {
                  cFun(null);
                  self2.emit("loaded", "empty database " + self2.filename + " loaded");
                  return;
                }
                if (dbString instanceof Error) {
                  cFun(dbString);
                  return;
                }
                if (typeof dbString === "object") {
                  self2.loadJSONObject(dbString, options || {});
                  cFun(null);
                  self2.emit("loaded", "database " + self2.filename + " loaded");
                  return;
                }
                cFun("unexpected adapter response : " + dbString);
              }
            });
          } else {
            cFun(new Error("persistenceAdapter not configured"));
          }
        };
        Loki.prototype.loadDatabase = function(options, callback) {
          var self2 = this;
          if (!this.throttledSaves) {
            this.loadDatabaseInternal(options, callback);
            return;
          }
          this.throttledSaveDrain(function(success) {
            if (success) {
              self2.throttledSavePending = true;
              self2.loadDatabaseInternal(options, function(err) {
                if (self2.throttledCallbacks.length === 0) {
                  self2.throttledSavePending = false;
                } else {
                  self2.saveDatabase();
                }
                if (typeof callback === "function") {
                  callback(err);
                }
              });
              return;
            } else {
              if (typeof callback === "function") {
                callback(new Error("Unable to pause save throttling long enough to read database"));
              }
            }
          }, options);
        };
        Loki.prototype.saveDatabaseInternal = function(callback) {
          var cFun = callback || function(err) {
            if (err) {
              throw err;
            }
            return;
          };
          var self2 = this;
          if (!this.persistenceAdapter) {
            cFun(new Error("persistenceAdapter not configured"));
            return;
          }
          if (this.persistenceAdapter.mode === "incremental") {
            var cachedDirty;
            this.ignoreAutosave = true;
            this.persistenceAdapter.saveDatabase(
              this.filename,
              function getLokiCopy() {
                self2.ignoreAutosave = false;
                if (cachedDirty) {
                  cFun(new Error("adapter error - getLokiCopy called more than once"));
                  return;
                }
                var lokiCopy = self2.copy({ removeNonSerializable: true });
                cachedDirty = self2.collections.map(function(collection) {
                  return [collection.dirty, collection.dirtyIds];
                });
                self2.collections.forEach(function(col) {
                  col.dirty = false;
                  col.dirtyIds = [];
                });
                return lokiCopy;
              },
              function exportDatabaseCallback(err) {
                self2.ignoreAutosave = false;
                if (err && cachedDirty) {
                  self2.collections.forEach(function(col, i) {
                    var cached = cachedDirty[i];
                    col.dirty = col.dirty || cached[0];
                    col.dirtyIds = col.dirtyIds.concat(cached[1]);
                  });
                }
                cFun(err);
              }
            );
          } else if (this.persistenceAdapter.mode === "reference" && typeof this.persistenceAdapter.exportDatabase === "function") {
            this.persistenceAdapter.exportDatabase(this.filename, this.copy({ removeNonSerializable: true }), function exportDatabaseCallback(err) {
              self2.autosaveClearFlags();
              cFun(err);
            });
          } else {
            this.autosaveClearFlags();
            this.persistenceAdapter.saveDatabase(this.filename, this.serialize(), function saveDatabasecallback(err) {
              cFun(err);
            });
          }
        };
        Loki.prototype.saveDatabase = function(callback) {
          if (!this.throttledSaves) {
            this.saveDatabaseInternal(callback);
            return;
          }
          if (this.throttledSavePending) {
            this.throttledCallbacks.push(callback);
            return;
          }
          var localCallbacks = this.throttledCallbacks;
          this.throttledCallbacks = [];
          localCallbacks.unshift(callback);
          this.throttledSavePending = true;
          var self2 = this;
          this.saveDatabaseInternal(function(err) {
            self2.throttledSavePending = false;
            localCallbacks.forEach(function(pcb) {
              if (typeof pcb === "function") {
                setTimeout(function() {
                  pcb(err);
                }, 1);
              }
            });
            if (self2.throttledCallbacks.length > 0) {
              self2.saveDatabase();
            }
          });
        };
        Loki.prototype.save = Loki.prototype.saveDatabase;
        Loki.prototype.deleteDatabase = function(options, callback) {
          var cFun = callback || function(err, data) {
            if (err) {
              throw err;
            }
          };
          if (typeof options === "function" && !callback) {
            cFun = options;
          }
          if (this.persistenceAdapter !== null) {
            this.persistenceAdapter.deleteDatabase(this.filename, function deleteDatabaseCallback(err) {
              cFun(err);
            });
          } else {
            cFun(new Error("persistenceAdapter not configured"));
          }
        };
        Loki.prototype.autosaveDirty = function() {
          for (var idx = 0; idx < this.collections.length; idx++) {
            if (this.collections[idx].dirty) {
              return true;
            }
          }
          return false;
        };
        Loki.prototype.autosaveClearFlags = function() {
          for (var idx = 0; idx < this.collections.length; idx++) {
            this.collections[idx].dirty = false;
          }
        };
        Loki.prototype.autosaveEnable = function(options, callback) {
          this.autosave = true;
          var delay = 5e3, self2 = this;
          if (typeof this.autosaveInterval !== "undefined" && this.autosaveInterval !== null) {
            delay = this.autosaveInterval;
          }
          this.autosaveHandle = setInterval(function autosaveHandleInterval() {
            if (self2.autosaveDirty() && !self2.ignoreAutosave) {
              self2.saveDatabase(callback);
            }
          }, delay);
        };
        Loki.prototype.autosaveDisable = function() {
          if (typeof this.autosaveHandle !== "undefined" && this.autosaveHandle !== null) {
            clearInterval(this.autosaveHandle);
            this.autosaveHandle = null;
          }
        };
        function Resultset(collection, options) {
          options = options || {};
          this.collection = collection;
          this.filteredrows = [];
          this.filterInitialized = false;
          return this;
        }
        Resultset.prototype.reset = function() {
          if (this.filteredrows.length > 0) {
            this.filteredrows = [];
          }
          this.filterInitialized = false;
          return this;
        };
        Resultset.prototype.toJSON = function() {
          var copy = this.copy();
          copy.collection = null;
          return copy;
        };
        Resultset.prototype.limit = function(qty) {
          if (!this.filterInitialized && this.filteredrows.length === 0) {
            this.filteredrows = this.collection.prepareFullDocIndex();
          }
          var rscopy = new Resultset(this.collection);
          rscopy.filteredrows = this.filteredrows.slice(0, qty);
          rscopy.filterInitialized = true;
          return rscopy;
        };
        Resultset.prototype.offset = function(pos) {
          if (!this.filterInitialized && this.filteredrows.length === 0) {
            this.filteredrows = this.collection.prepareFullDocIndex();
          }
          var rscopy = new Resultset(this.collection);
          rscopy.filteredrows = this.filteredrows.slice(pos);
          rscopy.filterInitialized = true;
          return rscopy;
        };
        Resultset.prototype.copy = function() {
          var result = new Resultset(this.collection);
          if (this.filteredrows.length > 0) {
            result.filteredrows = this.filteredrows.slice();
          }
          result.filterInitialized = this.filterInitialized;
          return result;
        };
        Resultset.prototype.branch = Resultset.prototype.copy;
        Resultset.prototype.sort = function(comparefun) {
          if (!this.filterInitialized && this.filteredrows.length === 0) {
            this.filteredrows = this.collection.prepareFullDocIndex();
          }
          var wrappedComparer = /* @__PURE__ */ (function(userComparer, data) {
            return function(a, b) {
              return userComparer(data[a], data[b]);
            };
          })(comparefun, this.collection.data);
          this.filteredrows.sort(wrappedComparer);
          return this;
        };
        Resultset.prototype.simplesort = function(propname, options) {
          var eff, targetEff = 10, dc = this.collection.data.length, frl = this.filteredrows.length, hasBinaryIndex = this.collection.binaryIndices.hasOwnProperty(propname);
          if (typeof options === "undefined" || options === false) {
            options = { desc: false };
          }
          if (options === true) {
            options = { desc: true };
          }
          if (frl === 0) {
            if (this.filterInitialized) {
              return this;
            }
            if (this.collection.binaryIndices.hasOwnProperty(propname)) {
              this.collection.ensureIndex(propname);
              this.filteredrows = this.collection.binaryIndices[propname].values.slice(0);
              if (options.desc) {
                this.filteredrows.reverse();
              }
              return this;
            } else {
              this.filteredrows = this.collection.prepareFullDocIndex();
            }
          } else {
            if (!options.disableIndexIntersect && hasBinaryIndex) {
              eff = dc / frl;
              if (options.useJavascriptSorting) {
                targetEff = 6;
              }
              if (eff <= targetEff || options.forceIndexIntersect) {
                var idx, fr = this.filteredrows;
                var io = {};
                for (idx = 0; idx < frl; idx++) {
                  io[fr[idx]] = true;
                }
                var pv = this.collection.binaryIndices[propname].values;
                this.filteredrows = pv.filter(function(n) {
                  return io[n];
                });
                if (options.desc) {
                  this.filteredrows.reverse();
                }
                return this;
              }
            }
          }
          if (options.useJavascriptSorting) {
            return this.sort(function(obj1, obj2) {
              if (obj1[propname] === obj2[propname]) return 0;
              if (obj1[propname] > obj2[propname]) return 1;
              if (obj1[propname] < obj2[propname]) return -1;
            });
          }
          var wrappedComparer = /* @__PURE__ */ (function(prop, desc, data) {
            var val1, val2, arr;
            return function(a, b) {
              if (~prop.indexOf(".")) {
                arr = prop.split(".");
                val1 = Utils.getIn(data[a], arr, true);
                val2 = Utils.getIn(data[b], arr, true);
              } else {
                val1 = data[a][prop];
                val2 = data[b][prop];
              }
              return sortHelper(val1, val2, desc);
            };
          })(propname, options.desc, this.collection.data);
          this.filteredrows.sort(wrappedComparer);
          return this;
        };
        Resultset.prototype.compoundsort = function(properties) {
          if (properties.length === 0) {
            throw new Error("Invalid call to compoundsort, need at least one property");
          }
          var prop;
          if (properties.length === 1) {
            prop = properties[0];
            if (Array.isArray(prop)) {
              return this.simplesort(prop[0], prop[1]);
            }
            return this.simplesort(prop, false);
          }
          for (var i = 0, len = properties.length; i < len; i += 1) {
            prop = properties[i];
            if (!Array.isArray(prop)) {
              properties[i] = [prop, false];
            }
          }
          if (!this.filterInitialized && this.filteredrows.length === 0) {
            this.filteredrows = this.collection.prepareFullDocIndex();
          }
          var wrappedComparer = /* @__PURE__ */ (function(props, data) {
            return function(a, b) {
              return compoundeval(props, data[a], data[b]);
            };
          })(properties, this.collection.data);
          this.filteredrows.sort(wrappedComparer);
          return this;
        };
        Resultset.prototype.findOr = function(expressionArray) {
          var fr = null, fri = 0, frlen = 0, docset = [], idxset = [], idx = 0, origCount = this.count();
          for (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {
            fr = this.branch().find(expressionArray[ei]).filteredrows;
            frlen = fr.length;
            for (fri = 0; fri < frlen; fri++) {
              idx = fr[fri];
              if (idxset[idx] === void 0) {
                idxset[idx] = true;
                docset.push(idx);
              }
            }
          }
          this.filteredrows = docset;
          this.filterInitialized = true;
          return this;
        };
        Resultset.prototype.$or = Resultset.prototype.findOr;
        function precompileQuery(operator, value) {
          if (operator === "$regex") {
            if (Array.isArray(value)) {
              value = new RegExp(value[0], value[1]);
            } else if (!(value instanceof RegExp)) {
              value = new RegExp(value);
            }
          } else if (typeof value === "object") {
            for (var key in value) {
              if (key === "$regex" || typeof value[key] === "object") {
                value[key] = precompileQuery(key, value[key]);
              }
            }
          }
          return value;
        }
        Resultset.prototype.findAnd = function(expressionArray) {
          for (var i = 0, len = expressionArray.length; i < len; i++) {
            if (this.count() === 0) {
              return this;
            }
            this.find(expressionArray[i]);
          }
          return this;
        };
        Resultset.prototype.$and = Resultset.prototype.findAnd;
        Resultset.prototype.find = function(query, firstOnly) {
          if (this.collection.data.length === 0) {
            this.filteredrows = [];
            this.filterInitialized = true;
            return this;
          }
          var queryObject = query || "getAll", p, property, queryObjectOp, obj, operator, value, key, searchByIndex = false, result = [], filters = [], index = null;
          firstOnly = firstOnly || false;
          if (typeof queryObject === "object") {
            for (p in queryObject) {
              obj = {};
              obj[p] = queryObject[p];
              filters.push(obj);
              if (hasOwnProperty.call(queryObject, p)) {
                property = p;
                queryObjectOp = queryObject[p];
              }
            }
            if (filters.length > 1) {
              return this.find({ "$and": filters }, firstOnly);
            }
          }
          if (!property || queryObject === "getAll") {
            if (firstOnly) {
              if (this.filterInitialized) {
                this.filteredrows = this.filteredrows.slice(0, 1);
              } else {
                this.filteredrows = this.collection.data.length > 0 ? [0] : [];
                this.filterInitialized = true;
              }
            }
            return this;
          }
          if (property === "$and" || property === "$or") {
            this[property](queryObjectOp);
            if (firstOnly && this.filteredrows.length > 1) {
              this.filteredrows = this.filteredrows.slice(0, 1);
            }
            return this;
          }
          if (queryObjectOp === null || (typeof queryObjectOp !== "object" || queryObjectOp instanceof Date)) {
            operator = "$eq";
            value = queryObjectOp;
          } else if (typeof queryObjectOp === "object") {
            for (key in queryObjectOp) {
              if (hasOwnProperty.call(queryObjectOp, key)) {
                operator = key;
                value = queryObjectOp[key];
                break;
              }
            }
          } else {
            throw new Error("Do not know what you want to do.");
          }
          if (operator === "$regex" || typeof value === "object") {
            value = precompileQuery(operator, value);
          }
          var usingDotNotation = property.indexOf(".") !== -1;
          var doIndexCheck = !this.filterInitialized;
          if (doIndexCheck && this.collection.binaryIndices[property] && indexedOps[operator]) {
            if (this.collection.adaptiveBinaryIndices !== true) {
              this.collection.ensureIndex(property);
            }
            searchByIndex = true;
            index = this.collection.binaryIndices[property];
          }
          if (!searchByIndex && operator === "$in" && Array.isArray(value) && typeof Set !== "undefined") {
            value = new Set(value);
            operator = "$inSet";
          }
          var fun = LokiOps[operator];
          var t = this.collection.data;
          var i = 0, len = 0;
          var filter, rowIdx = 0, record;
          if (this.filterInitialized) {
            filter = this.filteredrows;
            len = filter.length;
            if (usingDotNotation) {
              property = property.split(".");
              for (i = 0; i < len; i++) {
                rowIdx = filter[i];
                record = t[rowIdx];
                if (dotSubScan(record, property, fun, value, record)) {
                  result.push(rowIdx);
                  if (firstOnly) {
                    this.filteredrows = result;
                    return this;
                  }
                }
              }
            } else {
              for (i = 0; i < len; i++) {
                rowIdx = filter[i];
                record = t[rowIdx];
                if (fun(record[property], value, record)) {
                  result.push(rowIdx);
                  if (firstOnly) {
                    this.filteredrows = result;
                    return this;
                  }
                }
              }
            }
          } else {
            if (!searchByIndex) {
              len = t.length;
              if (usingDotNotation) {
                property = property.split(".");
                for (i = 0; i < len; i++) {
                  record = t[i];
                  if (dotSubScan(record, property, fun, value, record)) {
                    result.push(i);
                    if (firstOnly) {
                      this.filteredrows = result;
                      this.filterInitialized = true;
                      return this;
                    }
                  }
                }
              } else {
                for (i = 0; i < len; i++) {
                  record = t[i];
                  if (fun(record[property], value, record)) {
                    result.push(i);
                    if (firstOnly) {
                      this.filteredrows = result;
                      this.filterInitialized = true;
                      return this;
                    }
                  }
                }
              }
            } else {
              var segm = this.collection.calculateRange(operator, property, value);
              if (operator !== "$in") {
                for (i = segm[0]; i <= segm[1]; i++) {
                  if (indexedOps[operator] !== true) {
                    if (indexedOps[operator](Utils.getIn(t[index.values[i]], property, usingDotNotation), value)) {
                      result.push(index.values[i]);
                      if (firstOnly) {
                        this.filteredrows = result;
                        this.filterInitialized = true;
                        return this;
                      }
                    }
                  } else {
                    result.push(index.values[i]);
                    if (firstOnly) {
                      this.filteredrows = result;
                      this.filterInitialized = true;
                      return this;
                    }
                  }
                }
              } else {
                for (i = 0, len = segm.length; i < len; i++) {
                  result.push(index.values[segm[i]]);
                  if (firstOnly) {
                    this.filteredrows = result;
                    this.filterInitialized = true;
                    return this;
                  }
                }
              }
            }
          }
          this.filteredrows = result;
          this.filterInitialized = true;
          return this;
        };
        Resultset.prototype.where = function(fun) {
          var viewFunction, result = [];
          if ("function" === typeof fun) {
            viewFunction = fun;
          } else {
            throw new TypeError("Argument is not a stored view or a function");
          }
          try {
            if (this.filterInitialized) {
              var j = this.filteredrows.length;
              while (j--) {
                if (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {
                  result.push(this.filteredrows[j]);
                }
              }
              this.filteredrows = result;
              return this;
            } else {
              var k = this.collection.data.length;
              while (k--) {
                if (viewFunction(this.collection.data[k]) === true) {
                  result.push(k);
                }
              }
              this.filteredrows = result;
              this.filterInitialized = true;
              return this;
            }
          } catch (err) {
            throw err;
          }
        };
        Resultset.prototype.count = function() {
          if (this.filterInitialized) {
            return this.filteredrows.length;
          }
          return this.collection.count();
        };
        Resultset.prototype.data = function(options) {
          var result = [], data = this.collection.data, obj, len, i, method;
          options = options || {};
          if (options.removeMeta && !options.forceClones) {
            options.forceClones = true;
            options.forceCloneMethod = options.forceCloneMethod || "shallow";
          }
          if (!this.collection.disableDeltaChangesApi && this.collection.disableFreeze) {
            options.forceClones = true;
            options.forceCloneMethod = "parse-stringify";
          }
          if (!this.filterInitialized) {
            if (this.filteredrows.length === 0) {
              if (this.collection.cloneObjects || options.forceClones) {
                len = data.length;
                method = options.forceCloneMethod || this.collection.cloneMethod;
                for (i = 0; i < len; i++) {
                  obj = clone(data[i], method);
                  if (options.removeMeta) {
                    delete obj.$loki;
                    delete obj.meta;
                  }
                  result.push(obj);
                }
                return result;
              } else {
                return data.slice();
              }
            } else {
              this.filterInitialized = true;
            }
          }
          var fr = this.filteredrows;
          len = fr.length;
          if (this.collection.cloneObjects || options.forceClones) {
            method = options.forceCloneMethod || this.collection.cloneMethod;
            for (i = 0; i < len; i++) {
              obj = clone(data[fr[i]], method);
              if (options.removeMeta) {
                delete obj.$loki;
                delete obj.meta;
              }
              result.push(obj);
            }
          } else {
            for (i = 0; i < len; i++) {
              result.push(data[fr[i]]);
            }
          }
          return result;
        };
        Resultset.prototype.update = function(updateFunction) {
          if (typeof updateFunction !== "function") {
            throw new TypeError("Argument is not a function");
          }
          if (!this.filterInitialized && this.filteredrows.length === 0) {
            this.filteredrows = this.collection.prepareFullDocIndex();
          }
          var obj, len = this.filteredrows.length, rcd = this.collection.data;
          for (var idx = 0; idx < len; idx++) {
            if (!this.disableFreeze || this.collection.cloneObjects || !this.collection.disableDeltaChangesApi) {
              obj = clone(rcd[this.filteredrows[idx]], this.collection.cloneMethod);
              updateFunction(obj);
              this.collection.update(obj);
            } else {
              updateFunction(rcd[this.filteredrows[idx]]);
              this.collection.update(rcd[this.filteredrows[idx]]);
            }
          }
          return this;
        };
        Resultset.prototype.remove = function() {
          if (!this.filterInitialized && this.filteredrows.length === 0) {
            this.filteredrows = this.collection.prepareFullDocIndex();
          }
          this.collection.removeBatchByPositions(this.filteredrows);
          this.filteredrows = [];
          return this;
        };
        Resultset.prototype.map = function(mapFun, dataOptions) {
          var data = this.data(dataOptions).map(mapFun);
          this.collection = new Collection("mappedData");
          this.collection.insert(data);
          this.filteredrows = [];
          this.filterInitialized = false;
          return this;
        };
        function Collection(name, options) {
          this.name = name;
          this.data = [];
          this.idIndex = null;
          this.binaryIndices = {};
          this.constraints = {
            unique: {},
            exact: {}
          };
          this.uniqueNames = [];
          this.transforms = {};
          this.objType = name;
          this.dirty = true;
          this.cachedIndex = null;
          this.cachedBinaryIndex = null;
          this.cachedData = null;
          var self2 = this;
          options = options || {};
          if (options.hasOwnProperty("unique")) {
            if (!Array.isArray(options.unique)) {
              options.unique = [options.unique];
            }
            options.unique.forEach(function(prop) {
              self2.uniqueNames.push(prop);
            });
          }
          this.adaptiveBinaryIndices = options.hasOwnProperty("adaptiveBinaryIndices") ? options.adaptiveBinaryIndices : true;
          this.transactional = options.hasOwnProperty("transactional") ? options.transactional : false;
          this.cloneObjects = options.hasOwnProperty("clone") ? options.clone : false;
          this.cloneMethod = options.hasOwnProperty("cloneMethod") ? options.cloneMethod : "parse-stringify";
          this.asyncListeners = options.hasOwnProperty("asyncListeners") ? options.asyncListeners : false;
          this.disableMeta = options.hasOwnProperty("disableMeta") ? options.disableMeta : false;
          this.disableChangesApi = options.hasOwnProperty("disableChangesApi") ? options.disableChangesApi : true;
          this.disableDeltaChangesApi = options.hasOwnProperty("disableDeltaChangesApi") ? options.disableDeltaChangesApi : true;
          if (this.disableChangesApi) {
            this.disableDeltaChangesApi = true;
          }
          this.autoupdate = options.hasOwnProperty("autoupdate") ? options.autoupdate : false;
          this.serializableIndices = options.hasOwnProperty("serializableIndices") ? options.serializableIndices : true;
          this.disableFreeze = options.hasOwnProperty("disableFreeze") ? options.disableFreeze : true;
          this.maxId = 0;
          this.DynamicViews = [];
          this.events = {
            "insert": [],
            "update": [],
            "pre-insert": [],
            "pre-update": [],
            "close": [],
            "flushbuffer": [],
            "error": [],
            "delete": [],
            "warning": []
          };
          this.changes = [];
          this.dirtyIds = [];
          var indices = [];
          if (options && options.indices) {
            if (Object.prototype.toString.call(options.indices) === "[object Array]") {
              indices = options.indices;
            } else if (typeof options.indices === "string") {
              indices = [options.indices];
            } else {
              throw new TypeError("Indices needs to be a string or an array of strings");
            }
          }
          for (var idx = 0; idx < indices.length; idx++) {
            this.ensureIndex(indices[idx]);
          }
          this.on("warning", function(warning) {
            self2.lokiConsoleWrapper.warn(warning);
          });
        }
        Collection.prototype = new LokiEventEmitter();
        Collection.prototype.contructor = Collection;
        Collection.prototype.lokiConsoleWrapper = {
          log: function() {
          },
          warn: function() {
          },
          error: function() {
          }
        };
        Collection.prototype.addAutoUpdateObserver = function(object) {
        };
        Collection.prototype.removeAutoUpdateObserver = function(object) {
        };
        Collection.prototype.prepareFullDocIndex = function() {
          var len = this.data.length;
          var indexes = new Array(len);
          for (var i = 0; i < len; i += 1) {
            indexes[i] = i;
          }
          return indexes;
        };
        Collection.prototype.configureOptions = function(options) {
          options = options || {};
          if (options.hasOwnProperty("adaptiveBinaryIndices")) {
            this.adaptiveBinaryIndices = options.adaptiveBinaryIndices;
            if (this.adaptiveBinaryIndices) {
              this.ensureAllIndexes();
            }
          }
        };
        Collection.prototype.ensureIndex = function(property, force) {
          if (typeof force === "undefined") {
            force = false;
          }
          if (property === null || property === void 0) {
            throw new Error("Attempting to set index without an associated property");
          }
          if (this.binaryIndices[property] && !force) {
            if (!this.binaryIndices[property].dirty) return;
          }
          if (this.adaptiveBinaryIndices === true && this.binaryIndices.hasOwnProperty(property) && !force) {
            return;
          }
          var index = {
            "name": property,
            "dirty": true,
            "values": this.prepareFullDocIndex()
          };
          this.binaryIndices[property] = index;
          var wrappedComparer = (function(prop, data) {
            var val1, val2;
            var propPath = ~prop.indexOf(".") ? prop.split(".") : false;
            return function(a, b) {
              if (propPath) {
                val1 = Utils.getIn(data[a], propPath, true);
                val2 = Utils.getIn(data[b], propPath, true);
              } else {
                val1 = data[a][prop];
                val2 = data[b][prop];
              }
              if (val1 !== val2) {
                if (Comparators.lt(val1, val2, false)) return -1;
                if (Comparators.gt(val1, val2, false)) return 1;
              }
              return 0;
            };
          })(property, this.data);
          index.values.sort(wrappedComparer);
          index.dirty = false;
          this.dirty = true;
        };
        Collection.prototype.checkAllIndexes = function(options) {
          var key, bIndices = this.binaryIndices;
          var results = [], result;
          for (key in bIndices) {
            if (hasOwnProperty.call(bIndices, key)) {
              result = this.checkIndex(key, options);
              if (!result) {
                results.push(key);
              }
            }
          }
          return results;
        };
        Collection.prototype.checkIndex = function(property, options) {
          options = options || {};
          if (options.randomSamplingFactor && options.randomSampling !== false) {
            options.randomSampling = true;
          }
          options.randomSamplingFactor = options.randomSamplingFactor || 0.1;
          if (options.randomSamplingFactor < 0 || options.randomSamplingFactor > 1) {
            options.randomSamplingFactor = 0.1;
          }
          var valid = true, idx, iter, pos, len, biv;
          if (!this.binaryIndices.hasOwnProperty(property)) {
            throw new Error("called checkIndex on property without an index: " + property);
          }
          if (!this.adaptiveBinaryIndices) {
            this.ensureIndex(property);
          }
          biv = this.binaryIndices[property].values;
          len = biv.length;
          if (len !== this.data.length) {
            if (options.repair) {
              this.ensureIndex(property, true);
            }
            return false;
          }
          if (len === 0) {
            return true;
          }
          var usingDotNotation = property.indexOf(".") !== -1;
          if (len === 1) {
            valid = biv[0] === 0;
          } else {
            if (options.randomSampling) {
              if (!LokiOps.$lte(
                Utils.getIn(this.data[biv[0]], property, usingDotNotation),
                Utils.getIn(this.data[biv[1]], property, usingDotNotation)
              )) {
                valid = false;
              }
              if (!LokiOps.$lte(
                Utils.getIn(this.data[biv[len - 2]], property, usingDotNotation),
                Utils.getIn(this.data[biv[len - 1]], property, usingDotNotation)
              )) {
                valid = false;
              }
              if (valid) {
                iter = Math.floor((len - 1) * options.randomSamplingFactor);
                for (idx = 0; idx < iter - 1; idx++) {
                  pos = Math.floor(Math.random() * (len - 1));
                  if (!LokiOps.$lte(
                    Utils.getIn(this.data[biv[pos]], property, usingDotNotation),
                    Utils.getIn(this.data[biv[pos + 1]], property, usingDotNotation)
                  )) {
                    valid = false;
                    break;
                  }
                }
              }
            } else {
              for (idx = 0; idx < len - 1; idx++) {
                if (!LokiOps.$lte(
                  Utils.getIn(this.data[biv[idx]], property, usingDotNotation),
                  Utils.getIn(this.data[biv[idx + 1]], property, usingDotNotation)
                )) {
                  valid = false;
                  break;
                }
              }
            }
          }
          if (!valid && options.repair) {
            this.ensureIndex(property, true);
          }
          return valid;
        };
        Collection.prototype.getBinaryIndexValues = function(property) {
          var idx, idxvals = this.binaryIndices[property].values;
          var result = [];
          for (idx = 0; idx < idxvals.length; idx++) {
            result.push(Utils.getIn(this.data[idxvals[idx]], property, true));
          }
          return result;
        };
        Collection.prototype.getUniqueIndex = function(field, force) {
          var index = this.constraints.unique[field];
          if (!index && force) {
            return this.ensureUniqueIndex(field);
          }
          return index;
        };
        Collection.prototype.ensureUniqueIndex = function(field) {
          var index = this.constraints.unique[field];
          if (!index) {
            if (this.uniqueNames.indexOf(field) == -1) {
              this.uniqueNames.push(field);
            }
          }
          this.constraints.unique[field] = index = new UniqueIndex(field);
          this.data.forEach(function(obj) {
            index.set(obj);
          });
          return index;
        };
        Collection.prototype.ensureAllIndexes = function(force) {
          var key, bIndices = this.binaryIndices;
          for (key in bIndices) {
            if (hasOwnProperty.call(bIndices, key)) {
              this.ensureIndex(key, force);
            }
          }
        };
        Collection.prototype.flagBinaryIndexesDirty = function() {
          var key, bIndices = this.binaryIndices;
          for (key in bIndices) {
            if (hasOwnProperty.call(bIndices, key)) {
              bIndices[key].dirty = true;
            }
          }
        };
        Collection.prototype.flagBinaryIndexDirty = function(index) {
          if (this.binaryIndices[index])
            this.binaryIndices[index].dirty = true;
        };
        Collection.prototype.count = function(query) {
          if (!query) {
            return this.data.length;
          }
          return this.chain().find(query).filteredrows.length;
        };
        Collection.prototype.ensureId = function() {
          if (this.idIndex) {
            return;
          }
          var data = this.data, i = 0;
          var len = data.length;
          var index = new Array(len);
          for (i; i < len; i++) {
            index[i] = data[i].$loki;
          }
          this.idIndex = index;
        };
        Collection.prototype.findAndUpdate = function(filterObject, updateFunction) {
          if (typeof filterObject === "function") {
            this.updateWhere(filterObject, updateFunction);
          } else {
            this.chain().find(filterObject).update(updateFunction);
          }
        };
        Collection.prototype.findAndRemove = function(filterObject) {
          this.chain().find(filterObject).remove();
        };
        Collection.prototype.insert = function(doc, overrideAdaptiveIndices) {
          if (!Array.isArray(doc)) {
            return this.insertOne(doc);
          }
          var obj;
          var results = [];
          var adaptiveBatchOverride = overrideAdaptiveIndices && !this.cloneObjects && this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;
          if (adaptiveBatchOverride) {
            this.adaptiveBinaryIndices = false;
          }
          try {
            this.emit("pre-insert", doc);
            for (var i = 0, len = doc.length; i < len; i++) {
              obj = this.insertOne(doc[i], true);
              if (!obj) {
                return void 0;
              }
              results.push(obj);
            }
          } finally {
            if (adaptiveBatchOverride) {
              this.ensureAllIndexes();
              this.adaptiveBinaryIndices = true;
            }
          }
          this.emit("insert", results);
          results = this.cloneObjects ? clone(results, this.cloneMethod) : results;
          return results.length === 1 ? results[0] : results;
        };
        Collection.prototype.insertOne = function(doc, bulkInsert) {
          var err = null;
          var returnObj;
          if (typeof doc !== "object") {
            err = new TypeError("Document needs to be an object");
          } else if (doc === null) {
            err = new TypeError("Object cannot be null");
          }
          if (err !== null) {
            this.emit("error", err);
            throw err;
          }
          var obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;
          if (!this.disableFreeze) {
            obj = unFreeze(obj);
          }
          if (!this.disableMeta) {
            if (typeof obj.meta === "undefined") {
              obj.meta = {
                revision: 0,
                created: 0
              };
            } else if (!this.disableFreeze) {
              obj.meta = unFreeze(obj.meta);
            }
          }
          if (!bulkInsert) {
            this.emit("pre-insert", obj);
          }
          if (!this.add(obj)) {
            return void 0;
          }
          if (!this.disableFreeze) {
            deepFreeze(obj);
          }
          returnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;
          if (!bulkInsert) {
            this.emit("insert", returnObj);
          }
          this.addAutoUpdateObserver(returnObj);
          return returnObj;
        };
        Collection.prototype.clear = function(options) {
          var self2 = this;
          options = options || {};
          this.data = [];
          this.idIndex = null;
          this.cachedIndex = null;
          this.cachedBinaryIndex = null;
          this.cachedData = null;
          this.maxId = 0;
          this.DynamicViews = [];
          this.dirty = true;
          this.constraints = {
            unique: {},
            exact: {}
          };
          if (options.removeIndices === true) {
            this.binaryIndices = {};
            this.uniqueNames = [];
          } else {
            var keys = Object.keys(this.binaryIndices);
            keys.forEach(function(biname) {
              self2.binaryIndices[biname].dirty = false;
              self2.binaryIndices[biname].values = [];
            });
          }
        };
        Collection.prototype.update = function(doc) {
          var adaptiveBatchOverride, k, len;
          if (Array.isArray(doc)) {
            len = doc.length;
            adaptiveBatchOverride = !this.cloneObjects && this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;
            if (adaptiveBatchOverride) {
              this.adaptiveBinaryIndices = false;
            }
            try {
              for (k = 0; k < len; k += 1) {
                this.update(doc[k]);
              }
            } finally {
              if (adaptiveBatchOverride) {
                this.ensureAllIndexes();
                this.adaptiveBinaryIndices = true;
              }
            }
            return;
          }
          if (!hasOwnProperty.call(doc, "$loki")) {
            throw new Error("Trying to update unsynced document. Please save the document first by using insert() or addMany()");
          }
          try {
            this.startTransaction();
            var arr = this.get(doc.$loki, true), oldInternal, newInternal, position, self2 = this;
            if (!arr) {
              throw new Error("Trying to update a document not in collection.");
            }
            oldInternal = arr[0];
            position = arr[1];
            newInternal = this.cloneObjects || !this.disableDeltaChangesApi && this.disableFreeze ? clone(doc, this.cloneMethod) : doc;
            this.emit("pre-update", doc);
            this.uniqueNames.forEach(function(key2) {
              self2.getUniqueIndex(key2, true).update(oldInternal, newInternal);
            });
            this.data[position] = newInternal;
            if (newInternal !== doc) {
              this.addAutoUpdateObserver(doc);
            }
            for (var idx = 0; idx < this.DynamicViews.length; idx++) {
              this.DynamicViews[idx].evaluateDocument(position, false);
            }
            var key;
            if (this.adaptiveBinaryIndices) {
              var bIndices = this.binaryIndices;
              for (key in bIndices) {
                this.adaptiveBinaryIndexUpdate(position, key);
              }
            } else {
              this.flagBinaryIndexesDirty();
            }
            this.idIndex[position] = newInternal.$loki;
            if (this.isIncremental) {
              this.dirtyIds.push(newInternal.$loki);
            }
            this.commit();
            this.dirty = true;
            if (!this.disableFreeze) {
              deepFreeze(newInternal);
            }
            var returnObj;
            if (this.cloneObjects) {
              returnObj = clone(newInternal, this.cloneMethod);
            } else {
              returnObj = newInternal;
            }
            this.emit("update", returnObj, oldInternal);
            return returnObj;
          } catch (err) {
            this.rollback();
            this.lokiConsoleWrapper.error(err.message);
            this.emit("error", err);
            throw err;
          }
        };
        Collection.prototype.add = function(obj) {
          if ("object" !== typeof obj) {
            throw new TypeError("Object being added needs to be an object");
          }
          if (typeof obj.$loki !== "undefined") {
            throw new Error("Document is already in collection, please use update()");
          }
          try {
            this.startTransaction();
            this.maxId++;
            if (isNaN(this.maxId)) {
              this.maxId = this.data[this.data.length - 1].$loki + 1;
            }
            var newId = this.maxId;
            obj.$loki = newId;
            if (!this.disableMeta) {
              obj.meta.version = 0;
            }
            for (var i = 0, len = this.uniqueNames.length; i < len; i++) {
              this.getUniqueIndex(this.uniqueNames[i], true).set(obj);
            }
            if (this.idIndex) {
              this.idIndex.push(newId);
            }
            if (this.isIncremental) {
              this.dirtyIds.push(newId);
            }
            this.data.push(obj);
            var addedPos = this.data.length - 1;
            var dvlen = this.DynamicViews.length;
            for (i = 0; i < dvlen; i++) {
              this.DynamicViews[i].evaluateDocument(addedPos, true);
            }
            if (this.adaptiveBinaryIndices) {
              var bIndices = this.binaryIndices;
              for (var key in bIndices) {
                this.adaptiveBinaryIndexInsert(addedPos, key);
              }
            } else {
              this.flagBinaryIndexesDirty();
            }
            this.commit();
            this.dirty = true;
            return this.cloneObjects ? clone(obj, this.cloneMethod) : obj;
          } catch (err) {
            this.rollback();
            this.lokiConsoleWrapper.error(err.message);
            this.emit("error", err);
            throw err;
          }
        };
        Collection.prototype.updateWhere = function(filterFunction, updateFunction) {
          var results = this.where(filterFunction), i = 0, obj;
          try {
            for (i; i < results.length; i++) {
              obj = updateFunction(results[i]);
              this.update(obj);
            }
          } catch (err) {
            this.rollback();
            this.lokiConsoleWrapper.error(err.message);
          }
        };
        Collection.prototype.removeWhere = function(query) {
          var list;
          if (typeof query === "function") {
            list = this.data.filter(query);
            this.remove(list);
          } else {
            this.chain().find(query).remove();
          }
        };
        Collection.prototype.removeDataOnly = function() {
          this.remove(this.data.slice());
        };
        Collection.prototype.removeBatchByPositions = function(positions) {
          var len = positions.length;
          var xo = {};
          var dlen, didx, idx;
          var bic = Object.keys(this.binaryIndices).length;
          var uic = Object.keys(this.constraints.unique).length;
          var adaptiveOverride = this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;
          var doc, self2 = this;
          try {
            this.startTransaction();
            this.ensureId();
            for (idx = 0; idx < len; idx++) {
              xo[this.idIndex[positions[idx]]] = true;
            }
            dlen = this.DynamicViews.length;
            if (dlen > 0 || bic > 0 || uic > 0) {
              if (dlen > 0) {
                for (didx = 0; didx < dlen; didx++) {
                  this.DynamicViews[didx].removeDocument(positions);
                }
              }
              if (this.adaptiveBinaryIndices && !adaptiveOverride) {
                var key, bIndices = this.binaryIndices;
                for (key in bIndices) {
                  this.adaptiveBinaryIndexRemove(positions, key);
                }
              } else {
                this.flagBinaryIndexesDirty();
              }
              if (uic) {
                this.uniqueNames.forEach(function(key2) {
                  var index = self2.getUniqueIndex(key2);
                  if (index) {
                    for (idx = 0; idx < len; idx++) {
                      doc = self2.data[positions[idx]];
                      if (doc[key2] !== null && doc[key2] !== void 0) {
                        index.remove(doc[key2]);
                      }
                    }
                  }
                });
              }
            }
            if (!this.disableChangesApi || this.events.delete.length > 1) {
              for (idx = 0; idx < len; idx++) {
                this.emit("delete", this.data[positions[idx]]);
              }
            }
            this.data = this.data.filter(function(obj) {
              return !xo[obj.$loki];
            });
            if (this.isIncremental) {
              for (idx = 0; idx < len; idx++) {
                this.dirtyIds.push(this.idIndex[positions[idx]]);
              }
            }
            this.idIndex = this.idIndex.filter(function(id) {
              return !xo[id];
            });
            if (this.adaptiveBinaryIndices && adaptiveOverride) {
              this.adaptiveBinaryIndices = false;
              this.ensureAllIndexes(true);
              this.adaptiveBinaryIndices = true;
            }
            this.commit();
            this.dirty = true;
          } catch (err) {
            this.rollback();
            if (adaptiveOverride) {
              this.adaptiveBinaryIndices = true;
            }
            this.lokiConsoleWrapper.error(err.message);
            this.emit("error", err);
            return null;
          }
        };
        Collection.prototype.removeBatch = function(batch) {
          var len = batch.length, dlen = this.data.length, idx;
          var xlt = {};
          var posx = [];
          for (idx = 0; idx < dlen; idx++) {
            xlt[this.data[idx].$loki] = idx;
          }
          for (idx = 0; idx < len; idx++) {
            if (typeof batch[idx] === "object") {
              posx.push(xlt[batch[idx].$loki]);
            } else {
              posx.push(xlt[batch[idx]]);
            }
          }
          this.removeBatchByPositions(posx);
        };
        Collection.prototype.remove = function(doc) {
          var frozen;
          if (typeof doc === "number") {
            doc = this.get(doc);
          }
          if ("object" !== typeof doc) {
            throw new Error("Parameter is not an object");
          }
          if (Array.isArray(doc)) {
            this.removeBatch(doc);
            return;
          }
          if (!hasOwnProperty.call(doc, "$loki")) {
            throw new Error("Object is not a document stored in the collection");
          }
          try {
            this.startTransaction();
            var arr = this.get(doc.$loki, true), position = arr[1];
            var self2 = this;
            this.uniqueNames.forEach(function(key2) {
              if (doc[key2] !== null && typeof doc[key2] !== "undefined") {
                var index = self2.getUniqueIndex(key2);
                if (index) {
                  index.remove(doc[key2]);
                }
              }
            });
            for (var idx = 0; idx < this.DynamicViews.length; idx++) {
              this.DynamicViews[idx].removeDocument(position);
            }
            if (this.adaptiveBinaryIndices) {
              var key, bIndices = this.binaryIndices;
              for (key in bIndices) {
                this.adaptiveBinaryIndexRemove(position, key);
              }
            } else {
              this.flagBinaryIndexesDirty();
            }
            this.data.splice(position, 1);
            this.removeAutoUpdateObserver(doc);
            this.idIndex.splice(position, 1);
            if (this.isIncremental) {
              this.dirtyIds.push(doc.$loki);
            }
            this.commit();
            this.dirty = true;
            this.emit("delete", arr[0]);
            if (!this.disableFreeze) {
              doc = unFreeze(doc);
            }
            delete doc.$loki;
            delete doc.meta;
            if (!this.disableFreeze) {
              freeze(doc);
            }
            return doc;
          } catch (err) {
            this.rollback();
            this.lokiConsoleWrapper.error(err.message);
            this.emit("error", err);
            return null;
          }
        };
        Collection.prototype.get = function(id, returnPosition) {
          if (!this.idIndex) {
            this.ensureId();
          }
          var retpos = returnPosition || false, data = this.idIndex, max = data.length - 1, min = 0, mid = min + max >> 1;
          id = typeof id === "number" ? id : parseInt(id, 10);
          if (isNaN(id)) {
            throw new TypeError("Passed id is not an integer");
          }
          while (data[min] < data[max]) {
            mid = min + max >> 1;
            if (data[mid] < id) {
              min = mid + 1;
            } else {
              max = mid;
            }
          }
          if (max === min && data[min] === id) {
            if (retpos) {
              return [this.data[min], min];
            }
            return this.data[min];
          }
          return null;
        };
        Collection.prototype.getBinaryIndexPosition = function(dataPosition, binaryIndexName) {
          var val = Utils.getIn(this.data[dataPosition], binaryIndexName, true);
          var index = this.binaryIndices[binaryIndexName].values;
          var range = this.calculateRange("$eq", binaryIndexName, val);
          if (range[0] === 0 && range[1] === -1) {
            return null;
          }
          var min = range[0];
          var max = range[1];
          for (var idx = min; idx <= max; idx++) {
            if (index[idx] === dataPosition) return idx;
          }
          return null;
        };
        Collection.prototype.adaptiveBinaryIndexInsert = function(dataPosition, binaryIndexName) {
          var usingDotNotation = binaryIndexName.indexOf(".") !== -1;
          var index = this.binaryIndices[binaryIndexName].values;
          var val = Utils.getIn(this.data[dataPosition], binaryIndexName, usingDotNotation);
          if (this.serializableIndices === true && val instanceof Date) {
            this.data[dataPosition][binaryIndexName] = val.getTime();
            val = Utils.getIn(this.data[dataPosition], binaryIndexName);
          }
          var idxPos = index.length === 0 ? 0 : this.calculateRangeStart(binaryIndexName, val, true, usingDotNotation);
          this.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);
        };
        Collection.prototype.adaptiveBinaryIndexUpdate = function(dataPosition, binaryIndexName) {
          var idxPos, index = this.binaryIndices[binaryIndexName].values, len = index.length;
          for (idxPos = 0; idxPos < len; idxPos++) {
            if (index[idxPos] === dataPosition) break;
          }
          this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);
          this.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);
        };
        Collection.prototype.adaptiveBinaryIndexRemove = function(dataPosition, binaryIndexName, removedFromIndexOnly) {
          var bi = this.binaryIndices[binaryIndexName];
          var len, idx, rmidx, rmlen, rxo = {};
          var curr, shift, idxPos;
          if (Array.isArray(dataPosition)) {
            rmlen = dataPosition.length;
            if (rmlen === 1) {
              dataPosition = dataPosition[0];
            } else {
              for (rmidx = 0; rmidx < rmlen; rmidx++) {
                rxo[dataPosition[rmidx]] = true;
              }
              bi.values = bi.values.filter(function(di) {
                return !rxo[di];
              });
              if (removedFromIndexOnly === true) {
                return;
              }
              var sortedPositions = dataPosition.slice();
              sortedPositions.sort(function(a, b) {
                return a - b;
              });
              len = bi.values.length;
              for (idx = 0; idx < len; idx++) {
                curr = bi.values[idx];
                shift = 0;
                for (rmidx = 0; rmidx < rmlen && curr > sortedPositions[rmidx]; rmidx++) {
                  shift++;
                }
                bi.values[idx] -= shift;
              }
              return;
            }
          }
          idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);
          if (idxPos === null) {
            return null;
          }
          bi.values.splice(idxPos, 1);
          if (removedFromIndexOnly === true) {
            return;
          }
          len = bi.values.length;
          for (idx = 0; idx < len; idx++) {
            if (bi.values[idx] > dataPosition) {
              bi.values[idx]--;
            }
          }
        };
        Collection.prototype.calculateRangeStart = function(prop, val, adaptive, usingDotNotation) {
          var rcd = this.data;
          var index = this.binaryIndices[prop].values;
          var min = 0;
          var max = index.length - 1;
          var mid = 0;
          if (index.length === 0) {
            return -1;
          }
          var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);
          var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);
          while (min < max) {
            mid = min + max >> 1;
            if (Comparators.lt(Utils.getIn(rcd[index[mid]], prop, usingDotNotation), val, false)) {
              min = mid + 1;
            } else {
              max = mid;
            }
          }
          var lbound = min;
          if (Comparators.aeq(val, Utils.getIn(rcd[index[lbound]], prop, usingDotNotation))) {
            return lbound;
          }
          if (Comparators.lt(val, Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), false)) {
            return adaptive ? lbound : lbound - 1;
          }
          return adaptive ? lbound + 1 : lbound;
        };
        Collection.prototype.calculateRangeEnd = function(prop, val, usingDotNotation) {
          var rcd = this.data;
          var index = this.binaryIndices[prop].values;
          var min = 0;
          var max = index.length - 1;
          var mid = 0;
          if (index.length === 0) {
            return -1;
          }
          var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);
          var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);
          while (min < max) {
            mid = min + max >> 1;
            if (Comparators.lt(val, Utils.getIn(rcd[index[mid]], prop, usingDotNotation), false)) {
              max = mid;
            } else {
              min = mid + 1;
            }
          }
          var ubound = max;
          if (Comparators.aeq(val, Utils.getIn(rcd[index[ubound]], prop, usingDotNotation))) {
            return ubound;
          }
          if (Comparators.gt(val, Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), false)) {
            return ubound + 1;
          }
          if (Comparators.aeq(val, Utils.getIn(rcd[index[ubound - 1]], prop, usingDotNotation))) {
            return ubound - 1;
          }
          return ubound;
        };
        Collection.prototype.calculateRange = function(op, prop, val) {
          var rcd = this.data;
          var index = this.binaryIndices[prop].values;
          var min = 0;
          var max = index.length - 1;
          var mid = 0;
          var lbound, lval;
          var ubound, uval;
          if (rcd.length === 0) {
            return [0, -1];
          }
          var usingDotNotation = prop.indexOf(".") !== -1;
          var minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);
          var maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);
          switch (op) {
            case "$eq":
            case "$aeq":
              if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {
                return [0, -1];
              }
              break;
            case "$dteq":
              if (Comparators.lt(val, minVal, false) || Comparators.gt(val, maxVal, false)) {
                return [0, -1];
              }
              break;
            case "$gt":
              if (Comparators.gt(val, maxVal, true)) {
                return [0, -1];
              }
              if (Comparators.gt(minVal, val, false)) {
                return [min, max];
              }
              break;
            case "$gte":
              if (Comparators.gt(val, maxVal, false)) {
                return [0, -1];
              }
              if (Comparators.gt(minVal, val, true)) {
                return [min, max];
              }
              break;
            case "$lt":
              if (Comparators.lt(val, minVal, true)) {
                return [0, -1];
              }
              if (Comparators.lt(maxVal, val, false)) {
                return [min, max];
              }
              break;
            case "$lte":
              if (Comparators.lt(val, minVal, false)) {
                return [0, -1];
              }
              if (Comparators.lt(maxVal, val, true)) {
                return [min, max];
              }
              break;
            case "$between":
              if (Comparators.gt(val[0], maxVal, false)) {
                return [0, -1];
              }
              if (Comparators.lt(val[1], minVal, false)) {
                return [0, -1];
              }
              lbound = this.calculateRangeStart(prop, val[0], false, usingDotNotation);
              ubound = this.calculateRangeEnd(prop, val[1], usingDotNotation);
              if (lbound < 0) lbound++;
              if (ubound > max) ubound--;
              if (!Comparators.gt(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val[0], true)) lbound++;
              if (!Comparators.lt(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val[1], true)) ubound--;
              if (ubound < lbound) return [0, -1];
              return [lbound, ubound];
            case "$in":
              var idxset = [], segResult = [];
              for (var j = 0, len = val.length; j < len; j++) {
                var seg = this.calculateRange("$eq", prop, val[j]);
                for (var i = seg[0]; i <= seg[1]; i++) {
                  if (idxset[i] === void 0) {
                    idxset[i] = true;
                    segResult.push(i);
                  }
                }
              }
              return segResult;
          }
          switch (op) {
            case "$eq":
            case "$aeq":
            case "$dteq":
            case "$gte":
            case "$lt":
              lbound = this.calculateRangeStart(prop, val, false, usingDotNotation);
              lval = Utils.getIn(rcd[index[lbound]], prop, usingDotNotation);
              break;
            default:
              break;
          }
          switch (op) {
            case "$eq":
            case "$aeq":
            case "$dteq":
            case "$lte":
            case "$gt":
              ubound = this.calculateRangeEnd(prop, val, usingDotNotation);
              uval = Utils.getIn(rcd[index[ubound]], prop, usingDotNotation);
              break;
            default:
              break;
          }
          switch (op) {
            case "$eq":
            case "$aeq":
            case "$dteq":
              if (!Comparators.aeq(lval, val)) {
                return [0, -1];
              }
              return [lbound, ubound];
            case "$gt":
              if (!Comparators.aeq(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val)) {
                return [ubound, max];
              }
              return [ubound + 1, max];
            case "$gte":
              if (!Comparators.aeq(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val)) {
                return [lbound + 1, max];
              }
              return [lbound, max];
            case "$lt":
              if (!Comparators.aeq(Utils.getIn(rcd[index[lbound]], prop, usingDotNotation), val)) {
                return [min, lbound];
              }
              return [min, lbound - 1];
            case "$lte":
              if (!Comparators.aeq(Utils.getIn(rcd[index[ubound]], prop, usingDotNotation), val)) {
                return [min, ubound - 1];
              }
              return [min, ubound];
            default:
              return [0, rcd.length - 1];
          }
        };
        Collection.prototype.by = function(field, value) {
          var self2;
          if (value === void 0) {
            self2 = this;
            return function(value2) {
              return self2.by(field, value2);
            };
          }
          var result = this.getUniqueIndex(field, true).get(value);
          if (!this.cloneObjects) {
            return result;
          } else {
            return clone(result, this.cloneMethod);
          }
        };
        Collection.prototype.findOne = function(query) {
          query = query || {};
          var result = this.chain().find(query, true).data();
          if (Array.isArray(result) && result.length === 0) {
            return null;
          } else {
            if (!this.cloneObjects) {
              return result[0];
            } else {
              return clone(result[0], this.cloneMethod);
            }
          }
        };
        Collection.prototype.chain = function(transform, parameters) {
          var rs = new Resultset(this);
          if (typeof transform === "undefined") {
            return rs;
          }
          return rs.transform(transform, parameters);
        };
        Collection.prototype.find = function(query) {
          return this.chain().find(query).data();
        };
        Collection.prototype.findOneUnindexed = function(prop, value) {
          var i = this.data.length, doc;
          while (i--) {
            if (Utils.getIn(this.data[i], prop, true) === value) {
              doc = this.data[i];
              return doc;
            }
          }
          return null;
        };
        Collection.prototype.startTransaction = function() {
        };
        Collection.prototype.commit = function() {
        };
        Collection.prototype.rollback = function() {
        };
        Collection.prototype.where = function(fun) {
          return this.chain().where(fun).data();
        };
        function UniqueIndex(uniqueField) {
          this.field = uniqueField;
          this.keyMap = /* @__PURE__ */ Object.create(null);
          this.lokiMap = /* @__PURE__ */ Object.create(null);
        }
        UniqueIndex.prototype.keyMap = {};
        UniqueIndex.prototype.lokiMap = {};
        UniqueIndex.prototype.set = function(obj) {
          var fieldValue = obj[this.field];
          if (fieldValue !== null && typeof fieldValue !== "undefined") {
            if (this.keyMap[fieldValue]) {
              throw new Error("Duplicate key for property " + this.field + ": " + fieldValue);
            } else {
              this.keyMap[fieldValue] = obj;
              this.lokiMap[obj.$loki] = fieldValue;
            }
          }
        };
        UniqueIndex.prototype.get = function(key) {
          return this.keyMap[key];
        };
        UniqueIndex.prototype.byId = function(id) {
          return this.keyMap[this.lokiMap[id]];
        };
        UniqueIndex.prototype.update = function(obj, doc) {
          if (this.lokiMap[obj.$loki] !== doc[this.field]) {
            var old = this.lokiMap[obj.$loki];
            this.set(doc);
            this.keyMap[old] = void 0;
          } else {
            this.keyMap[obj[this.field]] = doc;
          }
        };
        UniqueIndex.prototype.remove = function(key) {
          var obj = this.keyMap[key];
          if (obj !== null && typeof obj !== "undefined") {
            this.keyMap[key] = void 0;
            this.lokiMap[obj.$loki] = void 0;
          } else {
            throw new Error("Key is not in unique index: " + this.field);
          }
        };
        UniqueIndex.prototype.clear = function() {
          this.keyMap = /* @__PURE__ */ Object.create(null);
          this.lokiMap = /* @__PURE__ */ Object.create(null);
        };
        Loki.deepFreeze = deepFreeze;
        Loki.freeze = freeze;
        Loki.unFreeze = unFreeze;
        Loki.LokiOps = LokiOps;
        Loki.Collection = Collection;
        Loki.Resultset = Resultset;
        Loki.LokiMemoryAdapter = LokiMemoryAdapter;
        Loki.aeq = aeqHelper;
        Loki.lt = ltHelper;
        Loki.gt = gtHelper;
        Loki.Comparators = Comparators;
        return Loki;
      })();
    });
  }
});

// node_modules/@nozbe/watermelondb/adapters/lokijs/worker/lokiExtensions.js
var require_lokiExtensions = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/lokijs/worker/lokiExtensions.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.deleteDatabase = deleteDatabase;
    exports.lokiFatalError = lokiFatalError;
    exports.newLoki = newLoki;
    var _extends2 = _interopRequireDefault(require_extends());
    var _logger = _interopRequireDefault(require_logger());
    var isIDBAvailable = function(onQuotaExceededError) {
      return new Promise(function(resolve) {
        if ("undefined" === typeof indexedDB) {
          resolve(false);
        }
        var checkRequest = indexedDB.open("WatermelonIDBChecker");
        checkRequest.onsuccess = function(e) {
          var db = e.target.result;
          db.close();
          resolve(true);
        };
        checkRequest.onerror = function(event) {
          var _event$target;
          var error = null === event || void 0 === event ? void 0 : null === (_event$target = event.target) || void 0 === _event$target ? void 0 : _event$target.error;
          _logger.default.error("[Loki] IndexedDB checker failed to open. Most likely, user is in Private Mode. It could also be a quota exceeded error. Will fall back to in-memory database.", event, error);
          if (error && "QuotaExceededError" === error.name) {
            _logger.default.log("[Loki] Looks like disk quota was exceeded: ", error);
            onQuotaExceededError && onQuotaExceededError(error);
          }
          resolve(false);
        };
        checkRequest.onblocked = function() {
          _logger.default.error("IndexedDB checker call is blocked");
        };
      });
    };
    function getLokiAdapter(options) {
      return new Promise(function($return, $error) {
        var useIncrementalIndexedDB, adapter, onQuotaExceededError, dbName, extraIncrementalIDBOptions, IncrementalIDBAdapter, LokiIndexedAdapter, LokiMemoryAdapter;
        ({
          useIncrementalIndexedDB,
          _testLokiAdapter: adapter,
          onQuotaExceededError,
          dbName,
          extraIncrementalIDBOptions = {}
        } = options);
        if (adapter) {
          return $return(adapter);
        } else {
          return Promise.resolve(isIDBAvailable(onQuotaExceededError)).then((function($await_3) {
            try {
              if ($await_3) {
                if (useIncrementalIndexedDB) {
                  IncrementalIDBAdapter = options._betaLoki ? require_incremental_indexeddb_adapter() : require_incremental_indexeddb_adapter();
                  return $return(new IncrementalIDBAdapter(extraIncrementalIDBOptions));
                }
                LokiIndexedAdapter = require_loki_indexed_adapter();
                return $return(new LokiIndexedAdapter(dbName));
              }
              return $If_2.call(this);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }).bind(this), $error);
        }
        function $If_2() {
          ({
            LokiMemoryAdapter
          } = options._betaLoki ? require_lokijs_wmelon() : require_lokijs_wmelon());
          return $return(new LokiMemoryAdapter());
        }
        return $If_2.call(this);
      });
    }
    function newLoki(options) {
      return new Promise(function($return, $error) {
        var extraLokiOptions, LokiDb, loki;
        ({
          extraLokiOptions = {}
        } = options);
        LokiDb = options._betaLoki ? require_lokijs_wmelon() : require_lokijs_wmelon();
        return Promise.resolve(getLokiAdapter(options)).then(function($await_4) {
          try {
            loki = new LokiDb(options.dbName, (0, _extends2.default)({
              adapter: $await_4,
              autosave: true,
              autosaveInterval: 500,
              verbose: true
            }, extraLokiOptions));
            return Promise.resolve(new Promise(function(resolve, reject) {
              loki.loadDatabase({}, function(error) {
                error ? reject(error) : resolve();
              });
            })).then(function($await_5) {
              try {
                return $return(loki);
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }, $error);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }, $error);
      });
    }
    function deleteDatabase(loki) {
      return new Promise(function($return, $error) {
        return Promise.resolve(new Promise(function(resolve, reject) {
          loki.close(function() {
            loki.deleteDatabase({}, function(response) {
              if (response && response.success || response === void 0) {
                resolve();
              } else {
                reject(response);
              }
            });
          });
        })).then(function($await_6) {
          try {
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }, $error);
      });
    }
    function lokiFatalError(loki) {
      try {
        var fatalHandler = function fatalHandler2() {
          throw new Error("Illegal attempt to save Loki database after a fatal error");
        };
        loki.save = fatalHandler;
        loki.saveDatabase = fatalHandler;
        loki.saveDatabaseInternal = fatalHandler;
        loki.autosave = false;
        loki.autosaveDisable();
        loki.close();
      } catch (error) {
        _logger.default.error("Failed to perform loki fatal error");
        _logger.default.error(error);
      }
    }
  }
});

// node_modules/@nozbe/watermelondb/adapters/lokijs/worker/encodeQuery/index.js
var require_encodeQuery = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/lokijs/worker/encodeQuery/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = encodeQuery;
    var _invariant = _interopRequireDefault(require_invariant());
    var _likeToRegexp = _interopRequireDefault(require_likeToRegexp());
    var weakNotNull = {
      $not: {
        $aeq: null
      }
    };
    var encodeComparison = function(comparison, value) {
      var {
        operator
      } = comparison;
      if (comparison.right.column) {
        switch (operator) {
          case "eq":
            return {
              $$aeq: value
            };
          case "notEq":
            return {
              $not: {
                $$aeq: value
              }
            };
          case "gt":
            return {
              $$gt: value
            };
          case "gte":
            return {
              $$gte: value
            };
          case "weakGt":
            return {
              $$gt: value
            };
          case "lt":
            return {
              $and: [{
                $$lt: value
              }, weakNotNull]
            };
          case "lte":
            return {
              $and: [{
                $$lte: value
              }, weakNotNull]
            };
          default:
            throw new Error("Illegal operator ".concat(operator, " for column comparisons"));
        }
      } else {
        switch (operator) {
          case "eq":
            return {
              $aeq: value
            };
          case "notEq":
            return {
              $not: {
                $aeq: value
              }
            };
          case "gt":
            return {
              $gt: value
            };
          case "gte":
            return {
              $gte: value
            };
          case "weakGt":
            return {
              $gt: value
            };
          // Note: yup, this is correct (for non-column comparisons)
          case "lt":
            return {
              $and: [{
                $lt: value
              }, weakNotNull]
            };
          case "lte":
            return {
              $and: [{
                $lte: value
              }, weakNotNull]
            };
          case "oneOf":
            return {
              $in: value
            };
          case "notIn":
            return {
              $and: [{
                $nin: value
              }, weakNotNull]
            };
          case "between":
            return {
              $between: value
            };
          case "like":
            return {
              $regex: (0, _likeToRegexp.default)(value)
            };
          case "notLike":
            return {
              $and: [{
                $not: {
                  $eq: null
                }
              }, {
                $not: {
                  $regex: (0, _likeToRegexp.default)(value)
                }
              }]
            };
          case "includes":
            return {
              $containsString: value
            };
          default:
            throw new Error("Unknown operator ".concat(operator));
        }
      }
    };
    var columnCompRequiresColumnNotNull = {
      gt: true,
      gte: true,
      lt: true,
      lte: true
    };
    var encodeWhereDescription = function({
      left,
      comparison
    }) {
      var _ref5;
      var {
        operator,
        right
      } = comparison;
      var col = left;
      var comparisonRight = right.column || right.values || right.value;
      if ("string" === typeof right.value) {
        if ("eq" === operator) {
          var _ref;
          return _ref = {}, _ref[col] = {
            $eq: comparisonRight
          }, _ref;
        } else if ("notEq" === operator) {
          var _ref2;
          return _ref2 = {}, _ref2[col] = {
            $ne: comparisonRight
          }, _ref2;
        }
      }
      var colName = right.column;
      var encodedComparison = encodeComparison(comparison, comparisonRight);
      if (colName && columnCompRequiresColumnNotNull[operator]) {
        var _ref3, _ref4;
        return {
          $and: [(_ref3 = {}, _ref3[col] = encodedComparison, _ref3), (_ref4 = {}, _ref4[colName] = weakNotNull, _ref4)]
        };
      }
      return _ref5 = {}, _ref5[col] = encodedComparison, _ref5;
    };
    var encodeCondition = function(associations) {
      return function(clause) {
        switch (clause.type) {
          case "and":
            return encodeAnd(associations, clause);
          case "or":
            return encodeOr(associations, clause);
          case "where":
            return encodeWhereDescription(clause);
          case "on":
            return encodeJoin(associations, clause);
          case "loki":
            return clause.expr;
          default:
            throw new Error("Unknown clause ".concat(clause.type));
        }
      };
    };
    var encodeConditions = function(associations, conditions) {
      return conditions.map(encodeCondition(associations));
    };
    var encodeAndOr = function(op) {
      return function(associations, clause) {
        var _ref6;
        var conditions = encodeConditions(associations, clause.conditions);
        return 1 === conditions.length ? conditions[0] : (_ref6 = {}, _ref6[op] = conditions, _ref6);
      };
    };
    var encodeAnd = encodeAndOr("$and");
    var encodeOr = encodeAndOr("$or");
    var concatRawQueries = function(queries) {
      switch (queries.length) {
        case 0:
          return void 0;
        case 1:
          return queries[0];
        default:
          return {
            $and: queries
          };
      }
    };
    var encodeRootConditions = function(associations, conditions) {
      return concatRawQueries(encodeConditions(associations, conditions));
    };
    var encodeJoin = function(associations, on) {
      var {
        table,
        conditions
      } = on;
      var association = associations.find(function({
        to
      }) {
        return table === to;
      });
      (0, _invariant.default)(association, "To nest Q.on inside Q.and/Q.or you must explicitly declare Q.experimentalJoinTables at the beginning of the query");
      var {
        info
      } = association;
      return {
        $join: {
          table,
          query: encodeRootConditions(associations, conditions),
          mapKey: "belongs_to" === info.type ? "id" : info.foreignKey,
          joinKey: "belongs_to" === info.type ? info.key : "id"
        }
      };
    };
    function encodeQuery(query) {
      var {
        table,
        description: {
          where,
          joinTables,
          sql
        },
        associations
      } = query;
      (0, _invariant.default)(!sql, "[Loki] Q.unsafeSqlQuery are not supported with LokiJSAdapter");
      return {
        table,
        query: encodeRootConditions(associations, where),
        hasJoins: !!joinTables.length
      };
    }
  }
});

// node_modules/@nozbe/watermelondb/adapters/lokijs/worker/performJoins/index.js
var require_performJoins = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/lokijs/worker/performJoins/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = performJoins;
    function performJoinsImpl(query, performer) {
      if (!query) {
        return query;
      } else if (query.$join) {
        var _ref;
        var _join = query.$join;
        var joinQuery = performJoinsImpl(_join.query, performer);
        _join.query = joinQuery;
        var records = performer(_join);
        var matchingIds = records.map(function(record) {
          return record[_join.mapKey];
        });
        return _ref = {}, _ref[_join.joinKey] = {
          $in: matchingIds
        }, _ref;
      } else if (query.$and) {
        return {
          $and: query.$and.map(function(clause) {
            return performJoinsImpl(clause, performer);
          })
        };
      } else if (query.$or) {
        return {
          $or: query.$or.map(function(clause) {
            return performJoinsImpl(clause, performer);
          })
        };
      }
      return query;
    }
    function performJoins(lokiQuery, performer) {
      var {
        query,
        hasJoins
      } = lokiQuery;
      if (!hasJoins) {
        return query;
      }
      return performJoinsImpl(query, performer);
    }
  }
});

// node_modules/@nozbe/watermelondb/adapters/lokijs/worker/executeQuery.js
var require_executeQuery = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/lokijs/worker/executeQuery.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.executeCount = executeCount;
    exports.executeQuery = executeQuery;
    var _encodeQuery = _interopRequireDefault(require_encodeQuery());
    var _performJoins = _interopRequireDefault(require_performJoins());
    function performJoin(join, loki) {
      var {
        table,
        query
      } = join;
      var collection = loki.getCollection(table).chain();
      var records = collection.find(query).data();
      return records;
    }
    function performQuery(query, loki) {
      var lokiQuery = (0, _encodeQuery.default)(query);
      var mainQuery = (0, _performJoins.default)(lokiQuery, function(join) {
        return performJoin(join, loki);
      });
      var collection = loki.getCollection(query.table).chain();
      var resultset = collection.find(mainQuery);
      var {
        sortBy,
        take,
        skip
      } = query.description;
      if (sortBy.length) {
        resultset = resultset.compoundsort(sortBy.map(function({
          sortColumn,
          sortOrder
        }) {
          return [sortColumn, "desc" === sortOrder];
        }));
      }
      if (skip) {
        resultset = resultset.offset(skip);
      }
      if (take) {
        resultset = resultset.limit(take);
      }
      return resultset;
    }
    function executeQuery(query, loki) {
      var {
        lokiTransform
      } = query.description;
      var results = performQuery(query, loki).data();
      if (lokiTransform) {
        return lokiTransform(results, loki);
      }
      return results;
    }
    function executeCount(query, loki) {
      var {
        lokiTransform
      } = query.description;
      var resultset = performQuery(query, loki);
      if (lokiTransform) {
        var records = lokiTransform(resultset.data(), loki);
        return records.length;
      }
      return resultset.count();
    }
  }
});

// node_modules/@nozbe/watermelondb/adapters/lokijs/worker/DatabaseDriver.js
var require_DatabaseDriver = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/lokijs/worker/DatabaseDriver.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    exports.setExperimentalAllowsFatalError = setExperimentalAllowsFatalError;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _logger = _interopRequireDefault(require_logger());
    var _invariant = _interopRequireDefault(require_invariant());
    var _RawRecord = require_RawRecord();
    var _lokiExtensions = require_lokiExtensions();
    var _executeQuery = require_executeQuery();
    var SCHEMA_VERSION_KEY = "_loki_schema_version";
    var experimentalAllowsFatalError = false;
    function setExperimentalAllowsFatalError() {
      experimentalAllowsFatalError = true;
    }
    var DatabaseDriver = exports.default = (function() {
      function DatabaseDriver2(options) {
        this.cachedRecords = /* @__PURE__ */ new Map();
        this._isBroken = false;
        var {
          schema,
          migrations
        } = options;
        this.options = options;
        this.schema = schema;
        this.migrations = migrations;
      }
      var _proto = DatabaseDriver2.prototype;
      _proto.setUp = function() {
        return new Promise((function($return, $error) {
          return Promise.resolve(this._openDatabase()).then((function() {
            try {
              return Promise.resolve(this._migrateIfNeeded()).then(function() {
                try {
                  return $return();
                } catch ($boundEx) {
                  return $error($boundEx);
                }
              }, $error);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }).bind(this), $error);
        }).bind(this));
      };
      _proto.isCached = function(table, id) {
        var cachedSet = this.cachedRecords.get(table);
        return cachedSet ? cachedSet.has(id) : false;
      };
      _proto.markAsCached = function(table, id) {
        var cachedSet = this.cachedRecords.get(table);
        if (cachedSet) {
          cachedSet.add(id);
        } else {
          this.cachedRecords.set(table, /* @__PURE__ */ new Set([id]));
        }
      };
      _proto.removeFromCache = function(table, id) {
        var cachedSet = this.cachedRecords.get(table);
        if (cachedSet) {
          cachedSet.delete(id);
        }
      };
      _proto.clearCachedRecords = function() {
        this.cachedRecords = /* @__PURE__ */ new Map();
      };
      _proto.getCache = function(table) {
        var cache = this.cachedRecords.get(table);
        if (cache) {
          return cache;
        }
        var newCache = /* @__PURE__ */ new Set([]);
        this.cachedRecords.set(table, newCache);
        return newCache;
      };
      _proto.find = function(table, id) {
        if (this.isCached(table, id)) {
          return id;
        }
        var raw = this.loki.getCollection(table).by("id", id);
        if (!raw) {
          return null;
        }
        this.markAsCached(table, id);
        return (0, _RawRecord.sanitizedRaw)(raw, this.schema.tables[table]);
      };
      _proto.query = function(_query) {
        var records = (0, _executeQuery.executeQuery)(_query, this.loki);
        return this._compactQueryResults(records, _query.table);
      };
      _proto.queryIds = function(query) {
        return (0, _executeQuery.executeQuery)(query, this.loki).map(function(record) {
          return record.id;
        });
      };
      _proto.unsafeQueryRaw = function(query) {
        return (0, _executeQuery.executeQuery)(query, this.loki);
      };
      _proto.count = function(query) {
        return (0, _executeQuery.executeCount)(query, this.loki);
      };
      _proto.batch = function(operations) {
        var _this = this;
        this._assertNotBroken();
        try {
          var recordsToCreate = {};
          operations.forEach(function(operation) {
            var [type, table, raw] = operation;
            switch (type) {
              case "create":
                if (!recordsToCreate[table]) {
                  recordsToCreate[table] = [];
                }
                recordsToCreate[table].push(raw);
                break;
              default:
                break;
            }
          });
          Object.entries(recordsToCreate).forEach(function(args) {
            var [table, raws] = args;
            var shouldRebuildIndexAfterInsert = 1e3 <= raws.length;
            _this.loki.getCollection(table).insert(raws, shouldRebuildIndexAfterInsert);
            var cache = _this.getCache(table);
            raws.forEach(function(raw) {
              cache.add(raw.id);
            });
          });
          operations.forEach(function(operation) {
            var [type, table, rawOrId] = operation;
            var collection = _this.loki.getCollection(table);
            switch (type) {
              case "update":
                var lokiId = collection.by("id", rawOrId.id).$loki;
                var raw = rawOrId;
                raw.$loki = lokiId;
                collection.update(raw);
                break;
              case "markAsDeleted":
                var id = rawOrId;
                var record = collection.by("id", id);
                if (record) {
                  record._status = "deleted";
                  collection.update(record);
                  _this.removeFromCache(table, id);
                }
                break;
              case "destroyPermanently":
                var _id = rawOrId;
                var _record = collection.by("id", _id);
                _record && collection.remove(_record);
                _this.removeFromCache(table, _id);
                break;
              default:
                break;
            }
          });
        } catch (error) {
          this._fatalError(error);
        }
      };
      _proto.getDeletedRecords = function(table) {
        return this.loki.getCollection(table).find({
          _status: {
            $eq: "deleted"
          }
        }).map(function(record) {
          return record.id;
        });
      };
      _proto.unsafeExecute = function(operations) {
        if (true) {
          (0, _invariant.default)(operations && "object" === typeof operations && 1 === Object.keys(operations).length && "function" === typeof operations.loki, "unsafeExecute expects an { loki: loki => { ... } } object");
        }
        var lokiBlock = operations.loki;
        lokiBlock(this.loki);
      };
      _proto.unsafeResetDatabase = function() {
        return new Promise((function($return, $error) {
          return Promise.resolve((0, _lokiExtensions.deleteDatabase)(this.loki)).then((function() {
            try {
              this.cachedRecords.clear();
              _logger.default.log("[Loki] Database is now reset");
              return Promise.resolve(this._openDatabase()).then((function() {
                try {
                  this._setUpSchema();
                  return $return();
                } catch ($boundEx) {
                  return $error($boundEx);
                }
              }).bind(this), $error);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }).bind(this), $error);
        }).bind(this));
      };
      _proto.getLocal = function(key) {
        var record = this._findLocal(key);
        return record ? record.value : null;
      };
      _proto.setLocal = function(key, value) {
        this._assertNotBroken();
        try {
          var record = this._findLocal(key);
          if (record) {
            record.value = value;
            this._localStorage.update(record);
          } else {
            this._localStorage.insert({
              key,
              value
            });
          }
        } catch (error) {
          this._fatalError(error);
        }
      };
      _proto.removeLocal = function(key) {
        this._assertNotBroken();
        try {
          var record = this._findLocal(key);
          if (record) {
            this._localStorage.remove(record);
          }
        } catch (error) {
          this._fatalError(error);
        }
      };
      _proto._openDatabase = function() {
        return new Promise((function($return, $error) {
          _logger.default.log("[Loki] Initializing IndexedDB");
          return Promise.resolve((0, _lokiExtensions.newLoki)(this.options)).then((function($await_13) {
            try {
              this.loki = $await_13;
              _logger.default.log("[Loki] Database loaded");
              return $return();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }).bind(this), $error);
        }).bind(this));
      };
      _proto._setUpSchema = function() {
        var _this2 = this;
        _logger.default.log("[Loki] Setting up schema");
        var tables = Object.values(this.schema.tables);
        tables.forEach(function(tableSchema) {
          _this2._addCollection(tableSchema);
        });
        this.loki.addCollection("local_storage", {
          unique: ["key"],
          indices: [],
          disableMeta: true
        });
        this._databaseVersion = this.schema.version;
        _logger.default.log("[Loki] Database collections set up");
      };
      _proto._addCollection = function(tableSchema) {
        var {
          name,
          columnArray
        } = tableSchema;
        var indexedColumns = columnArray.reduce(function(indexes, column) {
          return column.isIndexed ? indexes.concat([column.name]) : indexes;
        }, []);
        this.loki.addCollection(name, {
          unique: ["id"],
          indices: ["_status"].concat((0, _toConsumableArray2.default)(indexedColumns)),
          disableMeta: true
        });
      };
      _proto._migrateIfNeeded = function() {
        return new Promise((function($return, $error) {
          var dbVersion, schemaVersion, migrationSteps;
          dbVersion = this._databaseVersion;
          schemaVersion = this.schema.version;
          if (dbVersion === schemaVersion) {
            return $If_5.call(this);
          } else {
            let $If_6 = function() {
              return $If_5.call(this);
            };
            if (0 === dbVersion) {
              _logger.default.log("[Loki] Empty database, setting up");
              return Promise.resolve(this.unsafeResetDatabase()).then((function() {
                try {
                  return $If_6.call(this);
                } catch ($boundEx) {
                  return $error($boundEx);
                }
              }).bind(this), $error);
            } else {
              let $If_7 = function() {
                return $If_6.call(this);
              };
              if (0 < dbVersion && dbVersion < schemaVersion) {
                let $If_8 = function() {
                  return $If_7.call(this);
                };
                _logger.default.log("[Loki] Database has old schema version. Migration is required.");
                migrationSteps = this._getMigrationSteps(dbVersion);
                if (migrationSteps) {
                  _logger.default.log("[Loki] Migrating from version ".concat(dbVersion, " to ").concat(this.schema.version, "..."));
                  var $Try_4_Post = (function() {
                    try {
                      return $If_8.call(this);
                    } catch ($boundEx) {
                      return $error($boundEx);
                    }
                  }).bind(this);
                  var $Try_4_Catch = function $Try_4_Catch2(error) {
                    try {
                      _logger.default.error("[Loki] Migration failed", error);
                      throw error;
                    } catch ($boundEx) {
                      return $error($boundEx);
                    }
                  };
                  try {
                    return Promise.resolve(this._migrate(migrationSteps)).then(function() {
                      try {
                        return $Try_4_Post();
                      } catch ($boundEx) {
                        return $Try_4_Catch($boundEx);
                      }
                    }, $Try_4_Catch);
                  } catch (error) {
                    $Try_4_Catch(error);
                  }
                } else {
                  _logger.default.warn("[Loki] Migrations not available for this version range, resetting database instead");
                  return Promise.resolve(this.unsafeResetDatabase()).then((function() {
                    try {
                      return $If_8.call(this);
                    } catch ($boundEx) {
                      return $error($boundEx);
                    }
                  }).bind(this), $error);
                }
              } else {
                _logger.default.warn("[Loki] Database has newer version ".concat(dbVersion, " than app schema ").concat(schemaVersion, ". Resetting database."));
                return Promise.resolve(this.unsafeResetDatabase()).then((function() {
                  try {
                    return $If_7.call(this);
                  } catch ($boundEx) {
                    return $error($boundEx);
                  }
                }).bind(this), $error);
              }
            }
          }
          function $If_5() {
            return $return();
          }
        }).bind(this));
      };
      _proto._getMigrationSteps = function(fromVersion) {
        var {
          migrations
        } = this;
        if (!migrations) {
          return null;
        }
        var {
          stepsForMigration
        } = require_stepsForMigration();
        return stepsForMigration({
          migrations,
          fromVersion,
          toVersion: this.schema.version
        });
      };
      _proto._migrate = function(steps) {
        return new Promise((function($return) {
          var _this3 = this;
          steps.forEach(function(step) {
            if ("create_table" === step.type) {
              _this3._executeCreateTableMigration(step);
            } else if ("add_columns" === step.type) {
              _this3._executeAddColumnsMigration(step);
            } else if (!("sql" === step.type)) {
              throw new Error("Unsupported migration step ".concat(step.type));
            }
          });
          this._databaseVersion = this.schema.version;
          _logger.default.log("[Loki] Migration successful");
          return $return();
        }).bind(this));
      };
      _proto._executeCreateTableMigration = function({
        schema
      }) {
        this._addCollection(schema);
      };
      _proto._executeAddColumnsMigration = function({
        table,
        columns
      }) {
        var collection = this.loki.getCollection(table);
        collection.findAndUpdate({}, function(record) {
          columns.forEach(function(column) {
            (0, _RawRecord.setRawSanitized)(record, column.name, null, column);
          });
        });
        columns.forEach(function(column) {
          if (column.isIndexed) {
            collection.ensureIndex(column.name);
          }
        });
      };
      _proto._compactQueryResults = function(records, table) {
        var _this4 = this;
        var cache = this.getCache(table);
        return records.map(function(raw) {
          var {
            id
          } = raw;
          if (cache.has(id)) {
            return id;
          }
          cache.add(id);
          return (0, _RawRecord.sanitizedRaw)(raw, _this4.schema.tables[table]);
        });
      };
      _proto._findLocal = function(key) {
        var localStorage = this._localStorage;
        return localStorage && localStorage.by("key", key);
      };
      _proto._assertNotBroken = function() {
        if (this._isBroken) {
          throw new Error("DatabaseDriver is in a broken state, bailing...");
        }
      };
      _proto._fatalError = function(error) {
        if (!experimentalAllowsFatalError) {
          _logger.default.warn("DatabaseDriver is broken, but experimentalAllowsFatalError has not been enabled to do anything about it...");
          throw error;
        }
        this._isBroken = true;
        (0, _lokiExtensions.lokiFatalError)(this.loki);
        _logger.default.error("DatabaseDriver is broken. App must be reloaded before continuing.");
        var handler = this.options._onFatalError;
        handler && handler(error);
        throw error;
      };
      return (0, _createClass2.default)(DatabaseDriver2, [{
        key: "_databaseVersion",
        get: function get() {
          var databaseVersionRaw = this.getLocal(SCHEMA_VERSION_KEY) || "";
          return parseInt(databaseVersionRaw, 10) || 0;
        },
        set: function set(version) {
          this.setLocal(SCHEMA_VERSION_KEY, "".concat(version));
        }
      }, {
        key: "_localStorage",
        get: function get() {
          return this.loki.getCollection("local_storage");
        }
      }]);
    })();
  }
});

// node_modules/@nozbe/watermelondb/adapters/lokijs/worker/DatabaseBridge.js
var require_DatabaseBridge = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/lokijs/worker/DatabaseBridge.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _logError = _interopRequireDefault(require_logError());
    var _invariant = _interopRequireDefault(require_invariant());
    var _DatabaseDriver = _interopRequireDefault(require_DatabaseDriver());
    var DatabaseBridge = exports.default = (function() {
      function DatabaseBridge2(workerContext) {
        var _this = this;
        this.queue = [];
        this._actionsExecuting = 0;
        this.workerContext = workerContext;
        this.workerContext.onmessage = function(e) {
          var action = e.data;
          _this.queue.push(action);
          if (1 === _this.queue.length) {
            _this.executeNext();
          }
        };
      }
      var _proto = DatabaseBridge2.prototype;
      _proto.executeNext = function() {
        var action = this.queue[0];
        try {
          (0, _invariant.default)(0 === this._actionsExecuting, "worker should not have ongoing actions");
          this._actionsExecuting += 1;
          var {
            type,
            payload
          } = action;
          if ("setUp" === type || "unsafeResetDatabase" === type) {
            this.processActionAsync(action);
          } else {
            var response = this._driverAction(type).apply(void 0, (0, _toConsumableArray2.default)(payload));
            this.onActionDone(action, {
              value: response
            });
          }
        } catch (error) {
          this._onError(action, error);
        }
      };
      _proto.processActionAsync = function(action) {
        return new Promise((function($return, $error) {
          var type, payload, options, driver, response;
          var $Try_2_Post = function $Try_2_Post2() {
            try {
              return $return();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          };
          var $Try_2_Catch = (function(error) {
            try {
              this._onError(action, error);
              return $Try_2_Post();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }).bind(this);
          try {
            let $If_4 = function() {
              return $Try_2_Post();
            };
            ({
              type,
              payload
            } = action);
            if ("setUp" === type) {
              (0, _invariant.default)(!this.driver, "Loki driver already set up - cannot set up again");
              [options] = payload;
              driver = new _DatabaseDriver.default(options);
              return Promise.resolve(driver.setUp()).then((function() {
                try {
                  this.driver = driver;
                  this.onActionDone(action, {
                    value: null
                  });
                  return $If_4.call(this);
                } catch ($boundEx) {
                  return $Try_2_Catch($boundEx);
                }
              }).bind(this), $Try_2_Catch);
            } else {
              return Promise.resolve(this._driverAction(type).apply(void 0, (0, _toConsumableArray2.default)(payload))).then((function($await_6) {
                try {
                  response = $await_6;
                  this.onActionDone(action, {
                    value: response
                  });
                  return $If_4.call(this);
                } catch ($boundEx) {
                  return $Try_2_Catch($boundEx);
                }
              }).bind(this), $Try_2_Catch);
            }
          } catch (error) {
            $Try_2_Catch(error);
          }
        }).bind(this));
      };
      _proto.onActionDone = function(action, result) {
        (0, _invariant.default)(1 === this._actionsExecuting, "worker should be executing 1 action");
        this._actionsExecuting = 0;
        this.queue.shift();
        try {
          var response = {
            id: action.id,
            result,
            cloneMethod: action.returnCloneMethod
          };
          this.workerContext.postMessage(response);
        } catch (error) {
          (0, _logError.default)(error);
        }
        if (this.queue.length) {
          this.executeNext();
        }
      };
      _proto._driverAction = function(type) {
        (0, _invariant.default)(this.driver, "Cannot run actions because driver is not set up");
        var action = this.driver[type].bind(this.driver);
        (0, _invariant.default)(action, "Unknown worker action ".concat(type));
        return action;
      };
      _proto._onError = function(action, error) {
        (0, _logError.default)(error);
        this.onActionDone(action, {
          error
        });
      };
      return DatabaseBridge2;
    })();
  }
});

// node_modules/@nozbe/watermelondb/adapters/lokijs/worker/loki.worker.js
var require_loki_worker = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/lokijs/worker/loki.worker.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _DatabaseBridge = _interopRequireDefault(require_DatabaseBridge());
    var getDefaultExport = function() {
      self.workerClass = new _DatabaseBridge.default(self);
      return self;
    };
    var _default = exports.default = getDefaultExport();
  }
});

// node_modules/@nozbe/watermelondb/adapters/lokijs/worker/cloneMessage/index.js
var require_cloneMessage = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/lokijs/worker/cloneMessage/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = cloneMessage;
    exports.shallowCloneDeepObjects = shallowCloneDeepObjects;
    function shallowCloneDeepObjects(value) {
      if (Array.isArray(value)) {
        var returned = new Array(value.length);
        for (var i = 0, len = value.length; i < len; i += 1) {
          returned[i] = shallowCloneDeepObjects(value[i]);
        }
        return returned;
      } else if (value && "object" === typeof value) {
        return Object.assign({}, value);
      }
      return value;
    }
    function cloneMessage(data) {
      var method = data.cloneMethod;
      if ("shallowCloneDeepObjects" === method) {
        var clonedData = data;
        clonedData.payload = shallowCloneDeepObjects(clonedData.payload);
        return clonedData;
      } else if ("immutable" === method) {
        return data;
      }
      throw new Error("Unknown data.clone method for cloneMessage");
    }
  }
});

// node_modules/@nozbe/watermelondb/adapters/lokijs/worker/synchronousWorker.js
var require_synchronousWorker = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/lokijs/worker/synchronousWorker.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _DatabaseBridge = _interopRequireDefault(require_DatabaseBridge());
    var _cloneMessage = _interopRequireDefault(require_cloneMessage());
    var SynchronousWorker = exports.default = (function() {
      function SynchronousWorker2() {
        var _this = this;
        this.onmessage = function() {
        };
        this._workerContext = {
          postMessage: function postMessage(data) {
            _this.onmessage({
              data: (0, _cloneMessage.default)(data)
            });
          },
          onmessage: function onmessage() {
          }
        };
        this._bridge = new _DatabaseBridge.default(this._workerContext);
      }
      var _proto = SynchronousWorker2.prototype;
      _proto.postMessage = function(data) {
        this._workerContext.onmessage({
          data: (0, _cloneMessage.default)(data)
        });
      };
      return SynchronousWorker2;
    })();
  }
});

// node_modules/@nozbe/watermelondb/adapters/lokijs/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/lokijs/dispatcher.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    function createWorker(useWebWorker) {
      if (useWebWorker) {
        var LokiWebWorker = require_loki_worker();
        return new LokiWebWorker();
      }
      var LokiSynchronousWorker = require_synchronousWorker().default;
      return new LokiSynchronousWorker();
    }
    var _actionId = 0;
    function nextActionId() {
      _actionId += 1;
      return _actionId;
    }
    var LokiDispatcher = exports.default = (function() {
      function LokiDispatcher2(useWebWorker) {
        var _this = this;
        this._pendingCalls = [];
        this._worker = createWorker(useWebWorker);
        this._worker.onmessage = function({
          data
        }) {
          var {
            result,
            id: responseId
          } = data;
          var {
            callback,
            id
          } = _this._pendingCalls.shift();
          if (id !== responseId) {
            callback({
              error: new Error("Loki worker responses are out of order")
            });
            return;
          }
          callback(result);
        };
      }
      var _proto = LokiDispatcher2.prototype;
      _proto.call = function(type, payload = [], callback = function() {
      }, cloneMethod = "immutable", returnCloneMethod = "immutable") {
        var id = nextActionId();
        this._pendingCalls.push({
          callback,
          id
        });
        this._worker.postMessage({
          id,
          type,
          payload,
          cloneMethod,
          returnCloneMethod
        });
      };
      return LokiDispatcher2;
    })();
  }
});

// node_modules/@nozbe/watermelondb/adapters/lokijs/index.js
var require_lokijs = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/lokijs/index.js"(exports) {
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _extends2 = _interopRequireDefault(require_extends());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _invariant = _interopRequireDefault(require_invariant());
    var _logger = _interopRequireDefault(require_logger());
    var _common = require_common();
    var _dispatcher = _interopRequireDefault(require_dispatcher());
    var LokiJSAdapter = exports.default = (function() {
      function LokiJSAdapter2(options) {
        var _options$useWebWorker;
        this._options = options;
        this.dbName = options.dbName || "loki";
        var {
          schema,
          migrations
        } = options;
        var useWebWorker = null !== (_options$useWebWorker = options.useWebWorker) && void 0 !== _options$useWebWorker ? _options$useWebWorker : true;
        this._dispatcher = new _dispatcher.default(useWebWorker);
        this.schema = schema;
        this.migrations = migrations;
        if (true) {
          (0, _invariant.default)("useWebWorker" in options, "LokiJSAdapter `useWebWorker` option is required. Pass `{ useWebWorker: false }` to adopt the new behavior, or `{ useWebWorker: true }` to supress this warning with no changes");
          if (true === options.useWebWorker) {
            _logger.default.warn("LokiJSAdapter {useWebWorker: true} option is now deprecated. If you rely on this feature, please file an issue");
          }
          (0, _invariant.default)("useIncrementalIndexedDB" in options, "LokiJSAdapter `useIncrementalIndexedDB` option is required. Pass `{ useIncrementalIndexedDB: true }` to adopt the new behavior, or `{ useIncrementalIndexedDB: false }` to supress this warning with no changes");
          if (false === options.useIncrementalIndexedDB) {
            _logger.default.warn("LokiJSAdapter {useIncrementalIndexedDB: false} option is now deprecated. If you rely on this feature, please file an issue");
          }
          (0, _common.validateAdapter)(this);
        }
        this._dispatcher.call("setUp", [options], function(result) {
          return (0, _common.devSetupCallback)(result, options.onSetUpError);
        });
      }
      var _proto = LokiJSAdapter2.prototype;
      _proto.testClone = function(options = {}) {
        return new Promise((function($return) {
          var driver = this._driver;
          driver.loki.close();
          return $return(new LokiJSAdapter2((0, _extends2.default)({}, this._options, {
            _testLokiAdapter: driver.loki.persistenceAdapter
          }, options)));
        }).bind(this));
      };
      _proto.find = function(table, id, callback) {
        (0, _common.validateTable)(table, this.schema);
        this._dispatcher.call("find", [table, id], callback);
      };
      _proto.query = function(_query, callback) {
        (0, _common.validateTable)(_query.table, this.schema);
        this._dispatcher.call("query", [_query], callback);
      };
      _proto.queryIds = function(query, callback) {
        (0, _common.validateTable)(query.table, this.schema);
        this._dispatcher.call("queryIds", [query], callback);
      };
      _proto.unsafeQueryRaw = function(query, callback) {
        (0, _common.validateTable)(query.table, this.schema);
        this._dispatcher.call("unsafeQueryRaw", [query], callback);
      };
      _proto.count = function(query, callback) {
        (0, _common.validateTable)(query.table, this.schema);
        this._dispatcher.call("count", [query], callback);
      };
      _proto.batch = function(operations, callback) {
        var _this = this;
        operations.forEach(function([, table]) {
          return (0, _common.validateTable)(table, _this.schema);
        });
        this._dispatcher.call("batch", [operations], callback, "shallowCloneDeepObjects");
      };
      _proto.getDeletedRecords = function(table, callback) {
        (0, _common.validateTable)(table, this.schema);
        this._dispatcher.call("getDeletedRecords", [table], callback);
      };
      _proto.destroyDeletedRecords = function(table, recordIds, callback) {
        (0, _common.validateTable)(table, this.schema);
        this._dispatcher.call("batch", [recordIds.map(function(id) {
          return ["destroyPermanently", table, id];
        })], callback, "immutable", "immutable");
      };
      _proto.unsafeLoadFromSync = function(jsonId, callback) {
        callback({
          error: new Error("unsafeLoadFromSync unavailable in LokiJS")
        });
      };
      _proto.provideSyncJson = function(id, syncPullResultJson, callback) {
        callback({
          error: new Error("provideSyncJson unavailable in LokiJS")
        });
      };
      _proto.unsafeResetDatabase = function(callback) {
        this._dispatcher.call("unsafeResetDatabase", [], callback);
      };
      _proto.unsafeExecute = function(operations, callback) {
        this._dispatcher.call("unsafeExecute", [operations], callback);
      };
      _proto.getLocal = function(key, callback) {
        this._dispatcher.call("getLocal", [key], callback);
      };
      _proto.setLocal = function(key, value, callback) {
        (0, _invariant.default)("string" === typeof value, "adapter.setLocal() value must be a string");
        this._dispatcher.call("setLocal", [key, value], callback);
      };
      _proto.removeLocal = function(key, callback) {
        this._dispatcher.call("removeLocal", [key], callback);
      };
      _proto._fatalError = function(error) {
        this._dispatcher.call("_fatalError", [error], function() {
        });
      };
      _proto._clearCachedRecords = function() {
        this._dispatcher.call("clearCachedRecords", [], function() {
        });
      };
      _proto._debugDignoseMissingRecord = function(table, id) {
        var driver = this._driver;
        if (driver) {
          var lokiCollection = driver.loki.getCollection(table);
          var didFindById = !!lokiCollection.by("id", id);
          _logger.default.log("Did find ".concat(table, "#").concat(id, " in Loki collection by ID? ").concat(didFindById));
          var didFindByFilter = !!lokiCollection.data.filter(function(doc) {
            return doc.id === id;
          });
          _logger.default.log("Did find ".concat(table, "#").concat(id, " in Loki collection by filtering the collection? ").concat(didFindByFilter));
        }
      };
      return (0, _createClass2.default)(LokiJSAdapter2, [{
        key: "_driver",
        get: function get() {
          return this._dispatcher._worker._bridge.driver;
        }
      }]);
    })();
    LokiJSAdapter.adapterType = "loki";
  }
});
export default require_lokijs();
//# sourceMappingURL=@nozbe_watermelondb_adapters_lokijs.js.map
