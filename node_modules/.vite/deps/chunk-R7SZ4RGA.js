import {
  require_interopRequireDefault
} from "./chunk-UA6MBTDI.js";
import {
  __commonJS
} from "./chunk-OL46QLBJ.js";

// node_modules/@nozbe/watermelondb/utils/common/randomId/fallback.js
var require_fallback = __commonJS({
  "node_modules/@nozbe/watermelondb/utils/common/randomId/fallback.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = fallbackRandomId;
    var alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    function fallbackRandomId() {
      var id = "";
      var v = 0;
      for (var i = 0; 16 > i; i += 1) {
        v = Math.floor(62 * Math.random());
        id += alphabet[v % 62];
      }
      return id;
    }
  }
});

// node_modules/@nozbe/watermelondb/utils/common/randomId/randomId.js
var require_randomId = __commonJS({
  "node_modules/@nozbe/watermelondb/utils/common/randomId/randomId.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    var alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var randomNumbers = new Uint8Array(256);
    var cur = 9999999;
    function cryptoRandomId() {
      var id = "";
      var len = 0;
      var v = 0;
      while (16 > len) {
        if (256 > cur) {
          v = randomNumbers[cur] >> 2;
          cur++;
          if (62 > v) {
            id += alphabet[v];
            len++;
          }
        } else {
          globalThis.crypto.getRandomValues(randomNumbers);
          cur = 0;
        }
      }
      return id;
    }
    var isCryptoAvailable = globalThis.crypto && globalThis.crypto.getRandomValues;
    var randomId = isCryptoAvailable ? cryptoRandomId : require_fallback().default;
    var _default = exports.default = randomId;
  }
});

// node_modules/@nozbe/watermelondb/utils/common/randomId/index.js
var require_randomId2 = __commonJS({
  "node_modules/@nozbe/watermelondb/utils/common/randomId/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.setGenerator = exports.default = void 0;
    var _randomId = _interopRequireDefault(require_randomId());
    var generator = _randomId.default;
    var setGenerator = exports.setGenerator = function(newGenerator) {
      if ("string" !== typeof newGenerator()) {
        throw new Error("RandomId generator function needs to return a string type.");
      }
      generator = newGenerator;
    };
    var _default = exports.default = function() {
      return generator();
    };
  }
});

// node_modules/@nozbe/watermelondb/RawRecord/index.js
var require_RawRecord = __commonJS({
  "node_modules/@nozbe/watermelondb/RawRecord/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.nullValue = nullValue;
    exports.sanitizedRaw = sanitizedRaw;
    exports.setRawSanitized = setRawSanitized;
    var _randomId = _interopRequireDefault(require_randomId2());
    function isValidNumber(value) {
      return "number" === typeof value && value === value && value !== Infinity && value !== -Infinity;
    }
    function _setRaw(raw, key, value, columnSchema) {
      var {
        type,
        isOptional
      } = columnSchema;
      if ("string" === type) {
        if ("string" === typeof value) {
          raw[key] = value;
        } else {
          raw[key] = isOptional ? null : "";
        }
      } else if ("boolean" === type) {
        if ("boolean" === typeof value) {
          raw[key] = value;
        } else if (1 === value || 0 === value) {
          raw[key] = Boolean(value);
        } else {
          raw[key] = isOptional ? null : false;
        }
      } else {
        if (isValidNumber(value)) {
          raw[key] = value || 0;
        } else {
          raw[key] = isOptional ? null : 0;
        }
      }
    }
    function isValidStatus(value) {
      return "created" === value || "updated" === value || "deleted" === value || "synced" === value;
    }
    function sanitizedRaw(dirtyRaw, tableSchema) {
      var {
        id,
        _status,
        _changed
      } = dirtyRaw;
      var raw = {};
      if ("string" === typeof id) {
        raw.id = id;
        raw._status = isValidStatus(_status) ? _status : "created";
        raw._changed = "string" === typeof _changed ? _changed : "";
      } else {
        raw.id = (0, _randomId.default)();
        raw._status = "created";
        raw._changed = "";
      }
      var columns = tableSchema.columnArray;
      for (var i = 0, len = columns.length; i < len; i += 1) {
        var columnSchema = columns[i];
        var key = columnSchema.name;
        var value = Object.prototype.hasOwnProperty.call(dirtyRaw, key) ? dirtyRaw[key] : null;
        _setRaw(raw, key, value, columnSchema);
      }
      return raw;
    }
    function setRawSanitized(rawRecord, columnName, value, columnSchema) {
      _setRaw(rawRecord, columnName, value, columnSchema);
    }
    function nullValue(columnSchema) {
      var {
        isOptional,
        type
      } = columnSchema;
      if (isOptional) {
        return null;
      } else if ("string" === type) {
        return "";
      } else if ("number" === type) {
        return 0;
      } else if ("boolean" === type) {
        return false;
      }
      throw new Error("Unknown type for column schema ".concat(JSON.stringify(columnSchema)));
    }
  }
});

// node_modules/@nozbe/watermelondb/utils/fp/likeToRegexp/index.js
var require_likeToRegexp = __commonJS({
  "node_modules/@nozbe/watermelondb/utils/fp/likeToRegexp/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = likeToRegexp;
    function likeToRegexp(likeQuery) {
      var regexp = "^".concat(likeQuery, "$").replace(/%/g, ".*").replace(/_/g, ".");
      return new RegExp(regexp, "is");
    }
  }
});

export {
  require_randomId2 as require_randomId,
  require_likeToRegexp,
  require_RawRecord
};
//# sourceMappingURL=chunk-R7SZ4RGA.js.map
