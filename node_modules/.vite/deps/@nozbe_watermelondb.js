import {
  require_Relation
} from "./chunk-34UZUV7I.js";
import {
  require_Query,
  require_Result,
  require_common,
  require_ensureSync,
  require_inheritsLoose
} from "./chunk-TNLTTETE.js";
import {
  require_RawRecord
} from "./chunk-R7SZ4RGA.js";
import {
  require_rx
} from "./chunk-UI2AWJZP.js";
import {
  require_createClass
} from "./chunk-OXRMU63H.js";
import {
  require_QueryDescription,
  require_Schema
} from "./chunk-7IBXDPTB.js";
import {
  require_fp,
  require_fromPairs,
  require_interopRequireDefault,
  require_invariant,
  require_logger,
  require_noop,
  require_toConsumableArray
} from "./chunk-UA6MBTDI.js";
import {
  __commonJS
} from "./chunk-OL46QLBJ.js";

// node_modules/@nozbe/watermelondb/Collection/RecordCache.js
var require_RecordCache = __commonJS({
  "node_modules/@nozbe/watermelondb/Collection/RecordCache.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _logger = _interopRequireDefault(require_logger());
    var RecordCache = exports.default = (function() {
      function RecordCache2(tableName, recordInsantiator, collection) {
        this.map = /* @__PURE__ */ new Map();
        this.tableName = tableName;
        this.recordInsantiator = recordInsantiator;
        this._debugCollection = collection;
      }
      var _proto = RecordCache2.prototype;
      _proto.get = function(id) {
        return this.map.get(id);
      };
      _proto.add = function(record) {
        this.map.set(record.id, record);
      };
      _proto.delete = function(record) {
        this.map.delete(record.id);
      };
      _proto.unsafeClear = function() {
        this.map = /* @__PURE__ */ new Map();
      };
      _proto.recordsFromQueryResult = function(result) {
        var _this = this;
        return result.map(function(res) {
          return _this.recordFromQueryResult(res);
        });
      };
      _proto.recordFromQueryResult = function(result) {
        if ("string" === typeof result) {
          return this._cachedModelForId(result);
        }
        return this._modelForRaw(result);
      };
      _proto.rawRecordsFromQueryResult = function(results) {
        var _this2 = this;
        return results.map(function(res) {
          if ("string" === typeof res) {
            return _this2._cachedModelForId(res)._raw;
          }
          var cachedRecord = _this2.map.get(res.id);
          return cachedRecord ? cachedRecord._raw : res;
        });
      };
      _proto._cachedModelForId = function(id) {
        var record = this.map.get(id);
        if (!record) {
          var message = "Record ID ".concat(this.tableName, "#").concat(id, " was sent over the bridge, but it's not cached");
          _logger.default.error(message);
          try {
            var adapter = this._debugCollection.database.adapter.underlyingAdapter;
            if (adapter._clearCachedRecords) {
              adapter._clearCachedRecords();
            }
            if (adapter._debugDignoseMissingRecord) {
              adapter._debugDignoseMissingRecord(this.tableName, id);
            }
          } catch (error) {
            _logger.default.warn("Ran into an error while running diagnostics:");
            _logger.default.warn(error);
          }
          throw new Error(message);
        }
        return record;
      };
      _proto._modelForRaw = function(raw, warnIfCached = true) {
        var cachedRecord = this.map.get(raw.id);
        if (cachedRecord) {
          warnIfCached && _logger.default.warn("Record ".concat(this.tableName, "#").concat(cachedRecord.id, " is cached, but full raw object was sent over the bridge"));
          return cachedRecord;
        }
        var newRecord = this.recordInsantiator(raw);
        this.add(newRecord);
        return newRecord;
      };
      return RecordCache2;
    })();
  }
});

// node_modules/@nozbe/watermelondb/Collection/index.js
var require_Collection = __commonJS({
  "node_modules/@nozbe/watermelondb/Collection/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _rx = require_rx();
    var _invariant = _interopRequireDefault(require_invariant());
    var _fp = require_fp();
    var _Result = require_Result();
    var _Query = _interopRequireDefault(require_Query());
    var _RecordCache = _interopRequireDefault(require_RecordCache());
    var Collection = exports.default = (function() {
      function Collection2(database, ModelClass) {
        var _this = this;
        this.changes = new _rx.Subject();
        this._subscribers = [];
        this.database = database;
        this.modelClass = ModelClass;
        this._cache = new _RecordCache.default(ModelClass.table, function(raw) {
          return new ModelClass(_this, raw);
        }, this);
      }
      var _proto = Collection2.prototype;
      _proto.find = function(id) {
        return new Promise((function($return) {
          var _this2 = this;
          return $return((0, _Result.toPromise)(function(callback) {
            return _this2._fetchRecord(id, callback);
          }));
        }).bind(this));
      };
      _proto.findAndObserve = function(id) {
        var _this3 = this;
        return _rx.Observable.create(function(observer) {
          var unsubscribe = null;
          var unsubscribed = false;
          _this3._fetchRecord(id, function(result) {
            if (result.value) {
              var record = result.value;
              observer.next(record);
              unsubscribe = record.experimentalSubscribe(function(isDeleted) {
                if (!unsubscribed) {
                  isDeleted ? observer.complete() : observer.next(record);
                }
              });
            } else {
              observer.error(result.error);
            }
          });
          return function() {
            unsubscribed = true;
            unsubscribe && unsubscribe();
          };
        });
      };
      _proto.query = function(...args) {
        var clauses = (0, _fp.fromArrayOrSpread)(args, "Collection.query", "Clause");
        return new _Query.default(this, clauses);
      };
      _proto.create = function(recordBuilder = _fp.noop) {
        return new Promise((function($return, $error) {
          var record;
          this.database._ensureInWriter("Collection.create()");
          record = this.prepareCreate(recordBuilder);
          return Promise.resolve(this.database.batch(record)).then(function() {
            try {
              return $return(record);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }, $error);
        }).bind(this));
      };
      _proto.prepareCreate = function(recordBuilder = _fp.noop) {
        return this.modelClass._prepareCreate(this, recordBuilder);
      };
      _proto.prepareCreateFromDirtyRaw = function(dirtyRaw) {
        return this.modelClass._prepareCreateFromDirtyRaw(this, dirtyRaw);
      };
      _proto.disposableFromDirtyRaw = function(dirtyRaw) {
        return this.modelClass._disposableFromDirtyRaw(this, dirtyRaw);
      };
      _proto._fetchQuery = function(query, callback) {
        var _this4 = this;
        this.database.adapter.underlyingAdapter.query(query.serialize(), function(result) {
          return callback((0, _Result.mapValue)(function(rawRecords) {
            return _this4._cache.recordsFromQueryResult(rawRecords);
          }, result));
        });
      };
      _proto._fetchIds = function(query, callback) {
        this.database.adapter.underlyingAdapter.queryIds(query.serialize(), callback);
      };
      _proto._fetchCount = function(query, callback) {
        this.database.adapter.underlyingAdapter.count(query.serialize(), callback);
      };
      _proto._unsafeFetchRaw = function(query, callback) {
        this.database.adapter.underlyingAdapter.unsafeQueryRaw(query.serialize(), callback);
      };
      _proto._fetchRecord = function(id, callback) {
        var _this5 = this;
        if ("string" !== typeof id) {
          callback({
            error: new Error("Invalid record ID ".concat(this.table, "#").concat(id))
          });
          return;
        }
        var cachedRecord = this._cache.get(id);
        if (cachedRecord) {
          callback({
            value: cachedRecord
          });
          return;
        }
        this.database.adapter.underlyingAdapter.find(this.table, id, function(result) {
          return callback((0, _Result.mapValue)(function(rawRecord) {
            (0, _invariant.default)(rawRecord, "Record ".concat(_this5.table, "#").concat(id, " not found"));
            return _this5._cache.recordFromQueryResult(rawRecord);
          }, result));
        });
      };
      _proto._applyChangesToCache = function(operations) {
        var _this6 = this;
        operations.forEach(function({
          record,
          type
        }) {
          if ("created" === type) {
            record._preparedState = null;
            _this6._cache.add(record);
          } else if ("destroyed" === type) {
            _this6._cache.delete(record);
          }
        });
      };
      _proto._notify = function(operations) {
        this._subscribers.forEach(function([subscriber]) {
          subscriber(operations);
        });
        this.changes.next(operations);
        operations.forEach(function({
          record,
          type
        }) {
          if ("updated" === type) {
            record._notifyChanged();
          } else if ("destroyed" === type) {
            record._notifyDestroyed();
          }
        });
      };
      _proto.experimentalSubscribe = function(subscriber, debugInfo) {
        var _this7 = this;
        var entry = [subscriber, debugInfo];
        this._subscribers.push(entry);
        return function() {
          var idx = _this7._subscribers.indexOf(entry);
          -1 !== idx && _this7._subscribers.splice(idx, 1);
        };
      };
      return (0, _createClass2.default)(Collection2, [{
        key: "db",
        get: function get() {
          return this.database;
        }
        /**
         * Table name associated with this Collection
         */
      }, {
        key: "table",
        get: function get() {
          return this.modelClass.table;
        }
        /**
         * Table schema associated with this Collection
         */
      }, {
        key: "schema",
        get: function get() {
          return this.database.schema.tables[this.table];
        }
      }]);
    })();
  }
});

// node_modules/@nozbe/watermelondb/adapters/compat.js
var require_compat = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/compat.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _Result = require_Result();
    var DatabaseAdapterCompat = exports.default = (function() {
      function DatabaseAdapterCompat2(adapter) {
        this.underlyingAdapter = adapter;
      }
      var _proto = DatabaseAdapterCompat2.prototype;
      _proto.find = function(table, id) {
        var _this = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this.underlyingAdapter.find(table, id, callback);
        });
      };
      _proto.query = function(_query) {
        var _this2 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this2.underlyingAdapter.query(_query, callback);
        });
      };
      _proto.queryIds = function(query) {
        var _this3 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this3.underlyingAdapter.queryIds(query, callback);
        });
      };
      _proto.unsafeQueryRaw = function(query) {
        var _this4 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this4.underlyingAdapter.unsafeQueryRaw(query, callback);
        });
      };
      _proto.count = function(query) {
        var _this5 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this5.underlyingAdapter.count(query, callback);
        });
      };
      _proto.batch = function(operations) {
        var _this6 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this6.underlyingAdapter.batch(operations, callback);
        });
      };
      _proto.getDeletedRecords = function(tableName) {
        var _this7 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this7.underlyingAdapter.getDeletedRecords(tableName, callback);
        });
      };
      _proto.destroyDeletedRecords = function(tableName, recordIds) {
        var _this8 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this8.underlyingAdapter.destroyDeletedRecords(tableName, recordIds, callback);
        });
      };
      _proto.unsafeLoadFromSync = function(jsonId) {
        var _this9 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this9.underlyingAdapter.unsafeLoadFromSync(jsonId, callback);
        });
      };
      _proto.provideSyncJson = function(id, syncPullResultJson) {
        var _this10 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this10.underlyingAdapter.provideSyncJson(id, syncPullResultJson, callback);
        });
      };
      _proto.unsafeResetDatabase = function() {
        var _this11 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this11.underlyingAdapter.unsafeResetDatabase(callback);
        });
      };
      _proto.unsafeExecute = function(work) {
        var _this12 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this12.underlyingAdapter.unsafeExecute(work, callback);
        });
      };
      _proto.getLocal = function(key) {
        var _this13 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this13.underlyingAdapter.getLocal(key, callback);
        });
      };
      _proto.setLocal = function(key, value) {
        var _this14 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this14.underlyingAdapter.setLocal(key, value, callback);
        });
      };
      _proto.removeLocal = function(key) {
        var _this15 = this;
        return (0, _Result.toPromise)(function(callback) {
          return _this15.underlyingAdapter.removeLocal(key, callback);
        });
      };
      _proto.testClone = function(options) {
        return new Promise((function($return, $error) {
          return Promise.resolve(this.underlyingAdapter.testClone(options)).then(function($await_1) {
            try {
              return $return(new DatabaseAdapterCompat2($await_1));
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }, $error);
        }).bind(this));
      };
      return (0, _createClass2.default)(DatabaseAdapterCompat2, [{
        key: "schema",
        get: function get() {
          return this.underlyingAdapter.schema;
        }
      }, {
        key: "dbName",
        get: function get() {
          return this.underlyingAdapter.dbName;
        }
      }, {
        key: "migrations",
        get: function get() {
          return this.underlyingAdapter.migrations;
        }
      }]);
    })();
  }
});

// node_modules/@nozbe/watermelondb/Database/CollectionMap/index.js
var require_CollectionMap = __commonJS({
  "node_modules/@nozbe/watermelondb/Database/CollectionMap/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _Collection = _interopRequireDefault(require_Collection());
    var _common = require_common();
    var CollectionMap = exports.default = (function() {
      function CollectionMap2(db, modelClasses) {
        var _this = this;
        this.map = /* @__PURE__ */ Object.create(null);
        modelClasses.forEach(function(modelClass) {
          var {
            table
          } = modelClass;
          if (true) {
            (0, _common.invariant)("string" === typeof table, "Model class ".concat(modelClass.name, ` passed to Database constructor is missing "static table = 'table_name'"`));
            (0, _common.invariant)(db.schema.tables[table], "Model class ".concat(modelClass.name, " has static table defined that is missing in schema known by this database"));
          }
          _this.map[table] = new _Collection.default(db, modelClass);
        });
        Object.freeze(this.map);
      }
      var _proto = CollectionMap2.prototype;
      _proto.get = function(tableName) {
        return this.map[tableName] || null;
      };
      return CollectionMap2;
    })();
  }
});

// node_modules/@nozbe/watermelondb/Database/WorkQueue.js
var require_WorkQueue = __commonJS({
  "node_modules/@nozbe/watermelondb/Database/WorkQueue.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inheritsLoose2 = _interopRequireDefault(require_inheritsLoose());
    var _common = require_common();
    var ReaderInterfaceImpl = (function() {
      function ReaderInterfaceImpl2(queue, item) {
        this.__workQueue = queue;
        this.__workItem = item;
      }
      var _proto = ReaderInterfaceImpl2.prototype;
      _proto.__validateQueue = function() {
        (0, _common.invariant)(this.__workQueue._queue[0] === this.__workItem, "Illegal call on a reader/writer that should no longer be running");
      };
      _proto.callReader = function(reader) {
        this.__validateQueue();
        return this.__workQueue.subAction(reader);
      };
      return ReaderInterfaceImpl2;
    })();
    var WriterInterfaceImpl = (function(_ReaderInterfaceImpl) {
      function WriterInterfaceImpl2() {
        return _ReaderInterfaceImpl.apply(this, arguments) || this;
      }
      (0, _inheritsLoose2.default)(WriterInterfaceImpl2, _ReaderInterfaceImpl);
      var _proto2 = WriterInterfaceImpl2.prototype;
      _proto2.callWriter = function(writer) {
        this.__validateQueue();
        return this.__workQueue.subAction(writer);
      };
      _proto2.batch = function(...records) {
        this.__validateQueue();
        return this.__workQueue._db.batch(records);
      };
      return WriterInterfaceImpl2;
    })(ReaderInterfaceImpl);
    var actionInterface = function(queue, item) {
      return item.isWriter ? new WriterInterfaceImpl(queue, item) : new ReaderInterfaceImpl(queue, item);
    };
    var WorkQueue = exports.default = (function() {
      function WorkQueue2(db) {
        this._queue = [];
        this._subActionIncoming = false;
        this._db = db;
      }
      var _proto3 = WorkQueue2.prototype;
      _proto3.enqueue = function(work, description, isWriter) {
        var _this = this;
        if (this._subActionIncoming) {
          this._subActionIncoming = false;
          var currentWork = this._queue[0];
          if (!currentWork.isWriter) {
            (0, _common.invariant)(!isWriter, "Cannot call a writer block from a reader block");
          }
          return work(actionInterface(this, currentWork));
        }
        return new Promise(function(resolve, reject) {
          var workItem = {
            work,
            isWriter,
            resolve,
            reject,
            description
          };
          if (_this._queue.length) {
            setTimeout(function() {
              var queue = _this._queue;
              var current = queue[0];
              if (current === workItem || !queue.includes(workItem)) {
                return;
              }
              var enqueuedKind = isWriter ? "writer" : "reader";
              var currentKind = current.isWriter ? "writer" : "reader";
              _common.logger.warn("The ".concat(enqueuedKind, " you're trying to run (").concat(description || "unnamed", ") can't be performed yet, because there are ").concat(queue.length, " other readers/writers in the queue.\n\nCurrent ").concat(currentKind, ": ").concat(current.description || "unnamed", ".\n\nIf everything is working fine, you can safely ignore this message (queueing is working as expected). But if your readers/writers are not running, it's because the current ").concat(currentKind, " is stuck.\nRemember that if you're calling a reader/writer from another reader/writer, you must use callReader()/callWriter(). See docs for more details."));
              _common.logger.log("Enqueued ".concat(enqueuedKind, ":"), work);
              _common.logger.log("Running ".concat(currentKind, ":"), current.work);
            }, 1500);
          }
          _this._queue.push(workItem);
          if (1 === _this._queue.length) {
            _this._executeNext();
          }
        });
      };
      _proto3.subAction = function(work) {
        try {
          this._subActionIncoming = true;
          var promise = work();
          (0, _common.invariant)(!this._subActionIncoming, "callReader/callWriter call must call a reader/writer synchronously");
          return promise;
        } catch (error) {
          this._subActionIncoming = false;
          return Promise.reject(error);
        }
      };
      _proto3._executeNext = function() {
        return new Promise((function($return, $error) {
          var _this2, workItem, work, resolve, reject, isWriter, workPromise;
          _this2 = this;
          workItem = this._queue[0];
          ({
            work,
            resolve,
            reject,
            isWriter
          } = workItem);
          var $Try_2_Post = (function() {
            try {
              this._queue.shift();
              if (this._queue.length) {
                setTimeout(function() {
                  return _this2._executeNext();
                }, 0);
              }
              return $return();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }).bind(this);
          var $Try_2_Catch = function $Try_2_Catch2(error) {
            try {
              reject(error);
              return $Try_2_Post();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          };
          try {
            workPromise = work(actionInterface(this, workItem));
            if (true) {
              (0, _common.invariant)(workPromise instanceof Promise, "The function passed to database.".concat(isWriter ? "write" : "read", "() or a method marked as @").concat(isWriter ? "writer" : "reader", " must be asynchronous (marked as 'async' or always returning a promise) (in: ").concat(workItem.description || "unnamed", ")"));
            }
            return Promise.resolve(workPromise).then(function($await_3) {
              try {
                resolve($await_3);
                return $Try_2_Post();
              } catch ($boundEx) {
                return $Try_2_Catch($boundEx);
              }
            }, $Try_2_Catch);
          } catch (error) {
            $Try_2_Catch(error);
          }
        }).bind(this));
      };
      _proto3._abortPendingWork = function() {
        (0, _common.invariant)(1 <= this._queue.length, "_abortPendingWork can only be called from a reader/writer");
        var workToAbort = this._queue.splice(1);
        workToAbort.forEach(function({
          reject
        }) {
          reject(new Error("Reader/writer has been aborted because the database was reset"));
        });
      };
      return (0, _createClass2.default)(WorkQueue2, [{
        key: "isWriterRunning",
        get: function get() {
          var [item] = this._queue;
          return Boolean(item && item.isWriter);
        }
      }]);
    })();
  }
});

// node_modules/@nozbe/watermelondb/adapters/error.js
var require_error = __commonJS({
  "node_modules/@nozbe/watermelondb/adapters/error.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    var _createClass2 = _interopRequireDefault(require_createClass());
    var throwError = function(name) {
      throw new Error("Cannot call database.adapter.".concat(name, " while the database is being reset"));
    };
    var ErrorAdapter = exports.default = (function() {
      function ErrorAdapter2() {
        var _this = this;
        ["find", "query", "queryIds", "count", "batch", "getDeletedRecords", "destroyDeletedRecords", "unsafeResetDatabase", "getLocal", "setLocal", "removeLocal", "testClone"].forEach(function(name) {
          _this[name] = function() {
            return throwError(name);
          };
        });
      }
      return (0, _createClass2.default)(ErrorAdapter2, [{
        key: "underlyingAdapter",
        get: function get() {
          throwError("underlyingAdapter");
        }
      }, {
        key: "schema",
        get: function get() {
          throwError("schema");
        }
      }, {
        key: "migrations",
        get: function get() {
          throwError("migrations");
        }
      }]);
    })();
  }
});

// node_modules/@nozbe/watermelondb/Database/LocalStorage/index.js
var require_LocalStorage = __commonJS({
  "node_modules/@nozbe/watermelondb/Database/LocalStorage/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.default = void 0;
    exports.localStorageKey = localStorageKey;
    var _common = require_common();
    function localStorageKey(name) {
      return name;
    }
    var LocalStorage = exports.default = (function() {
      function LocalStorage2(database) {
        this._db = database;
      }
      var _proto = LocalStorage2.prototype;
      _proto.get = function(key) {
        return new Promise((function($return, $error) {
          var json;
          return Promise.resolve(this._db.adapter.getLocal(key)).then(function($await_1) {
            try {
              json = $await_1;
              return $return(null == json ? void 0 : JSON.parse(json));
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }, $error);
        }).bind(this));
      };
      _proto._getSync = function(key, callback) {
        this._db.adapter.underlyingAdapter.getLocal(key, function(result) {
          var json = result.value ? result.value : void 0;
          var value = null == json ? void 0 : JSON.parse(json);
          callback(value);
        });
      };
      _proto.set = function(key, value) {
        return new Promise((function($return) {
          var json = JSON.stringify(value);
          (0, _common.invariant)("string" === typeof json, "Value not JSON-serializable");
          return $return(this._db.adapter.setLocal(key, json));
        }).bind(this));
      };
      _proto.remove = function(key) {
        return new Promise((function($return) {
          return $return(this._db.adapter.removeLocal(key));
        }).bind(this));
      };
      return LocalStorage2;
    })();
  }
});

// node_modules/@nozbe/watermelondb/Database/index.js
var require_Database = __commonJS({
  "node_modules/@nozbe/watermelondb/Database/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = void 0;
    exports.setExperimentalAllowsFatalError = setExperimentalAllowsFatalError;
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _rx = require_rx();
    var _common = require_common();
    var _fp = require_fp();
    var _compat = _interopRequireDefault(require_compat());
    var _CollectionMap = _interopRequireDefault(require_CollectionMap());
    var _WorkQueue = _interopRequireDefault(require_WorkQueue());
    var experimentalAllowsFatalError = false;
    function setExperimentalAllowsFatalError() {
      experimentalAllowsFatalError = true;
    }
    var Database = exports.default = (function() {
      function Database2(options) {
        this._workQueue = new _WorkQueue.default(this);
        this._isBroken = false;
        this._pendingNotificationBatches = 0;
        this._pendingNotificationChanges = [];
        this._subscribers = [];
        this._resetCount = 0;
        this._isBeingReset = false;
        this.experimentalIsVerbose = false;
        var {
          adapter,
          modelClasses
        } = options;
        if (true) {
          (0, _common.invariant)(adapter, "Missing adapter parameter for new Database()");
          (0, _common.invariant)(modelClasses && Array.isArray(modelClasses), "Missing modelClasses parameter for new Database()");
        }
        this.adapter = new _compat.default(adapter);
        this.schema = adapter.schema;
        this.collections = new _CollectionMap.default(this, modelClasses);
      }
      var _proto = Database2.prototype;
      _proto.get = function(tableName) {
        return this.collections.get(tableName);
      };
      _proto.batch = function(...records) {
        return new Promise((function($return, $error) {
          var _this, actualRecords, batchOperations, changeNotifications, debugInfo, changes;
          _this = this;
          actualRecords = (0, _fp.fromArrayOrSpread)(records, "Database.batch", "Model");
          this._ensureInWriter("Database.batch()");
          batchOperations = [];
          changeNotifications = {};
          actualRecords.forEach(function(record) {
            if (!record) {
              return;
            }
            var preparedState = record._preparedState;
            if (!preparedState) {
              (0, _common.invariant)("disposable" !== record._raw._status, "Cannot batch a disposable record");
              throw new Error("Cannot batch a record that doesn't have a prepared create/update/delete");
            }
            var raw = record._raw;
            var {
              id
            } = raw;
            var {
              table
            } = record.constructor;
            var changeType;
            if ("update" === preparedState) {
              batchOperations.push(["update", table, raw]);
              changeType = "updated";
            } else if ("create" === preparedState) {
              batchOperations.push(["create", table, raw]);
              changeType = "created";
            } else if ("markAsDeleted" === preparedState) {
              batchOperations.push(["markAsDeleted", table, id]);
              changeType = "destroyed";
            } else if ("destroyPermanently" === preparedState) {
              batchOperations.push(["destroyPermanently", table, id]);
              changeType = "destroyed";
            } else {
              (0, _common.invariant)(false, "bad preparedState");
            }
            if ("create" !== preparedState) {
              record._preparedState = null;
            }
            if (!changeNotifications[table]) {
              changeNotifications[table] = [];
            }
            changeNotifications[table].push({
              record,
              type: changeType
            });
          });
          return Promise.resolve(this.adapter.batch(batchOperations)).then((function() {
            try {
              if (this.experimentalIsVerbose) {
                debugInfo = batchOperations.map(function([type, table, rawOrId]) {
                  switch (type) {
                    case "create":
                    case "update":
                      return "".concat(type, " ").concat(table, "#").concat(rawOrId.id);
                    case "markAsDeleted":
                    case "destroyPermanently":
                      return "".concat(type, " ").concat(table, "#").concat(rawOrId);
                    default:
                      return "".concat(type, "???");
                  }
                }).join(", ");
                _common.logger.debug("batch: ".concat(debugInfo));
              }
              changes = Object.entries(changeNotifications);
              changes.forEach(function([table, changeSet]) {
                _this.collections.get(table)._applyChangesToCache(changeSet);
              });
              this._notify(changes);
              return $return(void 0);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }).bind(this), $error);
        }).bind(this));
      };
      _proto._notify = function(changes) {
        var _this2 = this;
        if (0 < this._pendingNotificationBatches) {
          this._pendingNotificationChanges.push(changes);
          return;
        }
        var affectedTables = new Set(changes.map(function([table]) {
          return table;
        }));
        this._subscribers.forEach(function([tables, subscriber]) {
          if (tables.some(function(table) {
            return affectedTables.has(table);
          })) {
            subscriber();
          }
        });
        changes.forEach(function([table, changeSet]) {
          _this2.collections.get(table)._notify(changeSet);
        });
      };
      _proto.experimentalBatchNotifications = function(work) {
        return new Promise((function($return, $error) {
          var $Try_1_Finally = (function($Try_1_Exit) {
            return (function($Try_1_Value) {
              try {
                this._pendingNotificationBatches -= 1;
                if (0 === this._pendingNotificationBatches) {
                  changes = this._pendingNotificationChanges;
                  this._pendingNotificationChanges = [];
                  changes.forEach(function(_changes) {
                    return _this3._notify(_changes);
                  });
                }
                return $Try_1_Exit && $Try_1_Exit.call(this, $Try_1_Value);
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }).bind(this);
          }).bind(this);
          var _this3, result, changes;
          _this3 = this;
          var $Try_1_Catch = function $Try_1_Catch2($exception_2) {
            try {
              throw $exception_2;
            } catch ($boundEx) {
              return $Try_1_Finally($error)($boundEx);
            }
          };
          try {
            this._pendingNotificationBatches += 1;
            return Promise.resolve(work()).then(function($await_6) {
              try {
                result = $await_6;
                return $Try_1_Finally($return)(result);
              } catch ($boundEx) {
                return $Try_1_Catch($boundEx);
              }
            }, $Try_1_Catch);
          } catch ($exception_2) {
            $Try_1_Catch($exception_2);
          }
        }).bind(this));
      };
      _proto.write = function(work, description) {
        return this._workQueue.enqueue(work, description, true);
      };
      _proto.read = function(work, description) {
        return this._workQueue.enqueue(work, description, false);
      };
      _proto.withChangesForTables = function(tables) {
        var _this4 = this;
        var changesSignals = tables.map(function(table) {
          return _this4.collections.get(table).changes;
        });
        return _rx.merge.apply(void 0, (0, _toConsumableArray2.default)(changesSignals)).pipe((0, _rx.startWith)(null));
      };
      _proto.experimentalSubscribe = function(tables, subscriber, debugInfo) {
        var _this5 = this;
        if (!tables.length) {
          return _fp.noop;
        }
        var entry = [tables, subscriber, debugInfo];
        this._subscribers.push(entry);
        return function() {
          var idx = _this5._subscribers.indexOf(entry);
          -1 !== idx && _this5._subscribers.splice(idx, 1);
        };
      };
      _proto.unsafeResetDatabase = function() {
        return new Promise((function($return, $error) {
          var $Try_3_Finally = (function($Try_3_Exit) {
            return (function($Try_3_Value) {
              try {
                this._isBeingReset = false;
                return $Try_3_Exit && $Try_3_Exit.call(this, $Try_3_Value);
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }).bind(this);
          }).bind(this);
          var adapter, ErrorAdapter;
          this._ensureInWriter("Database.unsafeResetDatabase()");
          var $Try_3_Post = function $Try_3_Post2() {
            try {
              return $return();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          };
          var $Try_3_Catch = function $Try_3_Catch2($exception_4) {
            try {
              throw $exception_4;
            } catch ($boundEx) {
              return $Try_3_Finally($error)($boundEx);
            }
          };
          try {
            this._isBeingReset = true;
            this._workQueue._abortPendingWork();
            ({
              adapter
            } = this);
            ErrorAdapter = require_error().default;
            this.adapter = new ErrorAdapter();
            if (this._subscribers.length) {
              console.log("Application error! Unexpected ".concat(this._subscribers.length, " Database subscribers were detected during database.unsafeResetDatabase() call. App should not hold onto subscriptions or Watermelon objects while resetting database."));
              console.log(this._subscribers);
              this._subscribers = [];
            }
            return Promise.resolve(adapter.unsafeResetDatabase()).then((function() {
              try {
                Object.values(this.collections.map).forEach(function(collection) {
                  collection._cache.unsafeClear();
                });
                this._resetCount += 1;
                this.adapter = adapter;
                return $Try_3_Finally($Try_3_Post)();
              } catch ($boundEx) {
                return $Try_3_Catch($boundEx);
              }
            }).bind(this), $Try_3_Catch);
          } catch ($exception_4) {
            $Try_3_Catch($exception_4);
          }
        }).bind(this));
      };
      _proto._ensureInWriter = function(debugName) {
        (0, _common.invariant)(this._workQueue.isWriterRunning, "".concat(debugName, " can only be called from inside of a Writer. See docs for more details."));
      };
      _proto._fatalError = function(error) {
        if (!experimentalAllowsFatalError) {
          _common.logger.warn("Database is now broken, but experimentalAllowsFatalError has not been enabled to do anything about it...");
          return;
        }
        this._isBroken = true;
        _common.logger.error("Database is broken. App must be reloaded before continuing.");
        if (this.adapter.underlyingAdapter._fatalError) {
          this.adapter.underlyingAdapter._fatalError(error);
        }
      };
      return (0, _createClass2.default)(Database2, [{
        key: "localStorage",
        get: function get() {
          if (!this._localStorage) {
            var LocalStorageClass = require_LocalStorage().default;
            this._localStorage = new LocalStorageClass(this);
          }
          return this._localStorage;
        }
      }]);
    })();
  }
});

// node_modules/@nozbe/watermelondb/sync/helpers.js
var require_helpers = __commonJS({
  "node_modules/@nozbe/watermelondb/sync/helpers.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.addToRawSet = addToRawSet;
    exports.setRawColumnChange = setRawColumnChange;
    function addToRawSet(rawSet, value) {
      var array = rawSet ? rawSet.split(",") : [];
      var set = new Set(array);
      set.add(value);
      return Array.from(set).join(",");
    }
    function setRawColumnChange(rawRecord, columnName) {
      rawRecord._changed = addToRawSet(rawRecord._changed, columnName);
      if ("created" !== rawRecord._status) {
        rawRecord._status = "updated";
      }
    }
  }
});

// node_modules/@nozbe/watermelondb/Model/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/@nozbe/watermelondb/Model/helpers.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.createTimestampsFor = void 0;
    exports.fetchDescendants = fetchDescendants;
    var _fp = require_fp();
    var Q = _interopRequireWildcard(require_QueryDescription());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    var createTimestampsFor = exports.createTimestampsFor = function(model) {
      var date = Date.now();
      var timestamps = {};
      if ("createdAt" in model) {
        timestamps.created_at = date;
      }
      if ("updatedAt" in model) {
        timestamps.updated_at = date;
      }
      return timestamps;
    };
    function getChildrenQueries(model) {
      var associationsList = Object.entries(model.constructor.associations);
      var hasManyAssociations = associationsList.filter(function([, value]) {
        return "has_many" === value.type;
      });
      var childrenQueries = hasManyAssociations.map(function([key, value]) {
        var childCollection = model.collections.get(key);
        return childCollection.query(Q.where(value.foreignKey, model.id));
      });
      return childrenQueries;
    }
    function fetchDescendantsInner(model) {
      return new Promise(function($return, $error) {
        var childPromise, childrenQueries, results;
        childPromise = function(query) {
          return new Promise(function($return2, $error2) {
            var children, grandchildren;
            return Promise.resolve(query.fetch()).then(function($await_1) {
              try {
                children = $await_1;
                return Promise.resolve((0, _fp.allPromises)(fetchDescendantsInner, children)).then(function($await_2) {
                  try {
                    grandchildren = $await_2;
                    return $return2((0, _fp.unnest)(grandchildren).concat(children));
                  } catch ($boundEx) {
                    return $error2($boundEx);
                  }
                }, $error2);
              } catch ($boundEx) {
                return $error2($boundEx);
              }
            }, $error2);
          });
        };
        childrenQueries = getChildrenQueries(model);
        return Promise.resolve((0, _fp.allPromises)(childPromise, childrenQueries)).then(function($await_3) {
          try {
            results = $await_3;
            return $return((0, _fp.unnest)(results));
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }, $error);
      });
    }
    function fetchDescendants(model) {
      return new Promise(function($return, $error) {
        var descendants;
        return Promise.resolve(fetchDescendantsInner(model)).then(function($await_4) {
          try {
            descendants = $await_4;
            return $return(Array.from(new Set(descendants)));
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }, $error);
      });
    }
  }
});

// node_modules/@nozbe/watermelondb/Model/index.js
var require_Model = __commonJS({
  "node_modules/@nozbe/watermelondb/Model/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.associations = associations;
    exports.default = void 0;
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _rx = require_rx();
    var _logger = _interopRequireDefault(require_logger());
    var _invariant = _interopRequireDefault(require_invariant());
    var _ensureSync = _interopRequireDefault(require_ensureSync());
    var _fromPairs = _interopRequireDefault(require_fromPairs());
    var _noop = _interopRequireDefault(require_noop());
    var _Schema = require_Schema();
    var _RawRecord = require_RawRecord();
    var _helpers = require_helpers();
    var _helpers2 = require_helpers2();
    function associations(...associationList) {
      return (0, _fromPairs.default)(associationList);
    }
    var Model = exports.default = (function() {
      function Model2(collection, raw) {
        this._isEditing = false;
        this._preparedState = null;
        this.__changes = null;
        this._subscribers = [];
        this.collection = collection;
        this._raw = raw;
      }
      var _proto = Model2.prototype;
      _proto._getChanges = function() {
        if (!this.__changes) {
          this.__changes = new _rx.BehaviorSubject(this);
        }
        return this.__changes;
      };
      _proto.update = function(recordUpdater = _noop.default) {
        return new Promise((function($return, $error) {
          var record;
          this.__ensureInWriter("Model.update()");
          record = this.prepareUpdate(recordUpdater);
          return Promise.resolve(this.db.batch(this)).then(function() {
            try {
              return $return(record);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }, $error);
        }).bind(this));
      };
      _proto.prepareUpdate = function(recordUpdater = _noop.default) {
        var _this = this;
        (0, _invariant.default)(!this._preparedState, "Cannot update a record with pending changes (".concat(this.__debugName, ")"));
        this.__ensureNotDisposable("Model.prepareUpdate()");
        this._isEditing = true;
        if ("updatedAt" in this) {
          this._setRaw((0, _Schema.columnName)("updated_at"), Date.now());
        }
        (0, _ensureSync.default)(recordUpdater(this));
        this._isEditing = false;
        this._preparedState = "update";
        if ("undefined" !== typeof process && process && process.nextTick) {
          process.nextTick(function() {
            (0, _invariant.default)("update" !== _this._preparedState, "record.prepareUpdate was called on ".concat(_this.__debugName, " but wasn't sent to batch() synchronously -- this is bad!"));
          });
        }
        this.__logVerbose("prepareUpdate");
        return this;
      };
      _proto.markAsDeleted = function() {
        return new Promise((function($return, $error) {
          this.__ensureInWriter("Model.markAsDeleted()");
          this.__ensureNotDisposable("Model.markAsDeleted()");
          return Promise.resolve(this.db.batch(this.prepareMarkAsDeleted())).then(function() {
            try {
              return $return();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }, $error);
        }).bind(this));
      };
      _proto.prepareMarkAsDeleted = function() {
        (0, _invariant.default)(!this._preparedState, "Cannot mark a record with pending changes as deleted (".concat(this.__debugName, ")"));
        this.__ensureNotDisposable("Model.prepareMarkAsDeleted()");
        this._raw._status = "deleted";
        this._preparedState = "markAsDeleted";
        this.__logVerbose("prepareMarkAsDeleted");
        return this;
      };
      _proto.destroyPermanently = function() {
        return new Promise((function($return, $error) {
          this.__ensureInWriter("Model.destroyPermanently()");
          this.__ensureNotDisposable("Model.destroyPermanently()");
          return Promise.resolve(this.db.batch(this.prepareDestroyPermanently())).then(function() {
            try {
              return $return();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }, $error);
        }).bind(this));
      };
      _proto.prepareDestroyPermanently = function() {
        (0, _invariant.default)(!this._preparedState, "Cannot destroy permanently record with pending changes (".concat(this.__debugName, ")"));
        this.__ensureNotDisposable("Model.prepareDestroyPermanently()");
        this._raw._status = "deleted";
        this._preparedState = "destroyPermanently";
        this.__logVerbose("prepareDestroyPermanently");
        return this;
      };
      _proto.experimentalMarkAsDeleted = function() {
        return new Promise((function($return, $error) {
          var records;
          this.__ensureInWriter("Model.experimentalMarkAsDeleted()");
          this.__ensureNotDisposable("Model.experimentalMarkAsDeleted()");
          return Promise.resolve((0, _helpers2.fetchDescendants)(this)).then((function($await_4) {
            try {
              records = $await_4;
              records.forEach(function(model) {
                return model.prepareMarkAsDeleted();
              });
              records.push(this.prepareMarkAsDeleted());
              return Promise.resolve(this.db.batch(records)).then(function() {
                try {
                  return $return();
                } catch ($boundEx) {
                  return $error($boundEx);
                }
              }, $error);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }).bind(this), $error);
        }).bind(this));
      };
      _proto.experimentalDestroyPermanently = function() {
        return new Promise((function($return, $error) {
          var records;
          this.__ensureInWriter("Model.experimentalDestroyPermanently()");
          this.__ensureNotDisposable("Model.experimentalDestroyPermanently()");
          return Promise.resolve((0, _helpers2.fetchDescendants)(this)).then((function($await_6) {
            try {
              records = $await_6;
              records.forEach(function(model) {
                return model.prepareDestroyPermanently();
              });
              records.push(this.prepareDestroyPermanently());
              return Promise.resolve(this.db.batch(records)).then(function() {
                try {
                  return $return();
                } catch ($boundEx) {
                  return $error($boundEx);
                }
              }, $error);
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }).bind(this), $error);
        }).bind(this));
      };
      _proto.observe = function() {
        (0, _invariant.default)("create" !== this._preparedState, "Cannot observe uncommitted record (".concat(this.__debugName, ")"));
        return this._getChanges();
      };
      _proto.batch = function(...records) {
        return this.db.batch(records);
      };
      _proto.callWriter = function(action) {
        return this.db._workQueue.subAction(action);
      };
      _proto.callReader = function(action) {
        return this.db._workQueue.subAction(action);
      };
      Model2._prepareCreate = function(collection, recordBuilder) {
        var record = new this(
          collection,
          // sanitizedRaw sets id
          (0, _RawRecord.sanitizedRaw)((0, _helpers2.createTimestampsFor)(this.prototype), collection.schema)
        );
        record._preparedState = "create";
        record._isEditing = true;
        (0, _ensureSync.default)(recordBuilder(record));
        record._isEditing = false;
        record.__logVerbose("prepareCreate");
        return record;
      };
      Model2._prepareCreateFromDirtyRaw = function(collection, dirtyRaw) {
        var record = new this(collection, (0, _RawRecord.sanitizedRaw)(dirtyRaw, collection.schema));
        record._preparedState = "create";
        record.__logVerbose("prepareCreateFromDirtyRaw");
        return record;
      };
      Model2._disposableFromDirtyRaw = function(collection, dirtyRaw) {
        var record = new this(collection, (0, _RawRecord.sanitizedRaw)(dirtyRaw, collection.schema));
        record._raw._status = "disposable";
        record.__logVerbose("disposableFromDirtyRaw");
        return record;
      };
      _proto.experimentalSubscribe = function(subscriber, debugInfo) {
        var _this2 = this;
        var entry = [subscriber, debugInfo];
        this._subscribers.push(entry);
        return function() {
          var idx = _this2._subscribers.indexOf(entry);
          -1 !== idx && _this2._subscribers.splice(idx, 1);
        };
      };
      _proto._notifyChanged = function() {
        this._getChanges().next(this);
        this._subscribers.forEach(function([subscriber]) {
          subscriber(false);
        });
      };
      _proto._notifyDestroyed = function() {
        this._getChanges().complete();
        this._subscribers.forEach(function([subscriber]) {
          subscriber(true);
        });
      };
      _proto._getRaw = function(rawFieldName) {
        return this._raw[rawFieldName];
      };
      _proto._setRaw = function(rawFieldName, rawValue) {
        this.__ensureCanSetRaw();
        var valueBefore = this._raw[rawFieldName];
        (0, _RawRecord.setRawSanitized)(this._raw, rawFieldName, rawValue, this.collection.schema.columns[rawFieldName]);
        if (valueBefore !== this._raw[rawFieldName] && "create" !== this._preparedState) {
          (0, _helpers.setRawColumnChange)(this._raw, rawFieldName);
        }
      };
      _proto._dangerouslySetRawWithoutMarkingColumnChange = function(rawFieldName, rawValue) {
        this.__ensureCanSetRaw();
        (0, _RawRecord.setRawSanitized)(this._raw, rawFieldName, rawValue, this.collection.schema.columns[rawFieldName]);
      };
      _proto.__ensureCanSetRaw = function() {
        this.__ensureNotDisposable("Model._setRaw()");
        (0, _invariant.default)(this._isEditing, "Not allowed to change record ".concat(this.__debugName, " outside of create/update()"));
        (0, _invariant.default)(!this._getChanges().isStopped && "deleted" !== this._raw._status, "Not allowed to change deleted record ".concat(this.__debugName));
      };
      _proto.__ensureNotDisposable = function(debugName) {
        (0, _invariant.default)("disposable" !== this._raw._status, "".concat(debugName, " cannot be called on a disposable record ").concat(this.__debugName));
      };
      _proto.__ensureInWriter = function(debugName) {
        this.db._ensureInWriter("".concat(debugName, " (").concat(this.__debugName, ")"));
      };
      _proto.__logVerbose = function(debugName) {
        if (this.db.experimentalIsVerbose) {
          _logger.default.debug("".concat(debugName, ": ").concat(this.__debugName));
        }
      };
      return (0, _createClass2.default)(Model2, [{
        key: "id",
        get: function get() {
          return this._raw.id;
        }
        /**
         * Record's sync status
         *
         * @see SyncStatus
         */
      }, {
        key: "syncStatus",
        get: function get() {
          return this._raw._status;
        }
      }, {
        key: "collections",
        get: (
          // TODO: Deprecate
          /**
           * Collections of other Models in the same database as this record.
           *
           * @deprecated
           */
          function get() {
            return this.database.collections;
          }
        )
        // TODO: Deprecate
      }, {
        key: "database",
        get: function get() {
          return this.collection.database;
        }
        /**
         * `Database` this record is associated with
         */
      }, {
        key: "db",
        get: function get() {
          return this.collection.database;
        }
      }, {
        key: "asModel",
        get: function get() {
          return this;
        }
        /**
         * Table name of this record
         */
      }, {
        key: "table",
        get: function get() {
          return this.constructor.table;
        }
      }, {
        key: "__debugName",
        get: function get() {
          return "".concat(this.table, "#").concat(this.id);
        }
      }]);
    })();
    Model.associations = {};
    Model._wmelonTag = "model";
  }
});

// node_modules/@nozbe/watermelondb/index.js
var require_watermelondb = __commonJS({
  "node_modules/@nozbe/watermelondb/index.js"(exports) {
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.tableSchema = exports.tableName = exports.localStorageKey = exports.columnName = exports.associations = exports.appSchema = exports.Relation = exports.Query = exports.Q = exports.Model = exports.Database = exports.Collection = void 0;
    var Q = _interopRequireWildcard(require_QueryDescription());
    exports.Q = Q;
    var _Collection = _interopRequireDefault(require_Collection());
    exports.Collection = _Collection.default;
    var _Database = _interopRequireDefault(require_Database());
    exports.Database = _Database.default;
    var _Relation = _interopRequireDefault(require_Relation());
    exports.Relation = _Relation.default;
    var _Model = _interopRequireWildcard(require_Model());
    exports.Model = _Model.default;
    exports.associations = _Model.associations;
    var _Query = _interopRequireDefault(require_Query());
    exports.Query = _Query.default;
    var _Schema = require_Schema();
    exports.tableName = _Schema.tableName;
    exports.columnName = _Schema.columnName;
    exports.appSchema = _Schema.appSchema;
    exports.tableSchema = _Schema.tableSchema;
    var _LocalStorage = require_LocalStorage();
    exports.localStorageKey = _LocalStorage.localStorageKey;
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
  }
});
export default require_watermelondb();
//# sourceMappingURL=@nozbe_watermelondb.js.map
