import {
  require_arrayOrSpread,
  require_extends,
  require_fp,
  require_interopRequireDefault,
  require_invariant,
  require_toConsumableArray
} from "./chunk-UA6MBTDI.js";
import {
  __commonJS
} from "./chunk-OL46QLBJ.js";

// node_modules/@nozbe/watermelondb/utils/fp/checkName/index.js
var require_checkName = __commonJS({
  "node_modules/@nozbe/watermelondb/utils/fp/checkName/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = checkName;
    var _invariant = _interopRequireDefault(require_invariant());
    var safeNameCharacters = /^[a-zA-Z_]\w*$/;
    var knownSafeNames = /* @__PURE__ */ new Set();
    function checkName(name) {
      if (knownSafeNames.has(name)) {
        return name;
      }
      (0, _invariant.default)("string" === typeof name, "Unsafe name '".concat(name, "' not allowed (not a string)"));
      (0, _invariant.default)(!["__proto__", "constructor", "prototype", "hasOwnProperty", "isPrototypeOf", "toString", "toLocaleString", "valueOf"].includes(name), "Unsafe name '".concat(name, "' not allowed (Object prototype property)"));
      (0, _invariant.default)("$loki" !== name.toLowerCase(), "Unsafe name '".concat(name, "' not allowed (reserved for LokiJS compatibility)"));
      (0, _invariant.default)(!["rowid", "oid", "_rowid_", "sqlite_master"].includes(name.toLowerCase()), "Unsafe name '".concat(name, "' not allowed (reserved for SQLite compatibility)"));
      (0, _invariant.default)(!name.toLowerCase().startsWith("sqlite_stat"), "Unsafe name '".concat(name, "' not allowed (reserved for SQLite compatibility)"));
      (0, _invariant.default)(!name.startsWith("__"), "Unsafe name '".concat(name, "' not allowed (names starting with '__' are reserved for internal purposes)"));
      (0, _invariant.default)(safeNameCharacters.test(name), "Unsafe name '".concat(name, "' not allowed (names must contain only safe characters ").concat(safeNameCharacters.toString(), ")"));
      knownSafeNames.add(name);
      return name;
    }
  }
});

// node_modules/@nozbe/watermelondb/QueryDescription/operators.js
var require_operators = __commonJS({
  "node_modules/@nozbe/watermelondb/QueryDescription/operators.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.asc = exports.and = void 0;
    exports.between = between;
    exports.column = column;
    exports.desc = void 0;
    exports.eq = eq;
    exports.experimentalJoinTables = experimentalJoinTables;
    exports.experimentalNestedJoin = experimentalNestedJoin;
    exports.gt = gt;
    exports.gte = gte;
    exports.includes = includes;
    exports.like = like;
    exports.lt = lt;
    exports.lte = lte;
    exports.notEq = notEq;
    exports.notIn = notIn;
    exports.notLike = notLike;
    exports.on = void 0;
    exports.oneOf = oneOf;
    exports.or = void 0;
    exports.sanitizeLikeString = sanitizeLikeString;
    exports.skip = skip;
    exports.sortBy = sortBy;
    exports.take = take;
    exports.unsafeLokiExpr = unsafeLokiExpr;
    exports.unsafeLokiTransform = unsafeLokiTransform;
    exports.unsafeSqlExpr = unsafeSqlExpr;
    exports.unsafeSqlQuery = unsafeSqlQuery;
    exports.weakGt = weakGt;
    exports.where = where;
    var _invariant = _interopRequireDefault(require_invariant());
    var _checkName = _interopRequireDefault(require_checkName());
    var _arrayOrSpread = _interopRequireDefault(require_arrayOrSpread());
    function eq(valueOrColumn) {
      return {
        operator: "eq",
        right: _valueOrColumn(valueOrColumn),
        type: comparisonSymbol
      };
    }
    function notEq(valueOrColumn) {
      return {
        operator: "notEq",
        right: _valueOrColumn(valueOrColumn),
        type: comparisonSymbol
      };
    }
    function gt(valueOrColumn) {
      return {
        operator: "gt",
        right: _valueOrColumn(valueOrColumn),
        type: comparisonSymbol
      };
    }
    function gte(valueOrColumn) {
      return {
        operator: "gte",
        right: _valueOrColumn(valueOrColumn),
        type: comparisonSymbol
      };
    }
    function weakGt(valueOrColumn) {
      return {
        operator: "weakGt",
        right: _valueOrColumn(valueOrColumn),
        type: comparisonSymbol
      };
    }
    function lt(valueOrColumn) {
      return {
        operator: "lt",
        right: _valueOrColumn(valueOrColumn),
        type: comparisonSymbol
      };
    }
    function lte(valueOrColumn) {
      return {
        operator: "lte",
        right: _valueOrColumn(valueOrColumn),
        type: comparisonSymbol
      };
    }
    function oneOf(values) {
      (0, _invariant.default)(Array.isArray(values), "argument passed to oneOf() is not an array");
      Object.freeze(values);
      return {
        operator: "oneOf",
        right: {
          values
        },
        type: comparisonSymbol
      };
    }
    function notIn(values) {
      (0, _invariant.default)(Array.isArray(values), "argument passed to notIn() is not an array");
      Object.freeze(values);
      return {
        operator: "notIn",
        right: {
          values
        },
        type: comparisonSymbol
      };
    }
    function between(left, right) {
      (0, _invariant.default)("number" === typeof left && "number" === typeof right, "Values passed to Q.between() are not numbers");
      return {
        operator: "between",
        right: {
          values: [left, right]
        },
        type: comparisonSymbol
      };
    }
    function like(value) {
      (0, _invariant.default)("string" === typeof value, "Value passed to Q.like() is not a string");
      return {
        operator: "like",
        right: {
          value
        },
        type: comparisonSymbol
      };
    }
    function notLike(value) {
      (0, _invariant.default)("string" === typeof value, "Value passed to Q.notLike() is not a string");
      return {
        operator: "notLike",
        right: {
          value
        },
        type: comparisonSymbol
      };
    }
    var nonLikeSafeRegexp = /[^a-zA-Z0-9]/g;
    function sanitizeLikeString(value) {
      (0, _invariant.default)("string" === typeof value, "Value passed to Q.sanitizeLikeString() is not a string");
      return value.replace(nonLikeSafeRegexp, "_");
    }
    function includes(value) {
      (0, _invariant.default)("string" === typeof value, "Value passed to Q.includes() is not a string");
      return {
        operator: "includes",
        right: {
          value
        },
        type: comparisonSymbol
      };
    }
    function column(name) {
      (0, _invariant.default)("string" === typeof name, "Name passed to Q.column() is not a string");
      return {
        column: (0, _checkName.default)(name),
        type: columnSymbol
      };
    }
    function _valueOrComparison(arg) {
      if (null === arg || "object" !== typeof arg) {
        return _valueOrComparison(eq(arg));
      }
      (0, _invariant.default)(arg.type === comparisonSymbol, "Invalid Comparison passed to Query builder. You seem to be passing unsanitized user data to Query builder!");
      var {
        operator,
        right
      } = arg;
      return {
        operator,
        right
      };
    }
    function where(left, valueOrComparison) {
      return {
        type: "where",
        left: (0, _checkName.default)(left),
        comparison: _valueOrComparison(valueOrComparison)
      };
    }
    function unsafeSqlExpr(sql) {
      if (true) {
        (0, _invariant.default)("string" === typeof sql, "Value passed to Q.unsafeSqlExpr is not a string");
      }
      return {
        type: "sql",
        expr: sql
      };
    }
    function unsafeLokiExpr(expr) {
      if (true) {
        (0, _invariant.default)(expr && "object" === typeof expr && !Array.isArray(expr), "Value passed to Q.unsafeLokiExpr is not an object");
      }
      return {
        type: "loki",
        expr
      };
    }
    function unsafeLokiTransform(fn) {
      return {
        type: "lokiTransform",
        function: fn
      };
    }
    var and = exports.and = function(...args) {
      var clauses = (0, _arrayOrSpread.default)(args, "Q.and()", "Where");
      validateConditions(clauses);
      return {
        type: "and",
        conditions: clauses
      };
    };
    var or = exports.or = function(...args) {
      var clauses = (0, _arrayOrSpread.default)(args, "Q.or()", "Where");
      validateConditions(clauses);
      return {
        type: "or",
        conditions: clauses
      };
    };
    var asc = exports.asc = "asc";
    var desc = exports.desc = "desc";
    function sortBy(sortColumn, sortOrder = asc) {
      (0, _invariant.default)("asc" === sortOrder || "desc" === sortOrder, "Invalid sortOrder argument received in Q.sortBy (valid: asc, desc)");
      return {
        type: "sortBy",
        sortColumn: (0, _checkName.default)(sortColumn),
        sortOrder
      };
    }
    function take(count) {
      (0, _invariant.default)("number" === typeof count, "Value passed to Q.take() is not a number");
      return {
        type: "take",
        count
      };
    }
    function skip(count) {
      (0, _invariant.default)("number" === typeof count, "Value passed to Q.skip() is not a number");
      return {
        type: "skip",
        count
      };
    }
    var _on = exports.on = function(table, leftOrClauseOrList, valueOrComparison) {
      if ("string" === typeof leftOrClauseOrList) {
        (0, _invariant.default)(valueOrComparison !== void 0, "illegal `undefined` passed to Q.on");
        return _on(table, [where(leftOrClauseOrList, valueOrComparison)]);
      }
      var clauseOrList = leftOrClauseOrList;
      if (Array.isArray(clauseOrList)) {
        var conditions = clauseOrList;
        validateConditions(conditions);
        return {
          type: "on",
          table: (0, _checkName.default)(table),
          conditions
        };
      } else if (clauseOrList && "and" === clauseOrList.type) {
        return _on(table, clauseOrList.conditions);
      }
      return _on(table, [clauseOrList]);
    };
    function experimentalJoinTables(tables) {
      (0, _invariant.default)(Array.isArray(tables), "experimentalJoinTables expected an array");
      return {
        type: "joinTables",
        tables: tables.map(_checkName.default)
      };
    }
    function experimentalNestedJoin(from, to) {
      return {
        type: "nestedJoinTable",
        from: (0, _checkName.default)(from),
        to: (0, _checkName.default)(to)
      };
    }
    function unsafeSqlQuery(sql, values = []) {
      if (true) {
        (0, _invariant.default)("string" === typeof sql, "Value passed to Q.unsafeSqlQuery is not a string");
        (0, _invariant.default)(Array.isArray(values), "Placeholder values passed to Q.unsafeSqlQuery are not an array");
      }
      return {
        type: "sqlQuery",
        sql,
        values
      };
    }
    var columnSymbol = Symbol("Q.column");
    var comparisonSymbol = Symbol("QueryComparison");
    function _valueOrColumn(arg) {
      if (null === arg || "object" !== typeof arg) {
        (0, _invariant.default)(arg !== void 0, "Cannot compare to undefined in a Query. Did you mean null?");
        return {
          value: arg
        };
      }
      if ("string" === typeof arg.column) {
        (0, _invariant.default)(arg.type === columnSymbol, "Invalid { column: } object passed to Watermelon query. You seem to be passing unsanitized user data to Query builder!");
        return {
          column: arg.column
        };
      }
      throw new Error("Invalid value passed to query");
    }
    var acceptableClauses = ["where", "and", "or", "on", "sql", "loki"];
    var isAcceptableClause = function(clause) {
      return acceptableClauses.includes(clause.type);
    };
    var validateConditions = function(clauses) {
      if (true) {
        (0, _invariant.default)(clauses.every(isAcceptableClause), "Q.and(), Q.or(), Q.on() can only contain: Q.where, Q.and, Q.or, Q.on, Q.unsafeSqlExpr, Q.unsafeLokiExpr clauses");
      }
    };
  }
});

// node_modules/@nozbe/watermelondb/utils/common/deepFreeze/index.js
var require_deepFreeze = __commonJS({
  "node_modules/@nozbe/watermelondb/utils/common/deepFreeze/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.default = deepFreeze;
    var _invariant = _interopRequireDefault(require_invariant());
    function deepFreeze(object) {
      (0, _invariant.default)(object && "object" === typeof object, "Invalid attempt to deepFreeze not-an-Object");
      Object.getOwnPropertyNames(object).forEach(function(name) {
        var value = object[name];
        if (value && "object" === typeof value) {
          deepFreeze(value);
        }
      });
      return Object.freeze(object);
    }
  }
});

// node_modules/@nozbe/watermelondb/Schema/index.js
var require_Schema = __commonJS({
  "node_modules/@nozbe/watermelondb/Schema/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.appSchema = appSchema;
    exports.columnName = columnName;
    exports.tableName = tableName;
    exports.tableSchema = tableSchema;
    exports.validateColumnSchema = validateColumnSchema;
    var _invariant = _interopRequireDefault(require_invariant());
    function tableName(name) {
      return name;
    }
    function columnName(name) {
      return name;
    }
    function appSchema({
      version,
      tables: tableList,
      unsafeSql
    }) {
      if (true) {
        (0, _invariant.default)(0 < version, "Schema version must be greater than 0");
      }
      var tables = tableList.reduce(function(map, table) {
        if (true) {
          (0, _invariant.default)("object" === typeof table && table.name, "Table schema must contain a name");
        }
        map[table.name] = table;
        return map;
      }, {});
      return {
        version,
        tables,
        unsafeSql
      };
    }
    var validateName = function(name) {
      if (true) {
        (0, _invariant.default)(!["id", "_changed", "_status", "local_storage"].includes(name.toLowerCase()), "Invalid column or table name '".concat(name, "' - reserved by WatermelonDB"));
        var checkName = require_checkName().default;
        checkName(name);
      }
    };
    function validateColumnSchema(column) {
      if (true) {
        (0, _invariant.default)(column.name, "Missing column name");
        validateName(column.name);
        (0, _invariant.default)(["string", "boolean", "number"].includes(column.type), "Invalid type ".concat(column.type, " for column '").concat(column.name, "' (valid: string, boolean, number)"));
        if ("created_at" === column.name || "updated_at" === column.name) {
          (0, _invariant.default)("number" === column.type && !column.isOptional, "".concat(column.name, " must be of type number and not optional"));
        }
        if ("last_modified" === column.name) {
          (0, _invariant.default)("number" === column.type, "For compatibility reasons, column last_modified must be of type 'number', and should be optional");
        }
      }
    }
    function tableSchema({
      name,
      columns: columnArray,
      unsafeSql
    }) {
      if (true) {
        (0, _invariant.default)(name, "Missing table name in schema");
        validateName(name);
      }
      var columns = columnArray.reduce(function(map, column) {
        if (true) {
          validateColumnSchema(column);
        }
        map[column.name] = column;
        return map;
      }, {});
      return {
        name,
        columns,
        columnArray,
        unsafeSql
      };
    }
  }
});

// node_modules/@nozbe/watermelondb/QueryDescription/helpers.js
var require_helpers = __commonJS({
  "node_modules/@nozbe/watermelondb/QueryDescription/helpers.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    exports.__esModule = true;
    exports.buildQueryDescription = buildQueryDescription;
    exports.queryWithoutDeleted = queryWithoutDeleted;
    var _extends2 = _interopRequireDefault(require_extends());
    var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
    var _fp = require_fp();
    var _invariant = _interopRequireDefault(require_invariant());
    var _deepFreeze = _interopRequireDefault(require_deepFreeze());
    var _Schema = require_Schema();
    var _operators = require_operators();
    var syncStatusColumn = (0, _Schema.columnName)("_status");
    var extractClauses = function(clauses) {
      var query = {
        where: [],
        joinTables: [],
        nestedJoinTables: [],
        sortBy: []
      };
      clauses.forEach(function(clause) {
        switch (clause.type) {
          case "where":
          case "and":
          case "or":
          case "sql":
          case "loki":
            query.where.push(clause);
            break;
          case "on": {
            var {
              table
            } = clause;
            query.joinTables.push(table);
            query.where.push(clause);
            break;
          }
          case "sortBy":
            query.sortBy.push(clause);
            break;
          case "take":
            query.take = clause.count;
            break;
          case "skip":
            query.skip = clause.count;
            break;
          case "joinTables": {
            var _query$joinTables;
            var {
              tables
            } = clause;
            (_query$joinTables = query.joinTables).push.apply(_query$joinTables, (0, _toConsumableArray2.default)(tables));
            break;
          }
          case "nestedJoinTable":
            query.nestedJoinTables.push({
              from: clause.from,
              to: clause.to
            });
            break;
          case "lokiTransform":
            query.lokiTransform = clause.function;
            break;
          case "sqlQuery":
            query.sql = clause;
            if (true) {
              (0, _invariant.default)(clauses.every(function(_clause) {
                return ["sqlQuery", "joinTables", "nestedJoinTable"].includes(_clause.type);
              }), "Cannot use Q.unsafeSqlQuery with other clauses, except for Q.experimentalJoinTables and Q.experimentalNestedJoin (Did you mean Q.unsafeSqlExpr?)");
            }
            break;
          default:
            throw new Error("Invalid Query clause passed");
        }
      });
      query.joinTables = (0, _fp.unique)(query.joinTables);
      return query;
    };
    function buildQueryDescription(clauses) {
      var query = extractClauses(clauses);
      if (true) {
        (0, _invariant.default)(!(query.skip && !query.take), "cannot skip without take");
        (0, _deepFreeze.default)(query);
      }
      return query;
    }
    var whereNotDeleted = (0, _operators.where)(syncStatusColumn, (0, _operators.notEq)("deleted"));
    function conditionsWithoutDeleted(conditions) {
      return conditions.map(queryWithoutDeletedImpl);
    }
    function queryWithoutDeletedImpl(clause) {
      if ("and" === clause.type) {
        return {
          type: "and",
          conditions: conditionsWithoutDeleted(clause.conditions)
        };
      } else if ("or" === clause.type) {
        return {
          type: "or",
          conditions: conditionsWithoutDeleted(clause.conditions)
        };
      } else if ("on" === clause.type) {
        var onClause = clause;
        return {
          type: "on",
          table: onClause.table,
          conditions: conditionsWithoutDeleted(onClause.conditions).concat(whereNotDeleted)
        };
      }
      return clause;
    }
    function queryWithoutDeleted(query) {
      var {
        where: whereConditions
      } = query;
      var newQuery = (0, _extends2.default)({}, query, {
        where: conditionsWithoutDeleted(whereConditions).concat(whereNotDeleted)
      });
      if (true) {
        (0, _deepFreeze.default)(newQuery);
      }
      return newQuery;
    }
  }
});

// node_modules/@nozbe/watermelondb/QueryDescription/index.js
var require_QueryDescription = __commonJS({
  "node_modules/@nozbe/watermelondb/QueryDescription/index.js"(exports) {
    exports.__esModule = true;
    exports.where = exports.weakGt = exports.unsafeSqlQuery = exports.unsafeSqlExpr = exports.unsafeLokiTransform = exports.unsafeLokiExpr = exports.take = exports.sortBy = exports.skip = exports.sanitizeLikeString = exports.queryWithoutDeleted = exports.or = exports.oneOf = exports.on = exports.notLike = exports.notIn = exports.notEq = exports.lte = exports.lt = exports.like = exports.includes = exports.gte = exports.gt = exports.experimentalNestedJoin = exports.experimentalJoinTables = exports.eq = exports.desc = exports.column = exports.buildQueryDescription = exports.between = exports.asc = exports.and = void 0;
    var _operators = require_operators();
    exports.eq = _operators.eq;
    exports.notEq = _operators.notEq;
    exports.gt = _operators.gt;
    exports.gte = _operators.gte;
    exports.weakGt = _operators.weakGt;
    exports.lt = _operators.lt;
    exports.lte = _operators.lte;
    exports.oneOf = _operators.oneOf;
    exports.notIn = _operators.notIn;
    exports.between = _operators.between;
    exports.like = _operators.like;
    exports.notLike = _operators.notLike;
    exports.sanitizeLikeString = _operators.sanitizeLikeString;
    exports.includes = _operators.includes;
    exports.column = _operators.column;
    exports.where = _operators.where;
    exports.unsafeSqlExpr = _operators.unsafeSqlExpr;
    exports.unsafeLokiExpr = _operators.unsafeLokiExpr;
    exports.unsafeLokiTransform = _operators.unsafeLokiTransform;
    exports.and = _operators.and;
    exports.or = _operators.or;
    exports.asc = _operators.asc;
    exports.desc = _operators.desc;
    exports.sortBy = _operators.sortBy;
    exports.take = _operators.take;
    exports.skip = _operators.skip;
    exports.on = _operators.on;
    exports.experimentalJoinTables = _operators.experimentalJoinTables;
    exports.experimentalNestedJoin = _operators.experimentalNestedJoin;
    exports.unsafeSqlQuery = _operators.unsafeSqlQuery;
    var _helpers = require_helpers();
    exports.buildQueryDescription = _helpers.buildQueryDescription;
    exports.queryWithoutDeleted = _helpers.queryWithoutDeleted;
  }
});

export {
  require_Schema,
  require_QueryDescription
};
//# sourceMappingURL=chunk-7IBXDPTB.js.map
